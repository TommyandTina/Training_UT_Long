; This is the comment
[PATH]
; TODO: Current support is just 1 excel file.
;InputPath				= "C:\\Users\\thanhto\\Desktop\\UT\\IMPFW\\IMPF_X30_Unit_Test_Specification_local.xlsx"
;InputPath				= "C:\\Users\\thanhto\\Desktop\\UT\\IMPFW\\IMPF_X30_Unit_Test_Specification-Updated-Jun09.xlsx"
;InputPath				= "C:\\Users\\thanhto\\Desktop\\UT\\IMPFW\\IMPF_X30_Unit_Test_Specification_svn_local.xlsx"
;InputPath				=   "C:\\Users\\thanhto\\Desktop\\UT\\IMPF_X30_Unit_Test_Specification.xlsx"
InputPath				= "C:\\Users\\thanhto\\Desktop\\UT\\IMPFW\\IMPF_X30_Unit_Test_Specification_Updated_Jun20.xlsx"
;InputPath				= "C:\\Users\\thanhto\\Desktop\\ss2_imp_xos3\\trunk\\xOS3.0_IMPPAPDSP_common\\06_Unit_Test\\01_Test_Specification\\02_IMPFW\\IMPF_X30_Unit_Test_Specification.xlsx"
; Parent directory/ Base folder
; Ex: ${Workspace}/ut_framework
OutputPath            = "C:\\Users\\thanhto\\Desktop\\UTS Tool\\ut_framework"
;OutputPath            = "C:\\Users\\thanhto\\Desktop\\UTS Tool\\tmp"

[TARGET_OF_TESTING]
; Finding sheet contain test data (depend on prj)
TargetModule          = 'impfw'
FindByPrefix          = False
Prefix                = ['R_IMPFW']
SheetNameContainData  = [	
							; 'impfw_api_chk_interrupt_mask',
							; 'impfw_api_chk_interrupt_allmask',
							; 'impfw_api_chk_interrupt_info',
							; 'impfw_api_chk_priority',
							; 'impfw_api_chk_instance_num',
							; 'impfw_api_chk_init_data',
							; 'impfw_api_chk_init_dspdata',
							; 'impfw_api_chk_init_busifchk',
							; 'impfw_api_chk_init_corechk',
							; 'R_IMPFW_IoDeviceRequired',
							; 'R_IMPFW_IoDeviceWrite32',
							; 'R_IMPFW_IoDeviceRead32',
							; 'R_IMPFW_GetIoDeviceInfo',
							; 'impfw_api_chk_init_safetydata',
							; 'impfw_api_chk_core_info',
							; 'R_IMPFW_SetPmPolicy',
							; 'R_IMPFW_Resume',
							; 'R_IMPFW_Quit',
							; 'R_IMPFW_InitSafety',
							; 'R_IMPFW_InitDsp',
							; 'R_IMPFW_Init',
							; 'R_IMPFW_GetVersion',
							; 'R_IMPFW_AttrSetRtt',
							; 'R_IMPFW_AttrSetPair',
							; 'R_IMPFW_AttrSetInterrupt',
							; 'R_IMPFW_AttrSetCl',
							; 'R_IMPFW_AttrSetCoremap',
							; 'R_IMPFW_AttrSetDsp',
							; 'R_IMPFW_AttrInit',
							; 'R_IMPFW_Execute',
							; 'R_IMPFW_InitSafetyOtherRtt',
							; 'R_IMPFW_SelfChkExecute',
							; 'impfw_mainctl_task_set_clctrl',
							; 'ut_mainctl_task_start_rtt_sub',
							; 'impfw_mainctl_attr_setclctrl',
							; 'R_IMPFW_AttrSetClCtrlInfo',
							; 'R_IMPFW_SetClCtrlInfo',
							 'impfw_quectl_dequeue',
							'impfw_quectl_enqueue',
							; 'impfw_quectl_get_next_req',
						]

; Define type is function pointer
[DATA_TYPE]
ListPointerType 		= [
							'impdrv_ctrl_handle_t','p_impfw_drvwrap_cb_t', \
							'impfw_attr_handle_t', \
							'osal_mq_handle_t','osal_device_handle_t', \
							'osal_mutex_handle_t', 'osal_thread_handle_t', \
							'p_impfw_thread_func_t','p_impfw_cbfunc_fatal_t', \
							'p_impfw_mainctl_cb_t','impfw_ctrl_handle_t', 'p_impfw_cbfunc_t', \
							'p_impfw_selfchk_cb_t', \
							'p_impfw_rttwrap_cb_t', \
							'p_hwartt_cbfunc_fatal_t', \
							'p_hwartt_cbfunc_t', \
							'osal_memory_buffer_handle_t',\
							'e_impfw_mutex_type_t',\
						]

[SPECIAL_STRING]
NOT_NULL_VALUE 		= 'not null'
NULL_VALUE 			= 'null'
NOT_STUB_VALUE 		= 'not stub'
NOT_CHANGE_VALUE    = 'not change'

###################################################################################################
################################## Test code configuration ########################################
###################################################################################################
[OUTPUT_GENERATION_CONTROL]
;Flag EnableImportData is enable, it will import data from INIT_ADDR_DATA, user need to create key INIT_ADDR_DATA for inialized data.
;Flag EnableTestCode is enable when the user want to generate Test code
;Flag EnableTestData is enable when the user want to generate Test data
EnableImportData = True
EnableTestCode = True
EnableTestData = True
EnableFileGenerate = False

; Key INIT_ADDR_DATA to identify input data from file config if module is used by Semi auto tool.
INIT_ADDR_DATA = {
	"init attribute"        			: [	"init_R_IMPFW_Attribute"	        	, ["attrhandle"], [ "0", "g_attr_core_info"] ],    
	"seq attrstate"         			: [	"seq_R_IMPFW_Attribute"	        		, ["attrhandle"], [ "0", "g_attr_core_info"]	],
	"core state wait"       			: [	"wait_R_IMPFW_Attribute"	        	, ["attrhandle"], [ "0", "g_attr_core_info"]	],
	"core state execute"    			: [	"execute_R_IMPFW_Attribute"	        	, ["attrhandle"], [ "0", "g_attr_core_info"]	],
	"core state int"        			: [	"int_R_IMPFW_Attribute"	        		, ["attrhandle"], [ "0", "g_attr_core_info"]	],
	"attr state uninit"     			: [	"attr_uninit_R_IMPFW_Attribute"	        , ["attrhandle"], [ "0", "g_attr_core_info"]	],
	"attr state using"      			: [	"attr_using_R_IMPFW_Attribute"	        , ["attrhandle"], [ "0", "g_attr_core_info"]	],
	"init pair req"    					: [ "init_impfw_quectl_get_pair_request"  	, ["p_quectl_work"] ],
	"init next req"    					: [ "init_impfw_quectl_get_next_request"   	, ["p_quectl_work"],[ "0", "g_next_priority"], [ "0", "g_head_priority"], [ "0", "g_que_cnt"], [ "0", "g_p_target_req"] ],
	"init enqueue"    					: [ "init_impfw_quectl_enqueue"   			, ["p_quectl_work"],[ "0", "g_p_free"], [ "0", "g_p_head"], [ "0", "g_p_tail"], [ "0", "g_que_cnt"] ],
	
	"init cl next req for mainwork" 	: [ "init_next_request_mainctl_work_cl" 	, ["p_main_work", "p_cbargs"]],
	"init rtt next req for mainwork" 	: [ "init_next_request_mainctl_work_rtt" 	, ["p_main_work"]],
	"init err next req for mainwork" 	: [ "init_next_request_mainctl_work_err" 	, ["p_main_work"]],
	"uninit next req for mainwork" 		: [ "uninit_next_request_mainctl_work" 		, ["p_main_work"]],
	"init workspace for mainwork" 		: [ "init_workspace_mainctl_work_cl" 		, ["p_main_work"]],
	"null safety work for mainwork"		: [ "init_null_safety_mainctl_work"			, ["p_main_work"]],
	"null hwartt handle for mainwork"	: [ "init_null_hwartt_handle_mainctl_work"	, ["p_main_work"]],
	"init start_bit for mainwork" 		: [ "init_start_bit_mainctl_work_cl" 		, ["p_main_work"]],
	"null callback for mainwork"		: [ "null_callback_mainctl_work_cl"			, ["p_main_work"]],
	"null quectl for mainwork"			: [ "null_quectl_mainctl_work_cl"			, ["p_main_work"]],
	"execute next req for mainwork"		: [ "exec_next_request_mainctl_work_cl"		, ["p_main_work"]],
	"execute next req rtt for mainwork"	: [ "exec_next_request_mainctl_work_rtt"	, ["p_main_work"]],
	"init rtt start_core_bits" 			: [ "init_rtt_mainctl_start_core_bits"		, ["p_main_work"]],
	"init_cl_non_pair"					: [ "init_cl_non_pair"						, ["p_main_work"]],
	"init_rtt_non_pair"					: [ "init_rtt_non_pair"						, ["p_main_work"]],
	"init attr size"					: [ "init_attr_size_mainctl_work"			, ["p_main_work"]],
	"null next request"					: [ "init_null_next_request"				, ["p_main_work"]],
	"init start cl"						: [ "init_start_cl_sub"						, ["p_main_work"]],
	"init safety mainwork"				: [ "init_safety_mainctl_work"				, ["p_main_work"]],
	"init task execute req"				: [ "init_task_execute_req"					, ["p_main_work"]],
	"init p safety mainwork"			: [ "init_p_safety_mainctl_work"			, ["p_main_work"]],
	"drvwrap null safetywork"			: [ "null_drvwrap_safety_mainctl_work"		, ["p_main_work"]],

	"init p drvwrap work"				: [ "init_p_drvwrap_work"					, ["p_drvwrap_work"]],
	"null p drvwrap work"				: [ "null_drvwrap_safety_mainctl_work"		, ["p_drvwrap_work"]],

	"init exec req"						: [ "init_exec_request"						, ["p_exec_req"]],
	"invalid exec num req"				: [ "invalid_exec_num_request"				, ["p_exec_req"]],
	"invalid curr req idx"				: [ "invalid_curr_request_idx"				, ["p_exec_req"]],
	"invalid req list"					: [ "invalid_request_list"					, ["p_exec_req"]],
	"invalid core type req"				: [ "invalid_core_type_request"				, ["p_exec_req"]],

	"init req info"						: [ "init_request_info"						, ["p_req_info"]],
	"null attrinfo for req info"		: [ "null_attrinfo_request_info"			, ["p_req_info"]],
	"null safety for req info"			: [ "null_safety_request_info"				, ["p_req_info"]],
	"init main work for drv start"		: [ "init_mainctl_work_for_drv_start"		, ["p_main_work"]],
	"init attribute v4hx"				: [ "init_R_IMPFW_Attribute_V4Hx"			, ["attrhandle"], [ "0", "g_attr_core_info"]],
	"core state wait v4hx"				: [ "wait_R_IMPFW_Attribute_V4Hx"			, ["attrhandle"], [ "0", "g_attr_core_info"]],
	"core state execute v4hx"			: [ "execute_R_IMPFW_Attribute_V4Hx"		, ["attrhandle"], [ "0", "g_attr_core_info"]],
	"core state int v4hx"				: [ "int_R_IMPFW_Attribute_V4Hx"			, ["attrhandle"], [ "0", "g_attr_core_info"]],
	"attr state uninit v4hx"     		: [	"attr_uninit_R_IMPFW_Attribute_V4Hx"	, ["attrhandle"], [ "0", "g_attr_core_info"]],
	"attr state using v4hx"      		: [	"attr_using_R_IMPFW_Attribute_V4Hx"	    , ["attrhandle"], [ "0", "g_attr_core_info"]],
	"init attribute dsp"				: ["init_R_IMPFW_Attribute_Dsp"				, ["p_attrhandle"], [ "0", "g_use_state"], ["0", "g_attr_core_info"], ["0", "g_attr_num"]],
	"dsp core state wait"				: ["wait_R_IMPFW_Attribute_Dsp"				, ["p_attrhandle"], [ "0", "g_use_state"], ["0", "g_attr_core_info"], ["0", "g_attr_num"]],
	"dsp core state execute"			: ["execute_R_IMPFW_Attribute_Dsp"			, ["p_attrhandle"], [ "0", "g_use_state"], ["0", "g_attr_core_info"], ["0", "g_attr_num"]],
	"dsp core state int"				: ["int_R_IMPFW_Attribute_Dsp"				, ["p_attrhandle"], [ "0", "g_use_state"], ["0", "g_attr_core_info"], ["0", "g_attr_num"]],	
	"dsp work null"						: ["dsp_work_null"							, ["p_attrhandle"], [ "0", "g_use_state"], ["0", "g_attr_core_info"], ["0", "g_attr_num"]],
	"attr info null"					: ["attr_info_null"							, ["p_attrhandle"], [ "0", "g_use_state"], ["0", "g_attr_core_info"], ["0", "g_attr_num"]],
	"dsp core state uninit"				: ["uninit_core_state_dsp"					, ["p_attrhandle"], [ "0", "g_use_state"], ["0", "g_attr_core_info"], ["0", "g_attr_num"]],
	"mutex handle"						: ["mutex_handle_dsp"						, ["p_attrhandle"], [ "0", "g_use_state"], ["0", "g_attr_core_info"], ["0", "g_attr_num"]],
	"mutex timeout"						: ["mutex_timeout_dsp"						, ["p_attrhandle"], [ "0", "g_use_state"], ["0", "g_attr_core_info"], ["0", "g_attr_num"]],
	"init mainwork for set cl ctrl" 	: [ "init_mainctl_work_for_set_clctrl" 	    , ["p_main_work"]],
	"uninit state mainwork for set cl ctrl" 	: [ "uninit_state_mainctl_work_for_set_clctrl" 	    , ["p_main_work"]],
	"ready state mainwork for set cl ctrl" 		: [ "ready_state_mainctl_work_for_set_clctrl" 	    , ["p_main_work"]],
	"wait state mainwork for set cl ctrl" 		: [ "wait_state_mainctl_work_for_set_clctrl" 	    , ["p_main_work"]],
	"execute state mainwork for set cl ctrl" 	: [ "exec_state_mainctl_work_for_set_clctrl" 	    , ["p_main_work"]],
	"init cl rtt next req for mainwork" 		: [ "init_next_request_mainctl_work_cl_rtt"     	, ["p_main_work"]],
	"init cl next req for mainwork is_drv_on false" 	: [ "init_next_request_mainctl_work_is_drv_on_false"    	, ["p_main_work"]],
    "init cl next req for mainwork is_drv_on true rtt" 	: [ "init_next_request_mainctl_work_is_drv_on_true_rtt"  	, ["p_main_work"]],
	"enqueue null p_free->next" 		: [ "init_enqueue_null_p_free_next"   			, ["p_quectl_work"],[ "0", "g_p_free"], [ "0", "g_p_head"], [ "0", "g_p_tail"], [ "0", "g_que_cnt"] ],
	"enqueue null p free" 				: [ "init_enqueue_null_p_free_next"   			, ["p_quectl_work"],[ "0", "g_p_free"], [ "0", "g_p_head"], [ "0", "g_p_tail"], [ "0", "g_que_cnt"] ],
	}

[VALIDATOR]
;Key TABLE_VALIDATOR to identify marco Validator following type expected value in PCL.
;For a example, RCvDrvErrorCode is a type in PCL Driver, and convert to marco TEST_VALIDATOR_RETCODE
;With this marco TEST_VALIDATOR_RETCODE, it needs to implement function to check marco in Framework Tool.
TABLE_VALIDATOR_BY_TYPE = {
	"e_impfw_api_retcode_t" 		: "TEST_VALIDATOR_IMPFW_RETCODE",
	"e_impfw_core_state_t" 			: "TEST_VALIDATOR_STATE",
	"e_impfw_attr_state_type_t" 	: "TEST_VALIDATOR_ATTR_STATE",
	"e_impfw_req_private_type_t"	: "TEST_VALIDATOR_REQ_STATE",
	"e_impfw_drvwrap_mem_state_t"	: "TEST_VALIDATOR_DRV_MEM_STATE",
	"bool"							: "TEST_VALIDATOR_BOOLVALUE",
	"int32_t"						: "TEST_VALIDATOR_I32VALUE",
	"int64_t"						: "TEST_VALIDATOR_I64VALUE",
	"uint32_t"						: "TEST_VALIDATOR_U32VALUE",
	"uint64_t"						: "TEST_VALIDATOR_U64VALUE",
	"e_impfw_req_type_t"			: "TEST_VALIDATOR_REQUEST_TYPE",
	"e_impfw_core_type_t"			: "TEST_VALIDATOR_CORE_TYPE",
	"e_impfw_req_priority_t"		: "TEST_VALIDATOR_REQUEST_PRIORITY",
	"st_impfw_request_t"			: "TEST_VALIDATOR_ADDR",
	"p_impfw_cbfunc_t"				: "TEST_VALIDATOR_ADDR",
	"st_impfw_attrinfo_t"			: "TEST_VALIDATOR_ADDR",
	"osal_thread_handle_t"			: "TEST_VALIDATOR_ADDR",
	"osal_mq_handle_t"				: "TEST_VALIDATOR_ADDR",
	"osal_milli_sec_t"				: "TEST_VALIDATOR_I32VALUE",
	"size_t"						: "TEST_VALIDATOR_I32VALUE",
	"e_impfw_callback_reason_t"		: "TEST_VALIDATOR_CB_REASON",
	"p_impfw_selfchk_cb_t"			: "TEST_VALIDATOR_ADDR",
	"e_impdrv_reg_req_state_t"		: "TEST_VALIDATOR_REQ_REQ_STATE",
	"e_impdrv_irq_group_t"			: "TEST_VALIDATOR_DRV_IRQ_GROUP",
	"e_impdrv_instance_t"			: "TEST_VALIDATOR_DRV_INSTANCE",
	"impdrv_ctrl_handle_t"			: "TEST_VALIDATOR_ADDR",
	"p_impfw_drvwrap_cb_t"			: "TEST_VALIDATOR_ADDR",
	"impfw_ctrl_handle_t"			: "TEST_VALIDATOR_ADDR",
	"st_impfw_attrinfo_t"			: "TEST_VALIDATOR_ADDR",
	"st_impfw_version_t"			: "TEST_VALIDATOR_ADDR",
	"e_impfw_iodev_req_state_t"		: "TEST_VALIDATOR_IODEV_REQ_STATE",
	"p_impfw_cbfunc_fatal_t"		: "TEST_VALIDATOR_ADDR",
	"osal_mutex_handle_t"			: "TEST_VALIDATOR_ADDR",
	"osal_msg_handle_t"				: "TEST_VALIDATOR_ADDR",
	"osal_thread_handle_t"			: "TEST_VALIDATOR_ADDR",
    }
TABLE_VALIDATOR_BY_NAME = {
	"state"          : "TEST_VALIDATOR_STATE",
    }

[COMPARE]
LogPath = 'D:\\Workspace\\rcar-env_xOS2\\build_v3m2\\rcar-xos\\v2.0.0\\sw\\amd64-gnu-windows\\bin\\impfw_unit_test_on_target_v3m2_log.txt'
Revision = '261828d7_v3m2'
;Please fill your test report sheet
TestReportSheet = "Test_Report"