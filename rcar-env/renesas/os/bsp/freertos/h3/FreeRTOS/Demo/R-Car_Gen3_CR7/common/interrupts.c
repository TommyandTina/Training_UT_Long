/*
 * Copyright (c) 2019-2020 Renesas Electronics Europe Ltd. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 */

#include <stddef.h>
#include "cmsis_rcar_gen3.h"
#include "interrupts.h"
#include "irq_ctrl.h"
#include "register.h"

/* The R-Car Gen3 has two interrupt controllers related to the CR7.
 * The CR7 GIC only handles SGI (Software Generated Interrupt) and PPI (Private
 * Peripheral Interrupt), it does not handle SPI (Shared Peripheral Interrupt)
 * from peripheral modules Interrupt). For SPI, you need to use the INTC-RT.
 * The output of INTC-RT is an input to the CR7 GIC on PPI[4].
 *
 * We use the ARM CMSIS code to manage the INTC-RT GIC, whereas the FreeRTOS
 * interrupt related code just deals with the CR7 GIC.
 */

#define CR7_INTC_ROUTING_CTRL	0xE6271004U		/* INTCRTRCR */

#define CR7_GICD_ADDR			((void *)0xF0001000U)
#define CR7_GICC_ADDR			((void *)0xF0000100U)
#define CR7_GIC_NR_IRQS			32
#define CR7_GIC_ID_IRQ			31		/* PPI[4] - legacy nIRQ input, from INTC-RT */

#define INTC_RT_GICD_ADDR		((void *)0xF1110000U)
#define INTC_RT_GICC_ADDR		((void *)0xF1120000U)
#define INTC_RT_NR_IRQS			512

#define DEFAULT_ISR_PRIORITY    0xA0
#define ISR_PRIORITY_MASK		0xF0

typedef void (*IrqHandlerFn)(void *data);

typedef struct
{
	IrqHandlerFn Handler;
	void *Context;
} IvtEntry;

static IvtEntry HandlerTable[INTC_RT_NR_IRQS];

/* Special R-Car interrupt initialisation */
static void CR7GicInit(void)
{
	uint32_t val;

	/* Set 0th output signal of INTC-RT connect to CR7 */
	val = readl(CR7_INTC_ROUTING_CTRL);
	val |= BIT(8);
	writel(val, CR7_INTC_ROUTING_CTRL);

	GIC_Enable(CR7_GICD_ADDR, CR7_GICC_ADDR);

	/* Enable legacy nIRQ in CR7 GIC. This comes from the INTC-RT GIC */
	Irq_Enable(CR7_GIC_ID_IRQ);
	Irq_SetPriority(CR7_GIC_ID_IRQ, DEFAULT_ISR_PRIORITY);
}

void Irq_Setup(void)
{
	CR7GicInit();

	GIC_Enable(INTC_RT_GICD_ADDR, INTC_RT_GICC_ADDR);
}

/* Set up a CR7 or INTC-RT GIC entry */
void Irq_SetupEntry(unsigned int id, IrqHandlerFn Handler, void *Context)
{
	/* Just in case... */
	if (id >= INTC_RT_NR_IRQS)
		while (1)
			;

	HandlerTable[id].Handler = Handler;
	HandlerTable[id].Context = Context;

	Irq_SetPriority(id, DEFAULT_ISR_PRIORITY);
}

static void StubHandler(void *data)
{
	while (1)
		;
}

/* Remove a CR7 or INTC-RT GIC entry */
void Irq_RemoveEntry(unsigned int id)
{
	/* Just in case... */
	if (id >= INTC_RT_NR_IRQS)
		while (1)
			;

	Irq_Disable(id);

	HandlerTable[id].Handler = &StubHandler;
	HandlerTable[id].Context = NULL;
}

void Irq_Enable(unsigned int id)
{
	if (id <= CR7_GIC_ID_IRQ)
		GIC_EnableIRQ(CR7_GICD_ADDR, id);
	else
		GIC_EnableIRQ(INTC_RT_GICD_ADDR, id);
}
/* Legacy: IRQ_Enable should not be used */
int32_t IRQ_Enable (IRQn_ID_t irqn)
{
    Irq_Enable(irqn);
    return 0;
}

void Irq_Disable(unsigned int id)
{
	if (id <= CR7_GIC_ID_IRQ)
		GIC_DisableIRQ(CR7_GICD_ADDR, id);
	else
		GIC_DisableIRQ(INTC_RT_GICD_ADDR, id);
}
/* Legacy: IRQ_Disable should not be used */
int32_t IRQ_Disable (IRQn_ID_t irqn)
{
    Irq_Disable(irqn);
    return 0;
}

void Irq_SetPriority(unsigned int id, unsigned int priority)
{
	if (id <= CR7_GIC_ID_IRQ)
		GIC_SetPriority(CR7_GICD_ADDR, id, priority);
	else
		GIC_SetPriority(INTC_RT_GICD_ADDR, id, priority);
}

unsigned int FreeRTOS_GetActiveIRQ(void)
{
    return IRQ_GetActiveIRQ(CR7_GICD_ADDR, CR7_GICC_ADDR);
}

void FreeRTOS_EndOfInterrupt(unsigned int id)
{
    GIC_EndInterrupt(CR7_GICC_ADDR, id);
}

/* CR7 GIC interrupt handler that also checks the INTC-RT GIC */
void vApplicationIRQHandler(uint32_t ulICCIAR)
{
	/*
	 * Interrupts cannot be re-enabled until the source of the interrupt is
	 * cleared. The ID of the interrupt is obtained by bitwise ANDing the ICCIAR
	 * value with 0x3FF
	 */
	uint32_t id = ulICCIAR & 0x3FFU;
	IvtEntry *pEntry;

	/* If the interrupt is PPI[4], then the interrupt is generated by INTC-RT */
	if (id == CR7_GIC_ID_IRQ)
		id = IRQ_GetActiveIRQ(INTC_RT_GICD_ADDR, INTC_RT_GICC_ADDR);

	/* Note: the GIC can return ID=1023 under certain conditions:
	 *  - forwarding of interrupts by the Distributor to the CPU interface is disabled
	 *  - signalling of interrupts by the CPU interface to the connected processor is disabled
	 *  - no pending interrupt on the CPU interface has sufficient priority for the interface to signal it to the processor.
	 */
	if (id >= INTC_RT_NR_IRQS) {
        return;
	}

	pEntry = &HandlerTable[id];

	if (!pEntry->Handler) {
		/* No interrupt handler! */
		while (1)
			;
	}

	pEntry->Handler(pEntry->Context);

	/* If the interrupt was from the INTC-RT, clear it */
	if (id >= CR7_GIC_NR_IRQS)
		GIC_EndInterrupt(INTC_RT_GICC_ADDR, id);
}
