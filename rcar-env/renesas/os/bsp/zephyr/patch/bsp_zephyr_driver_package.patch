diff --git a/arch/arm/core/aarch32/CMakeLists.txt b/arch/arm/core/aarch32/CMakeLists.txt
index b0cf09f5de..f22aece9ad 100644
--- a/arch/arm/core/aarch32/CMakeLists.txt
+++ b/arch/arm/core/aarch32/CMakeLists.txt
@@ -20,6 +20,7 @@ zephyr_library_sources_ifdef(CONFIG_IRQ_OFFLOAD irq_offload.c)
 zephyr_library_sources_ifdef(CONFIG_SW_VECTOR_RELAY irq_relay.S)
 zephyr_library_sources_ifdef(CONFIG_THREAD_LOCAL_STORAGE ../common/tls.c)
 zephyr_library_sources_ifdef(CONFIG_USERSPACE userspace.S)
+zephyr_library_sources_ifdef(CONFIG_CACHE_MANAGEMENT cache.c)
 
 add_subdirectory_ifdef(CONFIG_CPU_CORTEX_M cortex_m)
 add_subdirectory_ifdef(CONFIG_CPU_CORTEX_M_HAS_CMSE cortex_m/cmse)
diff --git a/arch/arm/core/aarch32/cache.c b/arch/arm/core/aarch32/cache.c
new file mode 100644
index 0000000000..8bde528e99
--- /dev/null
+++ b/arch/arm/core/aarch32/cache.c
@@ -0,0 +1,300 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/cache.h>
+
+#define BYTE_PER_WORD			4u
+
+/* CTR */
+#define	CTR_IMINLINE_MASK		BIT_MASK(4u)
+#define	CTR_DMINLINE_SHIFT		16u
+#define	CTR_DMINLINE_MASK		BIT_MASK(4u)
+
+/* CLIDR */
+#define CLIDR_LOC_SHIFT			24u
+#define CLIDR_LOC_MASK			BIT_MASK(3u)
+#define CLIDR_CTYPE_SHIFT(level)	((level) * 3u)
+#define CLIDR_CTYPE_MASK		BIT_MASK(3u)
+#define CLIDR_CTYPE_NO_CACHE	0u
+#define CLIDR_CTYPE_ONLY_ICACHE	1u
+#define CLIDR_CTYPE_ONLY_DCACHE	2u
+#define CLIDR_CTYPE_BOTH_CACHE	3u
+
+/* CCSIDR */
+#define CCSIDR_LN_SZ_SHIFT		0u
+#define CCSIDR_LN_SZ_MASK		BIT_MASK(3u)
+#define CCSIDR_LN_SZ_ACTUAL		4u
+#define CCSIDR_WAYS_SHIFT		3u
+#define CCSIDR_WAYS_MASK		BIT_MASK(10u)
+#define CCSIDR_SETS_SHIFT		13u
+#define CCSIDR_SETS_MASK		BIT_MASK(15u)
+
+/* CSSELR */
+#define CSSELR_LEVEL_SHIFT		1u
+
+/**
+ * @fn          arch_dcache_line_size_get
+ * @brief       get line size of data cache in bytes
+ * @return      line size of data cache(byte)
+ */
+size_t arch_dcache_line_size_get(void)
+{
+	size_t dcache_line_size;
+	uint32_t ctr;
+	uint32_t dminline;
+
+	/* Read CTR */
+	__asm volatile ("MRC p15, 0, %0, c0, c0, 1" : "=r" (ctr));
+
+	dminline = (ctr >> CTR_DMINLINE_SHIFT) & CTR_DMINLINE_MASK;
+
+	dcache_line_size = BYTE_PER_WORD << dminline;
+
+	return dcache_line_size;
+}
+
+/**
+ * @fn          arch_dcache_range
+ * @brief       operation for data cache
+ * @param[in]   addr      operation start addr
+ * @param[in]   size       operation size
+ * @param[in]   op         specify operation type
+ * @retval      0          OK
+ * @retval      -ENOTSUP   NG (Unsupported value error)
+ */
+int arch_dcache_range(void * addr, size_t size, int op)
+{
+	size_t line_size;
+	uintptr_t start_addr = (uintptr_t)addr;
+	uintptr_t end_addr = start_addr + size;
+
+	if ((op != K_CACHE_INVD) && (op != K_CACHE_WB) && (op != K_CACHE_WB_INVD))
+	{
+		return -ENOTSUP;
+	}
+
+	line_size = arch_dcache_line_size_get();
+
+	/* Align address to line size */
+	start_addr &= ~(line_size - 1);
+
+	while (start_addr < end_addr)
+	{
+		if (op == K_CACHE_INVD)
+		{
+			__asm volatile ("MCR  p15, 0, %0, c7, c6, 1" :: "r" (start_addr));
+		}
+		else if (op == K_CACHE_WB_INVD)
+		{
+			__asm volatile ("MCR  p15, 0, %0, c7, c14, 1" :: "r" (start_addr));
+		}
+		else if (op == K_CACHE_WB)
+		{
+			__asm volatile ("MCR  p15, 0, %0, c7, c10, 1" :: "r" (start_addr));
+		}
+
+		start_addr += line_size;
+	}
+
+	__asm volatile ("DSB");
+	__asm volatile ("ISB");
+
+	return 0;
+}
+
+/**
+ * @fn          arch_dcache_all
+ * @brief       operation for all data cache
+ * @param[in]   op         specify operation type
+ * @retval      0          OK
+ * @retval      -ENOTSUP   NG (Unsupported value error)
+ */
+int arch_dcache_all(int op)
+{
+	uint32_t clidr;
+	uint32_t csselr;
+	uint32_t ccsidr;
+	uint8_t loc;
+	uint8_t ctype;
+	uint8_t cache_level;
+	uint8_t line_size;
+	uint8_t way_pos;
+	uint32_t max_ways;
+	uint32_t max_sets;
+	uint32_t mcr_val;
+	uint32_t set;
+	uint32_t way;
+
+	if ((op != K_CACHE_INVD) && (op != K_CACHE_WB) && (op != K_CACHE_WB_INVD))
+	{
+		return -ENOTSUP;
+	}
+
+	/* data barrier before start */
+	__asm volatile ("DSB");
+
+	/* Read CLIDR */
+	__asm volatile ("MRC p15, 1, %0, c0, c0, 1" : "=r" (clidr));
+
+	/* if loc is 0, then no need to invalidate/clean */
+	loc = (clidr >> CLIDR_LOC_SHIFT) & CLIDR_LOC_MASK;
+	if (0 == loc)
+	{
+		return 0;
+	}
+
+	for (cache_level = 0u; cache_level < loc; cache_level++)
+	{
+		/* skip if no cache, or just i-cache */
+		ctype = (clidr >> CLIDR_CTYPE_SHIFT(cache_level)) & CLIDR_CTYPE_MASK;
+		if (ctype < CLIDR_CTYPE_ONLY_DCACHE)
+		{
+			continue;
+		}
+
+		/* select cache level */
+		csselr = cache_level << CSSELR_LEVEL_SHIFT;
+		__asm volatile ("MCR p15, 2, %0, c0, c0, 0" :: "r" (csselr));
+		__asm volatile ("ISB");
+
+		/* Read CCSIDR */
+		__asm volatile ("MRC p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
+		line_size = ((ccsidr >> CCSIDR_LN_SZ_SHIFT) & CCSIDR_LN_SZ_MASK) + CCSIDR_LN_SZ_ACTUAL;
+		/* find maximum number on the way size */
+		max_ways = (ccsidr >> CCSIDR_WAYS_SHIFT) & CCSIDR_WAYS_MASK;
+		/* extract max number of the index size */
+		max_sets = (ccsidr >> CCSIDR_SETS_SHIFT) & CCSIDR_SETS_MASK;
+		/* find bit position of way size increment */
+		way_pos = __builtin_clz(max_ways);
+
+		for (set = 0u; set <= max_sets; set++)
+		{
+			for (way = 0u; way <= max_ways; way++)
+			{
+				/* way number, aligned to position */
+				mcr_val = way << way_pos;
+				/* cache level, aligned to position */
+				mcr_val |= csselr;
+				/* set number, aligned to position */
+				mcr_val |= (set << line_size);
+
+				if (op == K_CACHE_INVD)
+				{
+					__asm volatile ("MCR  p15, 0, %0, c7, c6, 2" :: "r" (mcr_val));
+				}
+				else if (op == K_CACHE_WB_INVD)
+				{
+					__asm volatile ("MCR  p15, 0, %0, c7, c14, 2" :: "r" (mcr_val));
+				}
+				else if (op == K_CACHE_WB)
+				{
+					__asm volatile ("MCR  p15, 0, %0, c7, c10, 2" :: "r" (mcr_val));
+				}
+			}
+		}
+	}
+
+	/* Restore csselr to level 0 */
+	cache_level = 0u;
+	csselr = cache_level << CSSELR_LEVEL_SHIFT;
+	__asm volatile ("MCR p15, 2, %0, c0, c0, 0" :: "r" (csselr));
+
+	__asm volatile ("DSB");
+	__asm volatile ("ISB");
+
+	return 0;
+}
+
+/**
+ * @fn          arch_icache_line_size_get
+ * @brief       get line size of instruction cache in bytes
+ * @return      line size of instruction cache(byte)
+ */
+size_t arch_icache_line_size_get(void)
+{
+	size_t icache_line_size;
+	uint32_t ctr;
+	uint32_t iminline;
+
+	/* Read CTR */
+	__asm volatile ("MRC p15, 0, %0, c0, c0, 1" : "=r" (ctr));
+
+	iminline = ctr & CTR_IMINLINE_MASK;
+
+	icache_line_size = BYTE_PER_WORD << iminline;
+
+	return icache_line_size;
+}
+
+/**
+ * @fn          arch_icache_range
+ * @brief       operation for instruction cache
+ * @param[in]   addr      operation start addr
+ * @param[in]   size       operation size
+ * @param[in]   op         specify operation type
+ * @retval      0          OK
+ * @retval      -ENOTSUP   NG (Unsupported value error)
+ */
+int arch_icache_range(void * addr, size_t size, int op)
+{
+	size_t line_size;
+	uintptr_t start_addr = (uintptr_t)addr;
+	uintptr_t end_addr = start_addr + size;
+
+	if ((op == K_CACHE_WB) || (op == K_CACHE_WB_INVD))
+	{
+		return 0;
+	}
+	else if (op != K_CACHE_INVD)
+	{
+		return -ENOTSUP;
+	}
+
+	line_size = arch_dcache_line_size_get();
+
+	/* Align address to line size */
+	start_addr &= ~(line_size - 1);
+
+	while (start_addr < end_addr)
+	{
+		__asm volatile ("MCR  p15, 0, %0, c7, c5, 1" :: "r" (start_addr));
+
+		start_addr += line_size;
+	}
+
+	__asm volatile ("DSB");
+	__asm volatile ("ISB");
+
+	return 0;
+}
+
+/**
+ * @fn          arch_icache_all
+ * @brief       operation for all instruction cache
+ * @param[in]   op         specify operation type
+ * @retval      0          OK
+ * @retval      -ENOTSUP   NG (Unsupported value error)
+ */
+int arch_icache_all(int op)
+{
+	uint32_t mcr_val = 0;
+
+	if ((op == K_CACHE_WB) || (op == K_CACHE_WB_INVD))
+	{
+		return 0;
+	}
+	else if (op != K_CACHE_INVD)
+	{
+		return -ENOTSUP;
+	}
+
+	__asm volatile ("MCR  p15, 0, %0, c7, c5, 0" :: "r" (mcr_val));
+
+	__asm volatile ("DSB");
+	__asm volatile ("ISB");
+
+	return 0;
+}
diff --git a/arch/arm/core/aarch32/cortex_a_r/reset.S b/arch/arm/core/aarch32/cortex_a_r/reset.S
index d6232cb949..7ff26192a1 100644
--- a/arch/arm/core/aarch32/cortex_a_r/reset.S
+++ b/arch/arm/core/aarch32/cortex_a_r/reset.S
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2013-2014 Wind River Systems, Inc.
  * Copyright (c) 2019 Stephanos Ioannidis <root@stephanos.io>
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -68,6 +69,10 @@ SECTION_SUBSEC_FUNC(TEXT, _reset_section, __start)
     msr spsr_hyp, r0
 
     ldr r0, =EL1_Reset_Handler
+#ifdef CONFIG_SOC_SERIES_RCAR_GEN4
+    ldr r1, =_vector_table
+    sub r0, r0, r1
+#endif
     msr elr_hyp, r0
     dsb
     isb
diff --git a/arch/arm/core/aarch32/cortex_a_r/vector_table.S b/arch/arm/core/aarch32/cortex_a_r/vector_table.S
index 971f90240c..02b9ba203b 100644
--- a/arch/arm/core/aarch32/cortex_a_r/vector_table.S
+++ b/arch/arm/core/aarch32/cortex_a_r/vector_table.S
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2018 Marvell
  * Copyright (c) 2018 Lexmark International, Inc.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -17,6 +18,20 @@
 _ASM_FILE_PROLOGUE
 
 SECTION_SUBSEC_FUNC(exc_vector_table,_vector_table_section,_vector_table)
+#ifdef CONFIG_SOC_SERIES_RCAR_GEN4
+	b		z_arm_reset				/*                   offset 0 */
+	b		z_arm_undef_instruction	/* undef instruction offset 4 */
+	b		z_arm_svc				/* svc               offset 8 */
+	b		z_arm_prefetch_abort	/* prefetch abort offset  0xc */
+	b		z_arm_data_abort		/* data abort     offset 0x10 */
+	nop								/*                offset 0x14 */
+#ifdef CONFIG_GEN_SW_ISR_TABLE
+	b		_isr_wrapper		 	/* IRQ            offset 0x18 */
+#else
+	b		z_irq_spurious
+#endif
+	b		z_arm_nmi				/* FIQ            offset 0x1c */
+#else
 	ldr pc, =z_arm_reset             /*                   offset 0 */
 	ldr pc, =z_arm_undef_instruction /* undef instruction offset 4 */
 	ldr pc, =z_arm_svc               /* svc               offset 8 */
@@ -29,3 +44,4 @@ SECTION_SUBSEC_FUNC(exc_vector_table,_vector_table_section,_vector_table)
 	ldr pc, =z_irq_spurious
 #endif
 	ldr pc, =z_arm_nmi               /* FIQ            offset 0x1c */
+#endif
diff --git a/arch/arm/core/aarch32/cortex_a_r/vector_table.h b/arch/arm/core/aarch32/cortex_a_r/vector_table.h
index 7d2122b482..06a0399457 100644
--- a/arch/arm/core/aarch32/cortex_a_r/vector_table.h
+++ b/arch/arm/core/aarch32/cortex_a_r/vector_table.h
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2018 Marvell
  * Copyright (c) 2018 Lexmark International, Inc.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -38,7 +39,9 @@ GTEXT(z_arm_prefetch_abort)
 GTEXT(z_arm_data_abort)
 
 GTEXT(z_arm_pendsv)
+#if !defined(__ARMCOMPILER_VERSION)
 GTEXT(z_arm_reserved)
+#endif
 
 GTEXT(z_arm_prep_c)
 GTEXT(_isr_wrapper)
diff --git a/arch/arm/core/aarch32/irq_manage.c b/arch/arm/core/aarch32/irq_manage.c
index 76a6ce7773..66e1dc68c9 100644
--- a/arch/arm/core/aarch32/irq_manage.c
+++ b/arch/arm/core/aarch32/irq_manage.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013-2014 Wind River Systems, Inc.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -30,7 +31,9 @@
 #include <zephyr/tracing/tracing.h>
 #include <zephyr/pm/pm.h>
 
+#if !defined(__ARMCOMPILER_VERSION)
 extern void z_arm_reserved(void);
+#endif
 
 #if defined(CONFIG_CPU_CORTEX_M)
 #define NUM_IRQS_PER_REG 32
diff --git a/arch/arm/core/aarch32/mpu/arm_mpu.c b/arch/arm/core/aarch32/mpu/arm_mpu.c
index a758887bae..b707c94aa3 100644
--- a/arch/arm/core/aarch32/mpu/arm_mpu.c
+++ b/arch/arm/core/aarch32/mpu/arm_mpu.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2017 Linaro Limited.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -57,20 +58,22 @@ static uint8_t static_regions_num;
 static int region_allocate_and_init(const uint8_t index,
 	const struct arm_mpu_region *region_conf)
 {
+	int ret;
 	/* Attempt to allocate new region index. */
 	if (index > (get_num_regions() - 1U)) {
 
 		/* No available MPU region index. */
 		LOG_ERR("Failed to allocate new MPU region %u\n", index);
-		return -EINVAL;
-	}
-
-	LOG_DBG("Program MPU region at index 0x%x", index);
+		ret = (int)(-EINVAL);
+	} else {
 
-	/* Program region */
-	region_init(index, region_conf);
+		LOG_DBG("Program MPU region at index 0x%x", index);
 
-	return index;
+		/* Program region */
+		region_init(index, region_conf);
+		ret = (int)(index);
+	}
+	return ret;
 }
 
 /* This internal function programs an MPU region
@@ -107,9 +110,9 @@ static int mpu_configure_regions(const struct z_arm_mpu_partition
 	bool do_sanity_check)
 {
 	int i;
-	int reg_index = start_reg_index;
+	int reg_index = (int)start_reg_index;
 
-	for (i = 0; i < regions_num; i++) {
+	for (i = 0; i < (int)regions_num; i++) {
 		if (regions[i].size == 0U) {
 			continue;
 		}
@@ -118,13 +121,14 @@ static int mpu_configure_regions(const struct z_arm_mpu_partition
 		if (do_sanity_check &&
 				(!mpu_partition_is_valid(&regions[i]))) {
 			LOG_ERR("Partition %u: sanity check failed.", i);
-			return -EINVAL;
+			reg_index = -EINVAL;
+			break;
 		}
 
 		reg_index = mpu_configure_region(reg_index, &regions[i]);
 
 		if (reg_index == -EINVAL) {
-			return reg_index;
+			break;
 		}
 
 		/* Increment number of programmed MPU indices. */
@@ -147,7 +151,7 @@ void arm_core_mpu_enable(void)
 	uint32_t val;
 
 	val = __get_SCTLR();
-	val |= SCTLR_MPU_ENABLE;
+	val |= (uint32_t)SCTLR_MPU_ENABLE;
 	/* Make sure that all the registers are set before proceeding */
 	__DSB();
 	__set_SCTLR(val);
@@ -162,7 +166,7 @@ void arm_core_mpu_disable(void)
 	uint32_t val;
 
 	val = __get_SCTLR();
-	val &= ~SCTLR_MPU_ENABLE;
+	val &= ~(uint32_t)SCTLR_MPU_ENABLE;
 	/* Force any outstanding transfers to complete before disabling MPU */
 	__DSB();
 	__set_SCTLR(val);
@@ -317,6 +321,7 @@ void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
 int z_arm_mpu_init(void)
 {
 	uint32_t r_index;
+	int ret = 0;
 
 	if (mpu_config.num_regions > get_num_regions()) {
 		/* Attempt to configure more MPU regions than
@@ -330,106 +335,113 @@ int z_arm_mpu_init(void)
 			mpu_config.num_regions,
 			get_num_regions()
 		);
-		return -1;
-	}
+		ret = -1;
+	} else {
 
-	LOG_DBG("total region count: %d", get_num_regions());
+		LOG_DBG("total region count: %d", get_num_regions());
 
-	arm_core_mpu_disable();
+		arm_core_mpu_disable();
 
 #if defined(CONFIG_NOCACHE_MEMORY)
-	/* Clean and invalidate data cache if it is enabled and
-	 * that was not already done at boot
-	 */
+		/* Clean and invalidate data cache if it is enabled and
+		 * that was not already done at boot
+		 */
 #if !defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
-	if (SCB->CCR & SCB_CCR_DC_Msk) {
-		SCB_CleanInvalidateDCache();
-	}
+		if (SCB->CCR & SCB_CCR_DC_Msk) {
+			SCB_CleanInvalidateDCache();
+		}
 #endif
 #endif /* CONFIG_NOCACHE_MEMORY */
 
-	/* Architecture-specific configuration */
-	mpu_init();
+		/* Architecture-specific configuration */
+		mpu_init();
 
-	/* Program fixed regions configured at SOC definition. */
-	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
-		region_init(r_index, &mpu_config.mpu_regions[r_index]);
-	}
+#if defined(CONFIG_AARCH32_ARMV8_R)
+		/* set MDIR */
+		set_region_mair0(mpu_config.mair0);
+		set_region_mair1(mpu_config.mair1);
+#endif
 
-	/* Update the number of programmed MPU regions. */
-	static_regions_num = mpu_config.num_regions;
+		/* Program fixed regions configured at SOC definition. */
+		for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
+			region_init(r_index, &mpu_config.mpu_regions[r_index]);
+		}
 
+		/* Update the number of programmed MPU regions. */
+		static_regions_num = (uint8_t)mpu_config.num_regions;
 
-	arm_core_mpu_enable();
 
-	/* Program additional fixed flash region for null-pointer
-	 * dereferencing detection (debug feature)
-	 */
+		arm_core_mpu_enable();
+
+		/* Program additional fixed flash region for null-pointer
+		 * dereferencing detection (debug feature)
+		 */
 #if defined(CONFIG_NULL_POINTER_EXCEPTION_DETECTION_MPU)
 #if (defined(CONFIG_ARMV8_M_BASELINE) || defined(CONFIG_ARMV8_M_MAINLINE)) && \
 	(CONFIG_FLASH_BASE_ADDRESS > CONFIG_CORTEX_M_NULL_POINTER_EXCEPTION_PAGE_SIZE)
 #pragma message "Null-Pointer exception detection cannot be configured on un-mapped flash areas"
 #else
-	const struct z_arm_mpu_partition unmap_region =	{
-		.start = 0x0,
-		.size = CONFIG_CORTEX_M_NULL_POINTER_EXCEPTION_PAGE_SIZE,
+		const struct z_arm_mpu_partition unmap_region =	{
+			.start = 0x0,
+			.size = CONFIG_CORTEX_M_NULL_POINTER_EXCEPTION_PAGE_SIZE,
 #if defined(CONFIG_ARMV8_M_BASELINE) || defined(CONFIG_ARMV8_M_MAINLINE)
-		/* Overlapping region (with any permissions)
-		 * will result in fault generation
-		 */
-		.attr = K_MEM_PARTITION_P_RO_U_NA,
+			/* Overlapping region (with any permissions)
+			 * will result in fault generation
+			 */
+			.attr = K_MEM_PARTITION_P_RO_U_NA,
 #else
-		/* Explicit no-access policy */
-		.attr = K_MEM_PARTITION_P_NA_U_NA,
+			/* Explicit no-access policy */
+			.attr = K_MEM_PARTITION_P_NA_U_NA,
 #endif
-	};
+		};
 
-	/* The flash region for null pointer dereferencing detection shall
-	 * comply with the regular MPU partition definition restrictions
-	 * (size and alignment).
-	 */
-	_ARCH_MEM_PARTITION_ALIGN_CHECK(0x0,
-		CONFIG_CORTEX_M_NULL_POINTER_EXCEPTION_PAGE_SIZE);
+		/* The flash region for null pointer dereferencing detection shall
+		 * comply with the regular MPU partition definition restrictions
+		 * (size and alignment).
+		 */
+		_ARCH_MEM_PARTITION_ALIGN_CHECK(0x0,
+			CONFIG_CORTEX_M_NULL_POINTER_EXCEPTION_PAGE_SIZE);
 
 #if defined(CONFIG_ARMV8_M_BASELINE) || defined(CONFIG_ARMV8_M_MAINLINE)
-	/* ARMv8-M requires that the area:
-	 * 0x0 - CORTEX_M_NULL_POINTER_EXCEPTION_PAGE_SIZE
-	 * is not unmapped (belongs to a valid MPU region already).
-	 */
-	if ((arm_cmse_mpu_region_get(0x0) == -EINVAL) ||
-		(arm_cmse_mpu_region_get(
-			CONFIG_CORTEX_M_NULL_POINTER_EXCEPTION_PAGE_SIZE - 1)
-		== -EINVAL)) {
-		__ASSERT(0,
-			"Null pointer detection page unmapped\n");
+		/* ARMv8-M requires that the area:
+		 * 0x0 - CORTEX_M_NULL_POINTER_EXCEPTION_PAGE_SIZE
+		 * is not unmapped (belongs to a valid MPU region already).
+		 */
+		if ((arm_cmse_mpu_region_get(0x0) == -EINVAL) ||
+			(arm_cmse_mpu_region_get(
+				CONFIG_CORTEX_M_NULL_POINTER_EXCEPTION_PAGE_SIZE - 1)
+			== -EINVAL)) {
+			__ASSERT(0,
+				"Null pointer detection page unmapped\n");
 		}
 #endif
 
-	if (mpu_configure_region(static_regions_num, &unmap_region) == -EINVAL) {
-
-		__ASSERT(0,
-			"Programming null-pointer detection region failed\n");
-		return -EINVAL;
-	}
-
-	static_regions_num++;
+		if (mpu_configure_region(static_regions_num, &unmap_region) == -EINVAL) {
 
+			__ASSERT(0,
+				"Programming null-pointer detection region failed\n");
+			ret = -EINVAL;
+		} else {
+			static_regions_num++;
+		}
 #endif
 #endif /* CONFIG_NULL_POINTER_EXCEPTION_DETECTION_MPU */
 
-	/* Sanity check for number of regions in Cortex-M0+, M3, and M4. */
+		if (0 == ret) {
+		/* Sanity check for number of regions in Cortex-M0+, M3, and M4. */
 #if defined(CONFIG_CPU_CORTEX_M0PLUS) || \
 	defined(CONFIG_CPU_CORTEX_M3) || \
 	defined(CONFIG_CPU_CORTEX_M4)
-	__ASSERT(
-		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos == 8,
-		"Invalid number of MPU regions\n");
+			__ASSERT(
+				(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos == 8,
+				"Invalid number of MPU regions\n");
 #elif defined(NUM_MPU_REGIONS)
-	__ASSERT(
-		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
-		NUM_MPU_REGIONS,
-		"Invalid number of MPU regions\n");
+			__ASSERT(
+				(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
+				NUM_MPU_REGIONS,
+				"Invalid number of MPU regions\n");
 #endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
-
-	return 0;
+		}
+	}
+	return ret;
 }
diff --git a/arch/arm/core/aarch32/mpu/arm_mpu_v7_internal.h b/arch/arm/core/aarch32/mpu/arm_mpu_v7_internal.h
index 508d1b6760..053c28ab3e 100644
--- a/arch/arm/core/aarch32/mpu/arm_mpu_v7_internal.h
+++ b/arch/arm/core/aarch32/mpu/arm_mpu_v7_internal.h
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2017 Linaro Limited.
  * Copyright (c) 2018 Nordic Semiconductor ASA.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -39,10 +40,15 @@ static void region_init(const uint32_t index,
 	 * enabled as we reconfigure it.
 	 */
 	set_region_size(0);
-
+#if defined(CONFIG_AARCH32_ARMV8_R)
+	set_region_base_address((region_conf->base & (uint32_t)MPU_RBAR_ADDR_Msk) | (region_conf->attr.rasr & (uint32_t)0x1F));
+	set_region_size((((region_conf->base & (uint32_t)MPU_RBAR_ADDR_Msk) + region_conf->size - (uint32_t)1) & (uint32_t)MPU_RBAR_ADDR_Msk)
+				| ((region_conf->attr.rasr >> 7) & (uint32_t)0xE) | (uint32_t)MPU_RASR_ENABLE_Msk);
+#else
 	set_region_base_address(region_conf->base & MPU_RBAR_ADDR_Msk);
 	set_region_attributes(region_conf->attr.rasr);
 	set_region_size(region_conf->size | MPU_RASR_ENABLE_Msk);
+#endif
 #else
 	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
 				| MPU_RBAR_VALID_Msk | index;
diff --git a/arch/arm/core/aarch32/mpu/cortex_a_r/arm_mpu_internal.h b/arch/arm/core/aarch32/mpu/cortex_a_r/arm_mpu_internal.h
index a0f7d17443..d3a3b2cca4 100644
--- a/arch/arm/core/aarch32/mpu/cortex_a_r/arm_mpu_internal.h
+++ b/arch/arm/core/aarch32/mpu/cortex_a_r/arm_mpu_internal.h
@@ -1,6 +1,7 @@
 /* SPDX-License-Identifier: Apache-2.0
  *
  * Copyright (c) 2019 Lexmark International, Inc.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  */
 
 #include <zephyr/sys/math_extras.h>
@@ -55,14 +56,34 @@ static inline void set_region_attributes(uint32_t attr)
 
 static inline void set_region_base_address(uint32_t addr)
 {
+#if defined(CONFIG_AARCH32_ARMV8_R)
+	__asm__ volatile("mcr p15, 0, %0, c6, c3, 0" :: "r" (addr) :);
+#else
 	__asm__ volatile("mcr p15, 0, %0, c6, c1, 0" :: "r" (addr) :);
+#endif
 }
 
 static inline void set_region_number(uint32_t index)
 {
+#if defined(CONFIG_AARCH32_ARMV8_R)
+	__asm__ volatile("mcr p15, 0, %0, c6, c2, 1" :: "r" (index) :);
+#else
 	__asm__ volatile("mcr p15, 0, %0, c6, c2, 0" :: "r" (index) :);
+#endif
+}
+
+#if defined(CONFIG_AARCH32_ARMV8_R)
+static inline void set_region_mair0(uint32_t data)
+{
+	__asm__ volatile("mcr p15, 0, %0, c10, c2, 0" :: "r" (data) :);
 }
 
+static inline void set_region_mair1(uint32_t data)
+{
+	__asm__ volatile("mcr p15, 0, %0, c10, c2, 1" :: "r" (data) :);
+}
+#endif
+
 static inline uint32_t mpu_region_get_base(uint32_t index)
 {
 	set_region_number(index);
@@ -81,7 +102,11 @@ static inline uint32_t mpu_rasr_size_to_size(uint32_t rasr_size)
 
 static inline void set_region_size(uint32_t size)
 {
+#if defined(CONFIG_AARCH32_ARMV8_R)
+	__asm__ volatile("mcr p15, 0, %0, c6, c3, 1" :: "r" (size) :);
+#else
 	__asm__ volatile("mcr p15, 0, %0, c6, c1, 2" :: "r" (size) :);
+#endif
 }
 
 static inline void ARM_MPU_ClrRegion(uint32_t rnr)
diff --git a/boards/arm/rcar_v4h_white_hawk/Kconfig.board b/boards/arm/rcar_v4h_white_hawk/Kconfig.board
new file mode 100644
index 0000000000..ca84828b42
--- /dev/null
+++ b/boards/arm/rcar_v4h_white_hawk/Kconfig.board
@@ -0,0 +1,6 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+config BOARD_RCAR_V4H_WHITE_HAWK_CR52
+	bool "Cortex-R52 for Renesas V4H White Hawk"
+	depends on SOC_R8A779G
diff --git a/boards/arm/rcar_v4h_white_hawk/Kconfig.defconfig b/boards/arm/rcar_v4h_white_hawk/Kconfig.defconfig
new file mode 100644
index 0000000000..6dbee66d86
--- /dev/null
+++ b/boards/arm/rcar_v4h_white_hawk/Kconfig.defconfig
@@ -0,0 +1,7 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+if BOARD_RCAR_V4H_WHITE_HAWK_CR52
+config BOARD
+	default "rcar_v4h_white_hawk_cr52_defconfig"
+endif # BOARD_RCAR_V4H_WHITE_HAWK_CR52
diff --git a/boards/arm/rcar_v4h_white_hawk/board.cmake b/boards/arm/rcar_v4h_white_hawk/board.cmake
new file mode 100644
index 0000000000..2d934ab3f0
--- /dev/null
+++ b/boards/arm/rcar_v4h_white_hawk/board.cmake
@@ -0,0 +1,3 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+board_runner_args(openocd "--use-elf")
diff --git a/boards/arm/rcar_v4h_white_hawk/rcar_v4h_white_hawk_cr52.dts b/boards/arm/rcar_v4h_white_hawk/rcar_v4h_white_hawk_cr52.dts
new file mode 100644
index 0000000000..828546121b
--- /dev/null
+++ b/boards/arm/rcar_v4h_white_hawk/rcar_v4h_white_hawk_cr52.dts
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ */
+
+/dts-v1/;
+#include <arm/renesas/gen4/r8a779g.dtsi>
+
+/ {
+	model = "Renesas v4h White Hawk board";
+	compatible = "renesas,v4h-white-hawk-cr52";
+
+	chosen {
+		zephyr,sram = &sram0;
+		zephyr,console = &scif0;
+		zephyr,shell-uart = &scif0;
+	};
+};
+
+&scif0 {
+	status = "okay";
+};
+
+&cmt0 {
+	status = "okay";
+	clock-frequency = <32800>;
+};
diff --git a/boards/arm/rcar_v4h_white_hawk/rcar_v4h_white_hawk_cr52.yaml b/boards/arm/rcar_v4h_white_hawk/rcar_v4h_white_hawk_cr52.yaml
new file mode 100644
index 0000000000..12e3cdb405
--- /dev/null
+++ b/boards/arm/rcar_v4h_white_hawk/rcar_v4h_white_hawk_cr52.yaml
@@ -0,0 +1,13 @@
+identifier: rcar_v4h_white_hawk_cr52
+name: Cortex r52 for Renesas V4H White Hawk
+type: mcu
+arch: arm
+toolchain:
+  - zephyr
+  - gnuarmemb
+supported:
+  - clock_control
+  - uart
+testing:
+  ignore_tags:
+    - isotp
diff --git a/boards/arm/rcar_v4h_white_hawk/rcar_v4h_white_hawk_cr52_defconfig b/boards/arm/rcar_v4h_white_hawk/rcar_v4h_white_hawk_cr52_defconfig
new file mode 100644
index 0000000000..b6e39e55e5
--- /dev/null
+++ b/boards/arm/rcar_v4h_white_hawk/rcar_v4h_white_hawk_cr52_defconfig
@@ -0,0 +1,31 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+CONFIG_SOC_R8A779G=y
+CONFIG_SOC_SERIES_RCAR_GEN4=y
+CONFIG_ARM_MPU=y
+CONFIG_BOARD_RCAR_V4H_WHITE_HAWK_CR52=y
+CONFIG_CLOCK_CONTROL=y
+CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC=32800
+CONFIG_SYS_CLOCK_TICKS_PER_SEC=1000
+CONFIG_RCAR_CMT_TIMER=y
+CONFIG_CONSOLE=y
+CONFIG_RAM_CONSOLE=y
+CONFIG_FLASH_SIZE=0
+CONFIG_FLASH_BASE_ADDRESS=0
+CONFIG_SERIAL=y
+CONFIG_UART_CONSOLE=y
+CONFIG_UART_INTERRUPT_DRIVEN=y
+CONFIG_CACHE_MANAGEMENT=y
+CONFIG_DCACHE_LINE_SIZE_DETECT=y
+CONFIG_ICACHE_LINE_SIZE_DETECT=y
+
+# Log level
+CONFIG_I2C_LOG_LEVEL_DBG=y
+CONFIG_CLOCK_CONTROL_LOG_LEVEL_INF=y
+CONFIG_POWER_DOMAIN_LOG_LEVEL_INF=y
+
+# Use Posix API
+CONFIG_POSIX_API=y
+
+# For Shell
+CONFIG_MINIMAL_LIBC=y
diff --git a/cmake/compiler/armclang/target.cmake b/cmake/compiler/armclang/target.cmake
index 54ddefda04..23151023cb 100644
--- a/cmake/compiler/armclang/target.cmake
+++ b/cmake/compiler/armclang/target.cmake
@@ -23,7 +23,11 @@ if(CONFIG_ARM64)
   list(APPEND TOOLCHAIN_C_FLAGS   -mabi=lp64)
   list(APPEND TOOLCHAIN_LD_FLAGS  -mabi=lp64)
 else()
-  list(APPEND TOOLCHAIN_C_FLAGS   -mcpu=${GCC_M_CPU})
+  if (CONFIG_SOC_SERIES_RCAR_GEN4)
+    list(APPEND TOOLCHAIN_C_FLAGS   -mcpu=${GCC_M_CPU}+nofp -nostdlib)
+  else()
+    list(APPEND TOOLCHAIN_C_FLAGS   -mcpu=${GCC_M_CPU})
+  endif()
 
   if(CONFIG_COMPILER_ISA_THUMB2)
     list(APPEND TOOLCHAIN_C_FLAGS   -mthumb)
diff --git a/cmake/linker/armlink/target.cmake b/cmake/linker/armlink/target.cmake
index 8f777c7800..957fe19b52 100644
--- a/cmake/linker/armlink/target.cmake
+++ b/cmake/linker/armlink/target.cmake
@@ -65,7 +65,7 @@ function(toolchain_ld_link_elf)
   )
 
   foreach(lib ${ZEPHYR_LIBS_PROPERTY})
-    if(NOT ${lib} STREQUAL arch__arm__core__aarch32__cortex_m)
+    if(NOT ${lib} STREQUAL arch__arm__core__aarch32__cortex_a_r)
       list(APPEND ZEPHYR_LIBS_OBJECTS $<TARGET_OBJECTS:${lib}>)
       list(APPEND ZEPHYR_LIBS_OBJECTS $<TARGET_PROPERTY:${lib},LINK_LIBRARIES>)
     endif()
@@ -76,7 +76,7 @@ function(toolchain_ld_link_elf)
     ${TOOLCHAIN_LD_LINK_ELF_LIBRARIES_PRE_SCRIPT}
     --scatter=${TOOLCHAIN_LD_LINK_ELF_LINKER_SCRIPT}
     ${TOOLCHAIN_LD_LINK_ELF_LIBRARIES_POST_SCRIPT}
-    $<TARGET_OBJECTS:arch__arm__core__aarch32__cortex_m>
+    $<TARGET_OBJECTS:arch__arm__core__aarch32__cortex_a_r>
     --map --list=${TOOLCHAIN_LD_LINK_ELF_OUTPUT_MAP}
     ${ZEPHYR_LIBS_OBJECTS}
     kernel
diff --git a/cmake/linker_script/arm/linker.cmake b/cmake/linker_script/arm/linker.cmake
index 231c9df8a7..646808236a 100644
--- a/cmake/linker_script/arm/linker.cmake
+++ b/cmake/linker_script/arm/linker.cmake
@@ -95,7 +95,6 @@ zephyr_linker_section(NAME .ARM.exidx GROUP ROM_REGION)
   zephyr_linker_section_configure(SECTION .ARM.exidx INPUT ".gnu.linkonce.armexidx.*")
 #endif()
 
-
 include(${COMMON_ZEPHYR_LINKER_DIR}/common-rom.cmake)
 include(${COMMON_ZEPHYR_LINKER_DIR}/thread-local-storage.cmake)
 
@@ -106,6 +105,12 @@ if(CONFIG_USERSPACE AND CONFIG_XIP)
 endif()
 zephyr_linker_section_configure(SECTION .rodata ALIGN 4)
 
+if(CONFIG_SOC_SERIES_RCAR_GEN4)
+  zephyr_linker_section(NAME .ram_start GROUP RODATA_REGION SUBALIGN 64)
+  zephyr_linker_symbol(SYMBOL __mpu_ram_start EXPR "(@__ram_start_start@)")
+  zephyr_linker_symbol(SYMBOL __text_rodata_region_size EXPR "(@__ram_start_start@ - @__rom_start_start@)")
+endif()
+
 # ToDo - . = ALIGN(_region_min_align);
 # Symbol to add _image_ram_start = .;
 
@@ -122,7 +127,11 @@ include(${COMMON_ZEPHYR_LINKER_DIR}/common-ram.cmake)
 #include(kobject.ld)
 
 if(NOT CONFIG_USERSPACE)
-  zephyr_linker_section(NAME .bss VMA RAM LMA FLASH TYPE BSS)
+  if("armclang" STREQUAL ${ZEPHYR_TOOLCHAIN_VARIANT})
+    zephyr_linker_section(NAME .bss VMA RAM TYPE BSS)
+  else()
+    zephyr_linker_section(NAME .bss VMA RAM LMA FLASH TYPE BSS)
+  endif()
   zephyr_linker_section_configure(SECTION .bss INPUT COMMON)
   zephyr_linker_section_configure(SECTION .bss INPUT ".kernel_bss.*")
   # As memory is cleared in words only, it is simpler to ensure the BSS
@@ -141,6 +150,20 @@ zephyr_linker_symbol(SYMBOL __kernel_ram_size EXPR "(@__kernel_ram_end@ - @__bss
 zephyr_linker_symbol(SYMBOL _image_ram_start  EXPR "(${RAM_ADDR})" SUBALIGN 32) # ToDo calculate 32 correctly
 zephyr_linker_symbol(SYMBOL ARM_LIB_STACKHEAP EXPR "(${RAM_ADDR} + ${RAM_SIZE})" SIZE -0x1000)
 
+if(CONFIG_SOC_SERIES_RCAR_GEN4)
+  if(CONFIG_ETH_RCAR)
+    zephyr_linker_symbol(SYMBOL __data_bss_region_size1 EXPR "(@__eth_non_cache_start@ - @__ram_start_start@)")
+    zephyr_linker_section(NAME .eth_non_cache GROUP RAM_REGION SUBALIGN 128)
+    zephyr_linker_symbol(SYMBOL __eth_nc_start EXPR "(@__eth_non_cache_start@)")
+    zephyr_linker_section(NAME .eth_non_cache_en GROUP RAM_REGION SUBALIGN 128)
+    zephyr_linker_symbol(SYMBOL __eth_nc_end EXPR "(@__eth_non_cache_en_start@)")
+    zephyr_linker_symbol(SYMBOL __eth_nc_size EXPR "(@__eth_non_cache_en_start@ - @__eth_non_cache_start@)")
+    zephyr_linker_symbol(SYMBOL __data_bss_region_size2 EXPR "(@__kernel_ram_end@ - @__eth_non_cache_en_start@)")
+  else()
+    zephyr_linker_symbol(SYMBOL __data_bss_region_size EXPR "(@__kernel_ram_end@ - @__ram_start_start@)")
+  endif()
+endif()
+
 set(VECTOR_ALIGN 4)
 if(CONFIG_CPU_CORTEX_M_HAS_VTOR)
   math(EXPR VECTOR_ALIGN "4 * (16 + ${CONFIG_NUM_IRQS})")
diff --git a/cmake/linker_script/common/common-rom.cmake b/cmake/linker_script/common/common-rom.cmake
index 4a60daab9a..afdb5edba0 100644
--- a/cmake/linker_script/common/common-rom.cmake
+++ b/cmake/linker_script/common/common-rom.cmake
@@ -170,6 +170,12 @@ zephyr_iterable_section(NAME shell KVMA RAM_REGION GROUP RODATA_REGION SUBALIGN
 zephyr_linker_section(NAME shell_root_cmds KVMA RAM_REGION GROUP RODATA_REGION NOINPUT ${XIP_ALIGN_WITH_INPUT})
 zephyr_linker_section_configure(SECTION shell_root_cmds INPUT ".shell_root_cmd_*" KEEP SORT NAME)
 
+zephyr_linker_section(NAME shell_subcmds KVMA RAM_REGION GROUP RODATA_REGION NOINPUT ${XIP_ALIGN_WITH_INPUT})
+zephyr_linker_section_configure(SECTION shell_subcmds INPUT ".shell_subcmd_*" KEEP SORT NAME)
+
+zephyr_linker_section(NAME shell_dynamic_subcmds KVMA RAM_REGION GROUP RODATA_REGION NOINPUT ${XIP_ALIGN_WITH_INPUT})
+zephyr_linker_section_configure(SECTION shell_dynamic_subcmds INPUT ".shell_dynamic_subcmd_*" KEEP SORT NAME)
+
 zephyr_linker_section(NAME font_entry KVMA RAM_REGION GROUP RODATA_REGION NOINPUT ${XIP_ALIGN_WITH_INPUT})
 zephyr_linker_section_configure(SECTION font_entry INPUT "._cfb_font.*" KEEP SORT NAME)
 
diff --git a/cmake/toolchain/armclang/Kconfig b/cmake/toolchain/armclang/Kconfig
index c2df1e1024..f296b66676 100644
--- a/cmake/toolchain/armclang/Kconfig
+++ b/cmake/toolchain/armclang/Kconfig
@@ -1,4 +1,5 @@
 # Copyright (c) 2021 Nordic Semiconductor ASA
+# Copyright (c) 2022 Renesas Electronics Corporation
 # SPDX-License-Identifier: Apache-2.0
 
 config LD_LINKER_SCRIPT_SUPPORTED
@@ -19,5 +20,8 @@ config ARMCLANG_STD_LIBC
 	  Use the full Arm Compiler runtime libraries.
 	  A reduced Zephyr minimal libc will be used for library functionality
 	  not provided by ARM Compiler standard libraries.
-
+config MINIMAL_LIBC
+	bool "Minimal C library"
+	help
+	  Build with minimal C library.
 endchoice
diff --git a/drivers/clock_control/CMakeLists.txt b/drivers/clock_control/CMakeLists.txt
index 56f0eaf695..a3045853fb 100644
--- a/drivers/clock_control/CMakeLists.txt
+++ b/drivers/clock_control/CMakeLists.txt
@@ -17,7 +17,11 @@ zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_MCUX_SYSCON         clock_cont
 zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_NPCX                clock_control_npcx.c)
 zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_NRF                 clock_control_nrf.c)
 zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_NRF_DRIVER_CALIBRATION nrf_clock_calibration.c)
+if(CONFIG_SOC_SERIES_RCAR_GEN4)
+zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_RCAR_CPG_MSSR       clock_control_rcar_cpg_mssr_v4h.c)
+else()
 zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_RCAR_CPG_MSSR       clock_control_rcar_cpg_mssr.c)
+endif()
 zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_RV32M1_PCC          clock_control_rv32m1_pcc.c)
 
 if(CONFIG_CLOCK_CONTROL_STM32_CUBE)
diff --git a/drivers/clock_control/Kconfig.rcar b/drivers/clock_control/Kconfig.rcar
index 2127962710..149344c158 100644
--- a/drivers/clock_control/Kconfig.rcar
+++ b/drivers/clock_control/Kconfig.rcar
@@ -1,10 +1,11 @@
 # Renesas RCar Gen3
 
 # Copyright (c) 2021 IoT.bzh
+# Copyright (c) 2022 Renesas Electronics Corporation
 # SPDX-License-Identifier: Apache-2.0
 
 config CLOCK_CONTROL_RCAR_CPG_MSSR
 	bool "RCar CPG MSSR driver"
-	depends on SOC_SERIES_RCAR_GEN3
+	depends on SOC_SERIES_RCAR_GEN3 || SOC_SERIES_RCAR_GEN4
 	help
 	  Enable support for Renesas RCar CPG MSSR driver.
diff --git a/drivers/clock_control/clock_control_rcar_cpg_mssr_v4h.c b/drivers/clock_control/clock_control_rcar_cpg_mssr_v4h.c
new file mode 100644
index 0000000000..b65cb22220
--- /dev/null
+++ b/drivers/clock_control/clock_control_rcar_cpg_mssr_v4h.c
@@ -0,0 +1,1546 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+#define DT_DRV_COMPAT renesas_rcar_cpg_mssr
+#include <errno.h>
+#include <soc.h>
+#include <zephyr/drivers/clock_control.h>
+#include <zephyr/drivers/clock_control/rcar_clock_control.h>
+#include <zephyr/dt-bindings/clock/renesas_rcar_cpg.h>
+#include <logging/log.h>
+LOG_MODULE_REGISTER(renesas_rcar_cpg_mssr, CONFIG_CLOCK_CONTROL_LOG_LEVEL);/* PRQA S 4548,4549 */
+
+/* S0D12 Clock rate */
+#define S0D12_CLK_RATE            66660000u
+
+/* KICK bit of FRQCRB/FRQCRD register */
+#define R_CPG_KICK        (31u)
+
+/* CPG Register offset */
+#define R_CPG_WPCR        (0x0004u) /* Write protect control register */
+#define R_CPG_WPR         (0x0000u) /* write protect register */
+
+/* No corresponding register */
+#define R_CPG_REG_NONE (0x0000u)
+
+/* CPG Module Standby, software Reset (MSSR) Registers offsets*/
+#define R_CPG_MSTPCR0       (0x2D00u)  /* Module stop control register 0 */
+#define R_CPG_MSTPCR1       (0x2D04u)  /* Module stop control register 1 */
+#define R_CPG_MSTPCR2       (0x2D08u)  /* Module stop control register 2 */
+#define R_CPG_MSTPCR3       (0x2D0Cu)  /* Module stop control register 3 */
+#define R_CPG_MSTPCR4       (0x2D10u)  /* Module stop control register 4 */
+#define R_CPG_MSTPCR5       (0x2D14u)  /* Module stop control register 5 */
+#define R_CPG_MSTPCR6       (0x2D18u)  /* Module stop control register 6 */
+#define R_CPG_MSTPCR7       (0x2D1Cu)  /* Module stop control register 7 */
+#define R_CPG_MSTPCR8       (0x2D20u)  /* Module stop control register 8 */
+#define R_CPG_MSTPCR9       (0x2D24u)  /* Module stop control register 9 */
+#define R_CPG_MSTPCR10      (0x2D28u)  /* Module stop control register 10 */
+#define R_CPG_MSTPCR11      (0x2D2Cu)  /* Module stop control register 11 */
+#define R_CPG_MSTPCR12      (0x2D30u)  /* Module stop control register 12 */
+#define R_CPG_MSTPCR13      (0x2D34u)  /* Module stop control register 13 */
+#define R_CPG_MSTPCR14      (0x2D38u)  /* Module stop control register 14 */
+#define R_CPG_MSTPCR15      (0x2D3Cu)  /* Module stop control register 15 */
+#define R_CPG_MSTPCR16      (0x2D40u)  /* Module stop control register 16 */
+#define R_CPG_MSTPCR17      (0x2D44u)  /* Module stop control register 17 */
+#define R_CPG_MSTPCR18      (0x2D48u)  /* Module stop control register 18 */
+#define R_CPG_MSTPCR19      (0x2D4Cu)  /* Module stop control register 19 */
+#define R_CPG_MSTPCR20      (0x2D50u)  /* Module stop control register 20 */
+#define R_CPG_MSTPCR21      (0x2D54u)  /* Module stop control register 21 */
+#define R_CPG_MSTPCR22      (0x2D58u)  /* Module stop control register 22 */
+#define R_CPG_MSTPCR23      (0x2D5Cu)  /* Module stop control register 23 */
+#define R_CPG_MSTPCR24      (0x2D60u)  /* Module stop control register 24 */
+#define R_CPG_MSTPCR25      (0x2D64u)  /* Module stop control register 25 */
+#define R_CPG_MSTPCR26      (0x2D68u)  /* Module stop control register 26 */
+#define R_CPG_MSTPCR27      (0x2D6Cu)  /* Module stop control register 27 */
+#define R_CPG_MSTPCR28      (0x2D70u)  /* Module stop control register 28 */
+#define R_CPG_MSTPCR29      (0x2D74u)  /* Module stop control register 29 */
+
+#define R_CPG_SRCR0          (0x2C00u)  /* Software reset register 0 */
+#define R_CPG_SRCR1          (0x2C04u)  /* Software reset register 1 */
+#define R_CPG_SRCR2          (0x2C08u)  /* Software reset register 2 */
+#define R_CPG_SRCR3          (0x2C0Cu)  /* Software reset register 3 */
+#define R_CPG_SRCR4          (0x2C10u)  /* Software reset register 4 */
+#define R_CPG_SRCR5          (0x2C14u)  /* Software reset register 5 */
+#define R_CPG_SRCR6          (0x2C18u)  /* Software reset register 6 */
+#define R_CPG_SRCR7          (0x2C1Cu)  /* Software reset register 7 */
+#define R_CPG_SRCR8          (0x2C20u)  /* Software reset register 8 */
+#define R_CPG_SRCR9          (0x2C24u)  /* Software reset register 9 */
+#define R_CPG_SRCR10         (0x2C28u)  /* Software reset register 10 */
+#define R_CPG_SRCR11         (0x2C2Cu)  /* Software reset register 11 */
+#define R_CPG_SRCR12         (0x2C30u)  /* Software reset register 12 */
+#define R_CPG_SRCR13         (0x2C34u)  /* Software reset register 13 */
+#define R_CPG_SRCR14         (0x2C38u)  /* Software reset register 14 */
+#define R_CPG_SRCR15         (0x2C3Cu)  /* Software reset register 15 */
+#define R_CPG_SRCR16         (0x2C40u)  /* Software reset register 16 */
+#define R_CPG_SRCR17         (0x2C44u)  /* Software reset register 17 */
+#define R_CPG_SRCR18         (0x2C48u)  /* Software reset register 18 */
+#define R_CPG_SRCR19         (0x2C4Cu)  /* Software reset register 19 */
+#define R_CPG_SRCR20         (0x2C50u)  /* Software reset register 20 */
+#define R_CPG_SRCR21         (0x2C54u)  /* Software reset register 21 */
+#define R_CPG_SRCR22         (0x2C58u)  /* Software reset register 22 */
+#define R_CPG_SRCR23         (0x2C5Cu)  /* Software reset register 23 */
+#define R_CPG_SRCR24         (0x2C60u)  /* Software reset register 24 */
+#define R_CPG_SRCR25         (0x2C64u)  /* Software reset register 25 */
+#define R_CPG_SRCR26         (0x2C68u)  /* Software reset register 26 */
+#define R_CPG_SRCR27         (0x2C6Cu)  /* Software reset register 27 */
+#define R_CPG_SRCR28         (0x2C70u)  /* Software reset register 28 */
+#define R_CPG_SRCR29         (0x2C74u)  /* Software reset register 29 */
+
+#define R_CPG_SRSTCLR0       (0x2C80u)  /* Software reset clear register 0 */
+#define R_CPG_SRSTCLR1       (0x2C84u)  /* Software reset clear register 1 */
+#define R_CPG_SRSTCLR2       (0x2C88u)  /* Software reset clear register 2 */
+#define R_CPG_SRSTCLR3       (0x2C8Cu)  /* Software reset clear register 3 */
+#define R_CPG_SRSTCLR4       (0x2C90u)  /* Software reset clear register 4 */
+#define R_CPG_SRSTCLR5       (0x2C94u)  /* Software reset clear register 5 */
+#define R_CPG_SRSTCLR6       (0x2C98u)  /* Software reset clear register 6 */
+#define R_CPG_SRSTCLR7       (0x2C9Cu)  /* Software reset clear register 7 */
+#define R_CPG_SRSTCLR8       (0x2CA0u)  /* Software reset clear register 8 */
+#define R_CPG_SRSTCLR9       (0x2CA4u)  /* Software reset clear register 9 */
+#define R_CPG_SRSTCLR10      (0x2CA8u)  /* Software reset clear register 10 */
+#define R_CPG_SRSTCLR11      (0x2CACu)  /* Software reset clear register 11 */
+#define R_CPG_SRSTCLR12      (0x2CB0u)  /* Software reset clear register 12 */
+#define R_CPG_SRSTCLR13      (0x2CB4u)  /* Software reset clear register 13 */
+#define R_CPG_SRSTCLR14      (0x2CB8u)  /* Software reset clear register 14 */
+#define R_CPG_SRSTCLR15      (0x2CBCu)  /* Software reset clear register 15 */
+#define R_CPG_SRSTCLR16      (0x2CC0u)  /* Software reset clear register 16 */
+#define R_CPG_SRSTCLR17      (0x2CC4u)  /* Software reset clear register 17 */
+#define R_CPG_SRSTCLR18      (0x2CC8u)  /* Software reset clear register 18 */
+#define R_CPG_SRSTCLR19      (0x2CCCu)  /* Software reset clear register 19 */
+#define R_CPG_SRSTCLR20      (0x2CD0u)  /* Software reset clear register 20 */
+#define R_CPG_SRSTCLR21      (0x2CD4u)  /* Software reset clear register 21 */
+#define R_CPG_SRSTCLR22      (0x2CD8u)  /* Software reset clear register 22 */
+#define R_CPG_SRSTCLR23      (0x2CDCu)  /* Software reset clear register 23 */
+#define R_CPG_SRSTCLR24      (0x2CE0u)  /* Software reset clear register 24 */
+#define R_CPG_SRSTCLR25      (0x2CE4u)  /* Software reset clear register 25 */
+#define R_CPG_SRSTCLR26      (0x2CE8u)  /* Software reset clear register 26 */
+#define R_CPG_SRSTCLR27      (0x2CECu)  /* Software reset clear register 27 */
+#define R_CPG_SRSTCLR28      (0x2CF0u)  /* Software reset clear register 28 */
+#define R_CPG_SRSTCLR29      (0x2CF4u)  /* Software reset clear register 29 */
+
+#define R_CPG_MSTPSR0       (0x2E00u)  /* Module Stop Status Register 0 */
+#define R_CPG_MSTPSR1       (0x2E04u)  /* Module Stop Status Register 1 */
+#define R_CPG_MSTPSR2       (0x2E08u)  /* Module Stop Status Register 2 */
+#define R_CPG_MSTPSR3       (0x2E0Cu)  /* Module Stop Status Register 3 */
+#define R_CPG_MSTPSR4       (0x2E10u)  /* Module Stop Status Register 4 */
+#define R_CPG_MSTPSR5       (0x2E14u)  /* Module Stop Status Register 5 */
+#define R_CPG_MSTPSR6       (0x2E18u)  /* Module Stop Status Register 6 */
+#define R_CPG_MSTPSR7       (0x2E1Cu)  /* Module Stop Status Register 7 */
+#define R_CPG_MSTPSR8       (0x2E20u)  /* Module Stop Status Register 8 */
+#define R_CPG_MSTPSR9       (0x2E24u)  /* Module Stop Status Register 9 */
+#define R_CPG_MSTPSR10      (0x2E28u)  /* Module Stop Status Register 10 */
+#define R_CPG_MSTPSR11      (0x2E2Cu)  /* Module Stop Status Register 11 */
+#define R_CPG_MSTPSR12      (0x2E30u)  /* Module Stop Status Register 12 */
+#define R_CPG_MSTPSR13      (0x2E34u)  /* Module Stop Status Register 13 */
+#define R_CPG_MSTPSR14      (0x2E38u)  /* Module Stop Status Register 14 */
+#define R_CPG_MSTPSR15      (0x2E3Cu)  /* Module Stop Status Register 15 */
+#define R_CPG_MSTPSR16      (0x2E40u)  /* Module Stop Status Register 16 */
+#define R_CPG_MSTPSR17      (0x2E44u)  /* Module Stop Status Register 17 */
+#define R_CPG_MSTPSR18      (0x2E48u)  /* Module Stop Status Register 18 */
+#define R_CPG_MSTPSR19      (0x2E4Cu)  /* Module Stop Status Register 19 */
+#define R_CPG_MSTPSR20      (0x2E50u)  /* Module Stop Status Register 20 */
+#define R_CPG_MSTPSR21      (0x2E54u)  /* Module Stop Status Register 21 */
+#define R_CPG_MSTPSR22      (0x2E58u)  /* Module Stop Status Register 22 */
+#define R_CPG_MSTPSR23      (0x2E5Cu)  /* Module Stop Status Register 23 */
+#define R_CPG_MSTPSR24      (0x2E60u)  /* Module Stop Status Register 24 */
+#define R_CPG_MSTPSR25      (0x2E64u)  /* Module Stop Status Register 25 */
+#define R_CPG_MSTPSR26      (0x2E68u)  /* Module Stop Status Register 26 */
+#define R_CPG_MSTPSR27      (0x2E6Cu)  /* Module Stop Status Register 27 */
+#define R_CPG_MSTPSR28      (0x2E70u)  /* Module Stop Status Register 28 */
+#define R_CPG_MSTPSR29      (0x2E74u)  /* Module Stop Status Register 29 */
+
+/**
+ * @enum    r_cpg_RegIdx_t
+ * @brief   List of register index used in MSTPCRn/MSTPSRn/SRCRn/SRSTCLRn
+ */
+typedef enum {
+	R_CPG_REGIDX_0,
+	R_CPG_REGIDX_1,
+	R_CPG_REGIDX_2,
+	R_CPG_REGIDX_3,
+	R_CPG_REGIDX_4,
+	R_CPG_REGIDX_5,
+	R_CPG_REGIDX_6,
+	R_CPG_REGIDX_7,
+	R_CPG_REGIDX_8,
+	R_CPG_REGIDX_9,
+	R_CPG_REGIDX_10,
+	R_CPG_REGIDX_11,
+	R_CPG_REGIDX_12,
+	R_CPG_REGIDX_13,
+	R_CPG_REGIDX_14,
+	R_CPG_REGIDX_15,
+	R_CPG_REGIDX_16,
+	R_CPG_REGIDX_17,
+	R_CPG_REGIDX_18,
+	R_CPG_REGIDX_19,
+	R_CPG_REGIDX_20,
+	R_CPG_REGIDX_21,
+	R_CPG_REGIDX_22,
+	R_CPG_REGIDX_23,
+	R_CPG_REGIDX_24,
+	R_CPG_REGIDX_25,
+	R_CPG_REGIDX_26,
+	R_CPG_REGIDX_27,
+	R_CPG_REGIDX_28,
+	R_CPG_REGIDX_29
+} r_cpg_RegIdx_t;
+
+/**
+ * @enum    r_cpg_BitPos_t
+ * @brief   List of bit number
+ */
+typedef enum {
+	R_CPG_BIT0,
+	R_CPG_BIT1,
+	R_CPG_BIT2,
+	R_CPG_BIT3,
+	R_CPG_BIT4,
+	R_CPG_BIT5,
+	R_CPG_BIT6,
+	R_CPG_BIT7,
+	R_CPG_BIT8,
+	R_CPG_BIT9,
+	R_CPG_BIT10,
+	R_CPG_BIT11,
+	R_CPG_BIT12,
+	R_CPG_BIT13,
+	R_CPG_BIT14,
+	R_CPG_BIT15,
+	R_CPG_BIT16,
+	R_CPG_BIT17,
+	R_CPG_BIT18,
+	R_CPG_BIT19,
+	R_CPG_BIT20,
+	R_CPG_BIT21,
+	R_CPG_BIT22,
+	R_CPG_BIT23,
+	R_CPG_BIT24,
+	R_CPG_BIT25,
+	R_CPG_BIT26,
+	R_CPG_BIT27,
+	R_CPG_BIT28,
+	R_CPG_BIT29,
+	R_CPG_BIT30,
+	R_CPG_BIT31
+} r_cpg_BitPos_t;
+
+struct rcar_cpg_mssr_data {
+	struct k_mutex mutex;
+	uint32_t base_address;
+};
+
+/**
+ * Function R_CPG_SetModuleStopStat
+ * @brief Set a state of the module stop for specified module
+ *
+ * @param[in]   RegIdx - MSTPCR register index, range R_CPG_REGIDX_0 - R_CPG_REGIDX_29.
+ *                       See @ref r_cpg_RegIdx_t
+ * @param[in]   BitPos - MSTPCR register bit number, range R_CPG_BIT0 - R_CPG_BIT31.
+ *                       See @ref r_cpg_BitPos_t
+ * @param[in]   enable - true: Enable Module Stop, false: Disable Module Stop
+ * @param[in]   data   - Address of the device instance private data
+ * @retval          0     Success
+ * @retval    -EINVAL     invalid parameter
+ *
+ * @note In this API, it is possible to specify the Bit of the Module described
+ * in Table 8A.15 to Table 8A.26 of HWM.
+ * In addition, even if you specify a Bit that does not have Module described
+ * in the table, no error will occur.
+ */
+static int R_CPG_SetModuleStopStat(r_cpg_RegIdx_t RegIdx,
+								r_cpg_BitPos_t BitPos,
+								bool enable, /* PRQA S 1056 */
+								struct rcar_cpg_mssr_data * data);
+
+/**
+ * Function R_CPG_GetModuleStopStat
+ * @brief Get a state of the module stop for specified module
+ *
+ * @param[in]   RegIdx - MSTPCR register index, range R_CPG_REGIDX_0 - R_CPG_REGIDX_29.
+ *                       See @ref r_cpg_RegIdx_t
+ * @param[in]   BitPos - MSTPCR register bit number, range R_CPG_BIT0 - R_CPG_BIT31.
+ *                       See @ref r_cpg_BitPos_t
+ * @param[out]  enable - true: Module Stop is enabled, false: Module Stop is disabled
+ * @param[in]   data   - Address of the device instance private data
+ * @retval          0     Success
+ * @retval    -EINVAL     invalid parameter
+ */
+static int R_CPG_GetModuleStopStat(r_cpg_RegIdx_t RegIdx,
+								r_cpg_BitPos_t BitPos,
+								bool * enable, /* PRQA S 1056 */
+								struct rcar_cpg_mssr_data * data);
+
+/**
+ * Function R_CPG_SetResetStat
+ * @brief Set a state of the CPG reset for specified module
+ *
+ * @param[in]   RegIdx - SRCR/SRSTCLR register index, range R_CPG_REGIDX_0 - R_CPG_REGIDX_29.
+ *                       See @ref r_cpg_RegIdx_t
+ * @param[in]   BitPos - SRCR/SRSTCLR register bit number, range R_CPG_BIT0 - R_CPG_BIT31.
+ *                       See @ref r_cpg_BitPos_t
+ * @param[in]   ResetStat - 1: Set SRCR target bit to 1.
+ *     0: Set the SRSTCLR target bit to 1 and wait for the SRCR bit to become 0.
+ *   It is necessary to wait for RCLK 1 cycle on the user side.
+ * @param[in]   data   - Address of the device instance private data
+ * @retval          0     Success
+ * @retval    -EINVAL     invalid parameter
+ *
+ * @note In this API, it is possible to specify the Bit of the Module described
+ * in Table 8A.27 to Table 8A.38 of HWM.
+ * In addition, even if you specify a Bit that does not have Module described
+ * in the table, no error will occur.
+ */
+static int R_CPG_SetResetStat(r_cpg_RegIdx_t RegIdx,
+							r_cpg_BitPos_t BitPos,
+							uint32_t ResetStat,
+							struct rcar_cpg_mssr_data * data);
+
+/**
+ * Function R_CPG_GetResetStat
+ * @brief Get a state of the CPG reset for specified module
+ *
+ * @param[in]   RegIdx    - SRCR register index, range R_CPG_REGIDX_0 - R_CPG_REGIDX_29.
+ *                          See @ref r_cpg_RegIdx_t
+ * @param[in]   BitPos    - SRCR register bit number, range R_CPG_BIT0 - R_CPG_BIT31.
+ *                          See @ref r_cpg_BitPos_t
+ * @param[out]  ResetStat - Reset status, 0: SRCR target bit is 0
+ *                                        1: SRCR target bit is 1
+ * @param[in]   data      - Address of the device instance private data
+ * @retval          0     Success
+ * @retval    -EINVAL     invalid parameter
+ */
+static int R_CPG_GetResetStat(r_cpg_RegIdx_t RegIdx,
+							r_cpg_BitPos_t BitPos,
+							uint32_t * ResetStat,
+							struct rcar_cpg_mssr_data * data);
+
+/**
+ * Function R_CPG_SetClockStopStat
+ * @brief Set a state of the clock stop for specified module
+ *
+ * @param[in]   ClockName - Clock name of CPG, range R_CPG_ZS_CLOCK - R_CPG_ZR2_CLOCK.
+ *                          See @ref r_cpg_ClockName_t
+ * @param[in]   enable    - true: Enable Clock Stop, false: Disable Clock Stop
+ * @param[in]   data      - Address of the device instance private data
+ * @retval          0     Success
+ * @retval    -EINVAL     invalid parameter
+ */
+static int R_CPG_SetClockStopStat(r_cpg_ClockName_t ClockName,
+								bool enable, /* PRQA S 1056 */
+								struct rcar_cpg_mssr_data * data);
+
+/**
+ * Function R_CPG_GetClockStopStat
+ * @brief Get a state of the clock stop for specified module
+ *
+ * @param[in]   ClockName - Clock name of CPG, range R_CPG_ZS_CLOCK - R_CPG_ZR2_CLOCK.
+ *                          See @ref r_cpg_ClockName_t
+ * @param[out]  enable    - true: Clock is stopped, false: Clock is running
+ * @param[in]   data      - Address of the device instance private data
+ * @retval          0     Success
+ * @retval    -EINVAL     invalid parameter
+ */
+static int R_CPG_GetClockStopStat(r_cpg_ClockName_t ClockName,
+								bool * enable, /* PRQA S 1056 */
+								struct rcar_cpg_mssr_data * data);
+
+/**
+ * Function R_CPG_SetClock
+ * @brief Set clock Division Ratio
+ *
+ * @param[in]   ClockName - Clock name of CPG, range R_CPG_ZS_CLOCK - R_CPG_ZR2_CLOCK.
+ *                          See @ref r_cpg_ClockName_t
+ * @param[in]   value     - Division ratio value
+ * @param[in]   data      - Address of the device instance private data
+ * @retval          0     Success
+ * @retval    -EINVAL     invalid parameter
+ */
+static int R_CPG_SetClock(r_cpg_ClockName_t ClockName,
+						uint32_t value,
+						struct rcar_cpg_mssr_data * data);
+
+/**
+ * Function R_CPG_GetClock
+ * @brief Get clock Division Ratio
+ *
+ * @param[in]   ClockName - Clock name of CPG, range R_CPG_ZS_CLOCK - R_CPG_ZR2_CLOCK.
+ *                          See @ref r_cpg_ClockName_t
+ * @param[in]   value     - Division ratio value
+ * @param[in]   data      - Address of the device instance private data
+ * @retval          0     Success
+ * @retval    -EINVAL     invalid parameter
+ */
+static int R_CPG_GetClock(r_cpg_ClockName_t ClockName,
+						uint32_t * value,
+						struct rcar_cpg_mssr_data * data);
+
+typedef struct {
+	uint16_t reg;
+	uint8_t bit;
+} cpg_clock_info_t;
+
+typedef struct {
+	uint16_t reg;
+	uint8_t bit;
+	uint16_t mask;
+} cpg_division_ratio_info_t;
+
+static const cpg_clock_info_t loc_ClockStopRegBits[] = {
+	/* [Clock Name] =                { Reg,            Bit}, */
+	[R_CPG_ZS_CLOCK] =               { R_CPG_REG_NONE, 0u }, /* None,    - */    /* PRQA S 1053 */
+	[R_CPG_ZT_CLOCK] =               { R_CPG_REG_NONE, 0u }, /* None,    - */
+	[R_CPG_ZTR_CLOCK] =              { R_CPG_REG_NONE, 0u }, /* None,    - */
+	[R_CPG_Z0_CLOCK] =               { R_CPG_REG_NONE, 0u }, /* None,    - */
+	[R_CPG_ZB3_ZB3D2_ZB3D4_CLOCK] =  { R_CPG_REG_NONE, 0u }, /* None,    - */
+	[R_CPG_ZG_CLOCK] =               { R_CPG_REG_NONE, 0u }, /* None,    - */
+	[R_CPG_SDSRC_CLOCK] =            { R_CPG_REG_NONE, 0u }, /* None,    - */
+	[R_CPG_SD0H_CLOCK] =             { 0x0870u,        9u }, /* SD0CKCR,   STP0HCK */
+	[R_CPG_SD0_CLOCK] =              { 0x0870u,        8u }, /* SD0CKCR,   STP0CK */
+	[R_CPG_RPC_CLOCK] =              { 0x0874u,        8u }, /* RPCCKCR,   CKSTP */
+	[R_CPG_RPCD2_CLOCK] =            { 0x0874u,        9u }, /* RPCCKCR,   CKSTP2 */
+	[R_CPG_MSO_CLOCK] =              { 0x087Cu,        8u }, /* MSOCKCR,   CKSTP */
+	[R_CPG_CANFD_CLOCK] =            { 0x0878u,        8u }, /* CANFDCKCR, CKSTP */
+	[R_CPG_CSI_CLOCK] =              { 0x0880u,        8u }, /* CSICKCR,   CKSTP */
+	[R_CPG_POST2_CLOCK] =            { 0x0894u,        8u }, /* POST2CKCR, CKSTP */
+	[R_CPG_POST3_CLOCK] =            { 0x0898u,        8u }, /* POST3CKCR, CKSTP */
+	[R_CPG_POST4_CLOCK] =            { 0x089Cu,        8u }, /* POST4CKCR, CKSTP */
+	[R_CPG_POST_CLOCK] =             { 0x0890u,        8u }, /* POSTCKCR,  CKSTP */
+	[R_CPG_DSIEXT_CLOCK] =           { 0x0884u,        8u }, /* DSIEXTCKCR,CKSTP */
+	[R_CPG_ZR0_CLOCK] =              { R_CPG_REG_NONE, 0u }, /* None,   - */
+	[R_CPG_ZR1_CLOCK] =              { R_CPG_REG_NONE, 0u }, /* None,   - */
+	[R_CPG_ZR2_CLOCK] =              { R_CPG_REG_NONE, 0u }  /* None,   - */
+};
+
+static const cpg_division_ratio_info_t loc_DivisionRatioRegBits[] = {
+	/* [Clock Name] =                {Reg,      Bit, Mask         }, */
+	[R_CPG_ZS_CLOCK] =               { 0x0804u, 12u, (uint16_t)BIT_MASK(4u) }, /* FRQCRB, ZSFC[3:0]    */   /* PRQA S 1053 */
+	[R_CPG_ZT_CLOCK] =               { 0x0804u, 16u, (uint16_t)BIT_MASK(4u) }, /* FRQCRB, ZTFC[3:0]    */
+	[R_CPG_ZTR_CLOCK] =              { 0x0804u, 20u, (uint16_t)BIT_MASK(4u) }, /* FRQCRB, ZTRFC[3:0]   */
+	[R_CPG_Z0_CLOCK] =               { 0x0808u,  0u, (uint16_t)BIT_MASK(5u) }, /* FRQCRC0,Z0FC[4:0]    */
+	[R_CPG_ZB3_ZB3D2_ZB3D4_CLOCK] =  { 0x080Cu,  0u, (uint16_t)BIT_MASK(5u) }, /* FRQCRD,ZB3FC[4:0]    */
+	[R_CPG_ZG_CLOCK] =               { 0x0804u, 24u, (uint16_t)BIT_MASK(5u) }, /* FRQCRB, ZGFC[4:0]    */
+	[R_CPG_SDSRC_CLOCK] =            { 0x08A4u, 29u, (uint16_t)BIT_MASK(2u) }, /* CKSRCSELCR,SDSRCSEL[1:0] */
+	[R_CPG_SD0H_CLOCK] =             { 0x0870u,  2u, (uint16_t)BIT_MASK(3u) }, /* SD0CKCR, SDSRCFC[2:0] */
+	[R_CPG_SD0_CLOCK] =              { 0x0870u,  0u, (uint16_t)BIT_MASK(2u) }, /* SD0CKCR,  SD0FC[1:0]  */
+	[R_CPG_RPC_CLOCK] =              { 0x0874u,  0u, (uint16_t)BIT_MASK(5u) }, /* RPCCKCR,  RPCFC[4:0]  */
+	[R_CPG_RPCD2_CLOCK] =            { 0x0874u,  0u, (uint16_t)BIT_MASK(5u) }, /* RPCCKCR,  RPCFC[4:0]  */
+	[R_CPG_MSO_CLOCK] =              { 0x087Cu,  0u, (uint16_t)BIT_MASK(6u) }, /* MSOCKCR,  DIV[5:0]    */
+	[R_CPG_CANFD_CLOCK] =            { 0x0878u,  0u, (uint16_t)BIT_MASK(6u) }, /* CANFDCKCR,DIV[5:0]    */
+	[R_CPG_CSI_CLOCK] =              { 0x0880u,  0u, (uint16_t)BIT_MASK(6u) }, /* CSICKCR,  DIV[5:0]    */
+	[R_CPG_POST2_CLOCK] =            { 0x0894u,  0u, (uint16_t)BIT_MASK(6u) }, /* POST2CKCR,DIV[5:0]    */
+	[R_CPG_POST3_CLOCK] =            { 0x0898u,  0u, (uint16_t)BIT_MASK(6u) }, /* POST3CKCR,DIV[5:0]    */
+	[R_CPG_POST4_CLOCK] =            { 0x089Cu,  0u, (uint16_t)BIT_MASK(6u) }, /* POST4CKCR,DIV[5:0]    */
+	[R_CPG_POST_CLOCK] =             { 0x0890u,  0u, (uint16_t)BIT_MASK(6u) }, /* POSTCKCR, DIV[5:0]    */
+	[R_CPG_DSIEXT_CLOCK] =           { 0x0884u,  0u, (uint16_t)BIT_MASK(6u) }, /* DSIEXTCKCR, DIV[5:0]  */
+	[R_CPG_ZR0_CLOCK] =              { 0x0808u, 16u, (uint16_t)BIT_MASK(5u) }, /* FRQCRC0,  ZR0FC[4:0] */
+	[R_CPG_ZR1_CLOCK] =              { 0x0808u, 24u, (uint16_t)BIT_MASK(5u) }, /* FRQCRC0,  ZR1FC[4:0] */
+	[R_CPG_ZR2_CLOCK] =              { 0x08E0u, 16u, (uint16_t)BIT_MASK(5u) }  /* FRQCRC1,  ZR2FC[4:0] */
+};
+
+/* Module stop control registers */
+static const uint16_t loc_MstpOffset[] = {
+	R_CPG_MSTPCR0,
+	R_CPG_MSTPCR1,
+	R_CPG_MSTPCR2,
+	R_CPG_MSTPCR3,
+	R_CPG_MSTPCR4,
+	R_CPG_MSTPCR5,
+	R_CPG_MSTPCR6,
+	R_CPG_MSTPCR7,
+	R_CPG_MSTPCR8,
+	R_CPG_MSTPCR9,
+	R_CPG_MSTPCR10,
+	R_CPG_MSTPCR11,
+	R_CPG_MSTPCR12,
+	R_CPG_MSTPCR13,
+	R_CPG_MSTPCR14,
+	R_CPG_MSTPCR15,
+	R_CPG_MSTPCR16,
+	R_CPG_MSTPCR17,
+	R_CPG_MSTPCR18,
+	R_CPG_MSTPCR19,
+	R_CPG_MSTPCR20,
+	R_CPG_MSTPCR21,
+	R_CPG_MSTPCR22,
+	R_CPG_MSTPCR23,
+	R_CPG_MSTPCR24,
+	R_CPG_MSTPCR25,
+	R_CPG_MSTPCR26,
+	R_CPG_MSTPCR27,
+	R_CPG_MSTPCR28,
+	R_CPG_MSTPCR29
+};
+
+/* Software reset registers */
+static const uint16_t loc_SrcrOffset[] = {
+	R_CPG_SRCR0,
+	R_CPG_SRCR1,
+	R_CPG_SRCR2,
+	R_CPG_SRCR3,
+	R_CPG_SRCR4,
+	R_CPG_SRCR5,
+	R_CPG_SRCR6,
+	R_CPG_SRCR7,
+	R_CPG_SRCR8,
+	R_CPG_SRCR9,
+	R_CPG_SRCR10,
+	R_CPG_SRCR11,
+	R_CPG_SRCR12,
+	R_CPG_SRCR13,
+	R_CPG_SRCR14,
+	R_CPG_SRCR15,
+	R_CPG_SRCR16,
+	R_CPG_SRCR17,
+	R_CPG_SRCR18,
+	R_CPG_SRCR19,
+	R_CPG_SRCR20,
+	R_CPG_SRCR21,
+	R_CPG_SRCR22,
+	R_CPG_SRCR23,
+	R_CPG_SRCR24,
+	R_CPG_SRCR25,
+	R_CPG_SRCR26,
+	R_CPG_SRCR27,
+	R_CPG_SRCR28,
+	R_CPG_SRCR29
+};
+
+
+static void loc_ProtectedRegClear(uintptr_t Addr, uint32_t Mask, struct rcar_cpg_mssr_data * data);
+static void loc_ProtectedRegSet(uintptr_t Addr, uint32_t Mask, struct rcar_cpg_mssr_data * data);
+static void loc_ModuleEnable(int RegNr, uint32_t BitNr, struct rcar_cpg_mssr_data * data);
+static void loc_ModuleDisable(int RegNr, uint32_t BitNr, struct rcar_cpg_mssr_data * data);
+static int cpg_mssr_blocking_start(const struct device * dev, clock_control_subsys_t sys);
+static int cpg_mssr_stop(const struct device * dev, clock_control_subsys_t sys);
+static int cpg_get_rate(const struct device * dev, clock_control_subsys_t sys, uint32_t *rate);
+static int rcar_cpg_mssr_init(const struct device * dev);
+static int cpg_set_rate(const struct device * dev, clock_control_subsys_t sys, clock_control_subsys_rate_t rate);
+static enum clock_control_status cpg_get_module_stop_status(const struct device * dev, clock_control_subsys_t sys);
+static enum clock_control_status cpg_get_clock_stop_status(const struct device * dev, clock_control_subsys_t sys);
+static enum clock_control_status cpg_get_reset_status(const struct device * dev, clock_control_subsys_t sys);
+static enum clock_control_status cpg_get_status(const struct device * dev, clock_control_subsys_t sys);
+
+
+/*
+ * Clear a protected register which address is given. It unlock the "write"
+ *          access by writing into Configure register.
+ *
+ * @param[in]   Addr - Register address
+ * @param[in]   Mask - the current register value shall be masked with this variable
+ * @param[in]   data - Address of the device instance private data
+ */
+static void loc_ProtectedRegClear(uintptr_t Addr, uint32_t Mask,
+							struct rcar_cpg_mssr_data * data) /* PRQA S 3673 */
+{
+	uint32_t val;
+
+	sys_write32(0xA5A50000u, data->base_address + R_CPG_WPCR); /* Clear register protection */
+
+	val = sys_read32((mem_addr_t)Addr);            /* Generate value */
+	val = val & Mask;
+	sys_write32(~val, (mem_addr_t)(data->base_address + R_CPG_WPR)); /* Unlock write. *//* PRQA S 2985 */
+	sys_write32(val, (mem_addr_t)Addr);                /* Write value */
+
+	if ((sys_read32((mem_addr_t)Addr) & ~Mask) != 0u) {
+		LOG_ERR("CPG did not clear MSTP bits! (Addr 0x%lx, Mask 0x%x, actual 0x%x)\n", Addr, Mask, sys_read32((mem_addr_t)Addr));
+	}
+}
+
+/*
+ * Set protected register which address is given. It unlock the "write"
+ *          access by writing into Configure register.
+ *
+ * @param[in]   Addr - Register address
+ * @param[in]   Mask - the current register value shall be masked with this variable
+ * @param[in]   data - Address of the device instance private data
+ */
+static void loc_ProtectedRegSet(uintptr_t Addr, uint32_t Mask,
+							struct rcar_cpg_mssr_data * data) /* PRQA S 3673 */
+{
+	uint32_t val;
+
+	sys_write32(0xA5A50000u, (mem_addr_t)(data->base_address + R_CPG_WPCR)); /* Clear register protection */
+	val = sys_read32((mem_addr_t)Addr);
+	val = val | Mask;                             /* Generate value */
+	sys_write32(~val, (mem_addr_t)(data->base_address + R_CPG_WPR)); /* Unlock write. *//* PRQA S 2985 */
+	sys_write32(val, (mem_addr_t)Addr);                  /* Write value */
+}
+
+/*
+ * Enable module clock
+ *
+ * @param[in]   RegNr - Index of RMSTP registers
+ * @param[in]   BitNr - bit in RMSTP corresponding to the module
+ * @param[in]   data  - Address of the device instance private data
+ */
+static void loc_ModuleEnable(int RegNr, uint32_t BitNr,
+							struct rcar_cpg_mssr_data * data)
+{
+	loc_ProtectedRegClear(data->base_address + loc_MstpOffset[RegNr],
+					(uint32_t)(~(1ul << BitNr)), data);
+}
+
+/*
+ * Disable module clock
+ *
+ * @param[in]   RegNr - Index of RMSTP registers
+ * @param[in]   BitNr - bit in RMSTP corresponding to the module
+ * @param[in]   data  - Address of the device instance private data
+ */
+static void loc_ModuleDisable(int RegNr, uint32_t BitNr,
+							struct rcar_cpg_mssr_data * data)
+{
+	loc_ProtectedRegSet(data->base_address + loc_MstpOffset[RegNr],
+					(uint32_t)(1ul << BitNr), data);
+}
+
+static int R_CPG_SetModuleStopStat(r_cpg_RegIdx_t RegIdx, r_cpg_BitPos_t BitPos,
+				bool enable, struct rcar_cpg_mssr_data * data)   /* PRQA S 1056 */
+{
+	int ret = 0;
+	int mutex_ret;
+
+	/* Lock mutex */
+	mutex_ret = k_mutex_lock(&data->mutex, K_FOREVER);                /* PRQA S 1054 */
+	if (0 != mutex_ret)
+	{
+		ret = mutex_ret;
+		LOG_ERR("[R_CPG_SetModuleStopStat]mutex lock error. ret:%d.\n", ret);
+	}
+
+	if (0 == ret)
+	{
+		/* Argument check */
+		if (RegIdx > R_CPG_REGIDX_29)
+		{
+			ret = -EINVAL;
+			LOG_ERR("[R_CPG_SetModuleStopStat]: 1st argument error.\n");
+		}
+	}
+
+	if (0 == ret)
+	{
+		/* Argument check */
+		if (BitPos > R_CPG_BIT31)
+		{
+			ret = -EINVAL;
+			LOG_ERR("[R_CPG_SetModuleStopStat]: 2nd argument error.\n");
+		}
+	}
+
+	if (0 == ret)
+	{
+		/* module stop: enable */
+		if (true == enable)
+		{
+			/* Disable module clock */
+			loc_ModuleDisable((int)RegIdx, (uint32_t)BitPos, data);
+		}
+		/* module stop: disable */
+		else
+		{
+			/* Enable module clock */
+			loc_ModuleEnable((int)RegIdx, (uint32_t)BitPos, data);
+		}
+	}
+
+	if (0 == mutex_ret)
+	{
+		/* Unlock mutex */
+		mutex_ret = k_mutex_unlock(&data->mutex);
+		if (0 != mutex_ret)
+		{
+			ret = mutex_ret;
+			LOG_ERR("[R_CPG_SetModuleStopStat]mutex unlock error. ret:%d.\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+
+static int R_CPG_GetModuleStopStat(r_cpg_RegIdx_t RegIdx, r_cpg_BitPos_t BitPos,
+				bool * enable, struct rcar_cpg_mssr_data * data) /* PRQA S 1056 */
+{
+	/* Module stop status registers */
+	static const uint16_t loc_MstpsrOffset[] = {
+	    R_CPG_MSTPSR0,
+	    R_CPG_MSTPSR1,
+	    R_CPG_MSTPSR2,
+	    R_CPG_MSTPSR3,
+	    R_CPG_MSTPSR4,
+	    R_CPG_MSTPSR5,
+	    R_CPG_MSTPSR6,
+	    R_CPG_MSTPSR7,
+	    R_CPG_MSTPSR8,
+	    R_CPG_MSTPSR9,
+	    R_CPG_MSTPSR10,
+	    R_CPG_MSTPSR11,
+	    R_CPG_MSTPSR12,
+	    R_CPG_MSTPSR13,
+	    R_CPG_MSTPSR14,
+	    R_CPG_MSTPSR15,
+	    R_CPG_MSTPSR16,
+	    R_CPG_MSTPSR17,
+	    R_CPG_MSTPSR18,
+	    R_CPG_MSTPSR19,
+	    R_CPG_MSTPSR20,
+	    R_CPG_MSTPSR21,
+	    R_CPG_MSTPSR22,
+	    R_CPG_MSTPSR23,
+	    R_CPG_MSTPSR24,
+	    R_CPG_MSTPSR25,
+	    R_CPG_MSTPSR26,
+	    R_CPG_MSTPSR27,
+	    R_CPG_MSTPSR28,
+	    R_CPG_MSTPSR29
+	};
+
+	int ret = 0;
+	int mutex_ret;
+	uint32_t ModuleStopStat;
+
+	/* Lock mutex */
+	mutex_ret = k_mutex_lock(&data->mutex, K_FOREVER);                /* PRQA S 1054 */
+	if (0 != mutex_ret)
+	{
+		ret = mutex_ret;
+		LOG_ERR("[R_CPG_GetModuleStopStat]mutex lock error. ret:%d.\n", ret);
+	}
+
+	/* Argument check */
+	if (RegIdx > R_CPG_REGIDX_29)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetModuleStopStat]: 1st argument error.\n");
+	}
+
+	/* Argument check */
+	if (BitPos > R_CPG_BIT31)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetModuleStopStat]: 2nd argument error.\n");
+	}
+
+	/* Argument check */
+	if (NULL == enable)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetModuleStopStat]: 3rd argument error(NULL).\n");
+	}
+
+	if (0 == ret)
+	{
+		/* Get value of MSTPSRn(n:RegIdx) BitPos */
+		ModuleStopStat = sys_read32((mem_addr_t)(data->base_address + loc_MstpsrOffset[RegIdx]))
+						& ((uint32_t)1u << BitPos);
+
+		/* 0:Supply of the clock signal to the corresponding module is enabled */
+		if (0u == ModuleStopStat)
+		{
+			*enable = false;
+		}
+		/* 1:Supply of the clock signal to the corresponding module is stopped */
+		else
+		{
+			*enable = true;
+		}
+	}
+
+	if (0 == mutex_ret)
+	{
+		/* Unlock mutex */
+		mutex_ret = k_mutex_unlock(&data->mutex);
+		if (0 != mutex_ret)
+		{
+			ret = mutex_ret;
+			LOG_ERR("[R_CPG_GetModuleStopStat]mutex unlock error. ret:%d.\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+static int R_CPG_SetResetStat(r_cpg_RegIdx_t RegIdx, r_cpg_BitPos_t BitPos,
+							uint32_t ResetStat, struct rcar_cpg_mssr_data * data)
+{
+	/* Software reset clear registers */
+	static const uint16_t loc_SrstclrOffset[] = {
+	    R_CPG_SRSTCLR0,
+	    R_CPG_SRSTCLR1,
+	    R_CPG_SRSTCLR2,
+	    R_CPG_SRSTCLR3,
+	    R_CPG_SRSTCLR4,
+	    R_CPG_SRSTCLR5,
+	    R_CPG_SRSTCLR6,
+	    R_CPG_SRSTCLR7,
+	    R_CPG_SRSTCLR8,
+	    R_CPG_SRSTCLR9,
+	    R_CPG_SRSTCLR10,
+	    R_CPG_SRSTCLR11,
+	    R_CPG_SRSTCLR12,
+	    R_CPG_SRSTCLR13,
+	    R_CPG_SRSTCLR14,
+	    R_CPG_SRSTCLR15,
+	    R_CPG_SRSTCLR16,
+	    R_CPG_SRSTCLR17,
+	    R_CPG_SRSTCLR18,
+	    R_CPG_SRSTCLR19,
+	    R_CPG_SRSTCLR20,
+	    R_CPG_SRSTCLR21,
+	    R_CPG_SRSTCLR22,
+	    R_CPG_SRSTCLR23,
+	    R_CPG_SRSTCLR24,
+	    R_CPG_SRSTCLR25,
+	    R_CPG_SRSTCLR26,
+	    R_CPG_SRSTCLR27,
+	    R_CPG_SRSTCLR28,
+	    R_CPG_SRSTCLR29
+	};
+
+	int ret = 0;
+	int mutex_ret;
+	uintptr_t SrcrAddr = 0u;
+	uintptr_t SrstclrAddr = 0u;
+	uint32_t val = 0u;
+
+	/* Lock mutex */
+	mutex_ret = k_mutex_lock(&data->mutex, K_FOREVER);                /* PRQA S 1054 */
+	if (0 != mutex_ret)
+	{
+		ret = mutex_ret;
+		LOG_ERR("[R_CPG_SetResetStat]mutex lock error. ret:%d.\n", ret);
+	}
+
+	/* Argument check */
+	if (RegIdx > R_CPG_REGIDX_29)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_SetResetStat]: 1st argument error.\n");
+	}
+	else
+	{
+		SrcrAddr = data->base_address + loc_SrcrOffset[RegIdx];
+		SrstclrAddr = data->base_address + loc_SrstclrOffset[RegIdx];
+	}
+
+	/* Argument check */
+	if (BitPos > R_CPG_BIT31)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_SetResetStat]: 2nd argument error.\n");
+	}
+	else
+	{
+		val = ((uint32_t)1u << BitPos);
+	}
+
+	if (0 == ret)
+	{
+		if (1u == ResetStat)
+		{
+			/* Set Software Reset */
+			sys_write32(val, (mem_addr_t)SrcrAddr);
+		}
+		else
+		{
+			/* Clear Software Reset */
+			sys_write32(val, (mem_addr_t)SrstclrAddr);
+			/* Wait for the bit in SRCRn to become 0 */
+			while (0u != (sys_read32((mem_addr_t)SrcrAddr) & val)) {
+			}
+		}
+	}
+
+	if (0 == mutex_ret)
+	{
+		/* Unlock mutex */
+		mutex_ret = k_mutex_unlock(&data->mutex);
+		if (0 != mutex_ret)
+		{
+			ret = mutex_ret;
+			LOG_ERR("[R_CPG_SetResetStat]mutex unlock error. ret:%d.\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+static int R_CPG_GetResetStat(r_cpg_RegIdx_t RegIdx, r_cpg_BitPos_t BitPos,
+						uint32_t * ResetStat, struct rcar_cpg_mssr_data * data)
+{
+	int ret = 0;
+	int mutex_ret;
+	uint32_t val;
+
+	/* Lock mutex */
+	mutex_ret = k_mutex_lock(&data->mutex, K_FOREVER);                /* PRQA S 1054 */
+	if (0 != mutex_ret)
+	{
+		ret = mutex_ret;
+		LOG_ERR("[R_CPG_GetResetStat]mutex lock error. ret:%d.\n", ret);
+	}
+
+	/* Argument check */
+	if (RegIdx > R_CPG_REGIDX_29)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetResetStat]: 1st argument error.\n");
+	}
+
+	/* Argument check */
+	if (BitPos > R_CPG_BIT31)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetResetStat]: 2nd argument error.\n");
+	}
+
+	/* Argument check */
+	if (NULL == ResetStat)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetResetStat]: 3rd argument error(NULL).\n");
+	}
+
+	if (0 == ret)
+	{
+		/* Get the target register value. */
+		val = sys_read32((mem_addr_t)(data->base_address + loc_SrcrOffset[RegIdx]));
+
+		/* Get value of SRCRn(n:RegIdx) BitPos */
+		if (0u == (val & (1ul << BitPos))) /* PRQA S 1821,4532 */
+		{
+			*ResetStat = 0u;
+		}
+		else
+		{
+			*ResetStat = 1u;
+		}
+	}
+
+	if (0 == mutex_ret)
+	{
+		/* Unlock mutex */
+		mutex_ret = k_mutex_unlock(&data->mutex);
+		if (0 != mutex_ret)
+		{
+			ret = mutex_ret;
+			LOG_ERR("[R_CPG_GetResetStat]mutex unlock error. ret:%d.\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+static int R_CPG_SetClockStopStat(r_cpg_ClockName_t ClockName, bool enable, /* PRQA S 1056 */
+								struct rcar_cpg_mssr_data * data)
+{
+	int ret = 0;
+	int mutex_ret;
+	const cpg_clock_info_t * regs;
+
+	/* Lock mutex */
+	mutex_ret = k_mutex_lock(&data->mutex, K_FOREVER);                /* PRQA S 1054 */
+	if (0 != mutex_ret)
+	{
+		ret = mutex_ret;
+		LOG_ERR("[R_CPG_SetClockStopStat]mutex lock error. ret:%d.\n", ret);
+	}
+
+	/* Argument check */
+	if (ClockName >= R_CPG_CLOCK_LAST)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_SetClockStopStat]: 1st argument error.\n");
+	}
+
+	if (0 == ret)
+	{
+		regs = &loc_ClockStopRegBits[ClockName];
+		/* When there is no corresponding register */
+		if (R_CPG_REG_NONE == regs->reg)
+		{
+			ret = -EINVAL;
+			LOG_ERR("[R_CPG_SetClockStopStat]: 1st arg error(ClockName:%d). Clock Stop operation is not possible.\n",
+					ClockName);
+		}
+		else
+		{
+			/* clock stop: enable */
+			if (true == enable)
+			{
+				/* 1: Stops clock */
+				loc_ProtectedRegSet(data->base_address + regs->reg,
+					((uint32_t)1u << regs->bit), data);
+			}
+			/* clock stop: disable */
+			else
+			{
+				/* 0: Supplies clock */
+				loc_ProtectedRegClear(data->base_address + regs->reg,
+					(~((uint32_t)1u << regs->bit)), data); /* PRQA S 4471,4499 */
+			}
+		}
+	}
+
+	if (0 == mutex_ret)
+	{
+		/* Unlock mutex */
+		mutex_ret = k_mutex_unlock(&data->mutex);
+		if (0 != mutex_ret)
+		{
+			ret = mutex_ret;
+			LOG_ERR("[R_CPG_SetClockStopStat]mutex unlock error. ret:%d.\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+static int R_CPG_GetClockStopStat(r_cpg_ClockName_t ClockName, bool * enable, /* PRQA S 1056 */
+								struct rcar_cpg_mssr_data * data)
+{
+	int ret = 0;
+	int mutex_ret;
+	const cpg_clock_info_t * regs;
+	uint32_t ClockStat;
+
+	/* Lock mutex */
+	mutex_ret = k_mutex_lock(&data->mutex, K_FOREVER);                /* PRQA S 1054 */
+	if (0 != mutex_ret)
+	{
+		ret = mutex_ret;
+		LOG_ERR("[R_CPG_GetClockStopStat]mutex lock error. ret:%d.\n", ret);
+	}
+
+	/* Argument check */
+	if (ClockName >= R_CPG_CLOCK_LAST)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetClockStopStat]: 1st argument error.\n");
+	}
+
+	/* Argument check */
+	if (NULL == enable)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetClockStopStat]: 2nd argument error(NULL).\n");
+	}
+
+	if (0 == ret)
+	{
+		/* Get value of reg->reg reg->bit */
+		regs = &loc_ClockStopRegBits[ClockName];
+		/* When there is no corresponding register */
+		if (R_CPG_REG_NONE == regs->reg)
+		{
+			/* This Clock cannot be stopped, so it is returned as Supply clock. */
+			ClockStat = 0u;
+		}
+		else
+		{
+			ClockStat = sys_read32((mem_addr_t)(data->base_address + regs->reg)) & ((uint32_t)1u << regs->bit); /* PRQA S 1821,4532 */
+		}
+
+		/* 0: Supplies clock */
+		if (0u == ClockStat)
+		{
+			*enable = false;
+		}
+		/* 1: Stops clock */
+		else
+		{
+			*enable = true;
+		}
+	}
+
+	if (0 == mutex_ret)
+	{
+		/* Unlock mutex */
+		mutex_ret = k_mutex_unlock(&data->mutex);
+		if (0 != mutex_ret)
+		{
+			ret = mutex_ret;
+			LOG_ERR("[R_CPG_GetClockStopStat]mutex unlock error. ret:%d.\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+static int R_CPG_SetClock(r_cpg_ClockName_t ClockName, uint32_t value,
+						struct rcar_cpg_mssr_data * data)
+{
+	int ret = 0;
+	int mutex_ret;
+	const cpg_division_ratio_info_t * regs;
+	uint32_t readval;
+	uint32_t writeval;
+
+	/* Lock mutex */
+	mutex_ret = k_mutex_lock(&data->mutex, K_FOREVER);                /* PRQA S 1054 */
+	if (0 != mutex_ret)
+	{
+		ret = mutex_ret;
+		LOG_ERR("[R_CPG_SetClock]mutex lock error. ret:%d.\n", ret);
+	}
+
+	/* Argument check */
+	if (ClockName >= R_CPG_CLOCK_LAST)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_SetClock]: 1st argument error.\n");
+	}
+
+	if (0 == ret)
+	{
+		/* get division ratio info */
+		regs = &loc_DivisionRatioRegBits[ClockName];
+
+		switch (ClockName)
+		{
+		case R_CPG_ZS_CLOCK:
+		case R_CPG_ZT_CLOCK:
+		case R_CPG_ZTR_CLOCK:
+		case R_CPG_ZG_CLOCK:
+		case R_CPG_ZB3_ZB3D2_ZB3D4_CLOCK:
+			/* Set kick bit to 1 before setting Division ratio */
+			loc_ProtectedRegSet(data->base_address + regs->reg,
+				(uint32_t)(1u << R_CPG_KICK), data);
+			break;
+		default:
+			break;
+		}
+
+		/* Set division ratio */
+		/* Division Ratio value to set */
+		value = value & regs->mask;
+		/* read register */
+		readval = sys_read32((mem_addr_t)(data->base_address + regs->reg));
+		/* Clear the division ratio setting destination to 0 */
+		readval = readval & ~(regs->mask << regs->bit);
+		/* Write register value */
+		writeval = (value << regs->bit) | readval;
+
+		/* Unlock write */
+		sys_write32(~writeval, (mem_addr_t)(data->base_address + R_CPG_WPR));
+		/* write value */
+		sys_write32(writeval, (mem_addr_t)(data->base_address + regs->reg));
+	}
+
+	if (0 == mutex_ret)
+	{
+		/* Unlock mutex */
+		mutex_ret = k_mutex_unlock(&data->mutex);
+		if (0 != mutex_ret)
+		{
+			ret = mutex_ret;
+			LOG_ERR("[R_CPG_SetClock]mutex unlock error. ret:%d.\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+static int R_CPG_GetClock(r_cpg_ClockName_t ClockName, uint32_t * value,
+						struct rcar_cpg_mssr_data * data)
+{
+	int ret = 0;
+	int mutex_ret;
+	const cpg_division_ratio_info_t * regs;
+	uint32_t val;
+
+	/* Lock mutex */
+	mutex_ret = k_mutex_lock(&data->mutex, K_FOREVER);                /* PRQA S 1054 */
+	if (0 != mutex_ret)
+	{
+		ret = mutex_ret;
+		LOG_ERR("[R_CPG_GetClock]mutex lock error. ret:%d.\n", ret);
+	}
+
+	/* Argument check */
+	if (ClockName >= R_CPG_CLOCK_LAST)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetClock]: 1st argument error.\n");
+	}
+
+	/* Argument check */
+	if (NULL == value)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[R_CPG_GetClock]: 2nd argument error(NULL).\n");
+	}
+
+	if (0 == ret)
+	{
+		/* get division ratio info */
+		regs = &loc_DivisionRatioRegBits[ClockName];
+
+		/* Get the target register value. */
+		val = sys_read32((mem_addr_t)(data->base_address + regs->reg));
+
+		/* Get division ratio */
+		*value = (val >> regs->bit) & regs->mask;
+	}
+
+	if (0 == mutex_ret)
+	{
+		/* Unlock mutex */
+		mutex_ret = k_mutex_unlock(&data->mutex);
+		if (0 != mutex_ret)
+		{
+			ret = mutex_ret;
+			LOG_ERR("[R_CPG_GetClock]mutex unlock error. ret:%d.\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+struct rcar_mssr_config {
+	uint32_t base_address;
+};
+
+static int cpg_mssr_blocking_start(const struct device * dev,
+								clock_control_subsys_t sys)
+{
+	struct rcar_cpg_clk * clk = (struct rcar_cpg_clk *)sys; /* PRQA S 316 */
+	int ret;
+	uint32_t regidx; /* Value of n in the MSTPCRn register */
+	uint32_t bit_number; /* Bit number of the MSTPCR register */
+
+	if (NULL == dev->data)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[cpg_mssr_blocking_start]: dev->data error(NULL).\n");
+	}
+	else
+	{
+		if (clk->domain == CPG_MOD)
+		{
+			regidx = clk->module / 100u;
+			bit_number = clk->module % 100u;
+
+			/* Disable Module Stop. (In other words, enable Module.) */
+			ret = R_CPG_SetModuleStopStat((r_cpg_RegIdx_t)regidx, (r_cpg_BitPos_t)bit_number, false, dev->data); /* PRQA S 317 */
+		}
+		else if (clk->domain == CPG_CORE)
+		{
+			/* Disable Clock Stop. (In other words, enable Clock.) */
+			ret = R_CPG_SetClockStopStat((r_cpg_ClockName_t)clk->module, false, dev->data); /* PRQA S 317 */
+		}
+		else
+		{
+			LOG_ERR("[cpg_mssr_blocking_start]error domain:%d.\n", clk->domain);
+			ret = -ENOTSUP;
+		}
+	}
+
+	return ret;
+}
+
+static int cpg_mssr_stop(const struct device * dev,
+						clock_control_subsys_t sys)
+{
+	struct rcar_cpg_clk * clk = (struct rcar_cpg_clk *)sys; /* PRQA S 316 */
+	int ret;
+	uint32_t regidx;
+	uint32_t bit_number;
+
+	if (NULL == dev->data)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[cpg_mssr_stop]: dev->data error(NULL).\n");
+	}
+	else
+	{
+		if (clk->domain == CPG_MOD)
+		{
+			regidx = clk->module / 100u; /* Value of n in the MSTPCRn register */
+			bit_number = clk->module % 100u;    /* Bit number of the MSTPCR register */
+
+			/* Enable Module Stop. (In other words, disable Module.) */
+			ret = R_CPG_SetModuleStopStat((r_cpg_RegIdx_t)regidx, (r_cpg_BitPos_t)bit_number, true, dev->data); /* PRQA S 317 */
+		}
+		else if (clk->domain == CPG_CORE)
+		{
+			/* Enable Clock Stop. (In other words, disable Clock.) */
+			ret = R_CPG_SetClockStopStat((r_cpg_ClockName_t)clk->module, true, dev->data); /* PRQA S 317 */
+		}
+		else if (clk->domain == CPG_RESET)
+		{
+			regidx = clk->module / 100u; /* Value of n in the SRCRn/SRSTCLRn */
+			bit_number = clk->module % 100u;    /* Bit number of the SRCR/SRSTCLR */
+
+			/* Set a state of the CPG reset for specified module */
+			ret = R_CPG_SetResetStat((r_cpg_RegIdx_t)regidx, (r_cpg_BitPos_t)bit_number, clk->reset_state, dev->data); /* PRQA S 317 */
+		}
+		else
+		{
+			LOG_ERR("[cpg_mssr_stop]error domain:%d.\n", clk->domain);
+			ret = -ENOTSUP;
+		}
+	}
+
+	return ret;
+}
+
+static int cpg_get_rate(const struct device * dev, clock_control_subsys_t sys,
+						uint32_t *rate)
+{
+	struct rcar_cpg_clk * clk = (struct rcar_cpg_clk *)sys; /* PRQA S 316 */
+	int ret = 0;
+
+	if (NULL == dev->data)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[cpg_get_rate]: dev->data error(NULL).\n");
+	}
+	else
+	{
+		if (clk->domain == CPG_CORE)
+		{
+			switch (clk->module)
+			{
+			case (unsigned int)CPG_CORE_CLK_S0D12:
+				*rate = S0D12_CLK_RATE;
+				break;
+			default:
+				LOG_ERR("[cpg_get_rate]error module:%d.\n", clk->module);
+				ret = -ENOTSUP;
+				break;
+			}
+		}
+		else if (clk->domain == CPG_DIVISION_RATIO)
+		{
+			/* Get division ratio */
+			ret = R_CPG_GetClock((r_cpg_ClockName_t)clk->module, rate, dev->data); /* PRQA S 317 */
+		}
+		else
+		{
+			LOG_ERR("[cpg_get_rate]error domain:%d.\n", clk->domain);
+			ret = -ENOTSUP;
+		}
+	}
+
+	return ret;
+}
+
+static int rcar_cpg_mssr_init(const struct device * dev) /* PRQA S 3219 */
+{
+	int ret;
+	struct rcar_cpg_mssr_data * rcar_data = dev->data; /* PRQA S 317 */
+	const struct rcar_mssr_config * rcar_config = dev->config; /* PRQA S 317 */
+
+	/* Initialize mutex */
+	ret = k_mutex_init(&rcar_data->mutex);
+	if (0 != ret)
+	{
+		LOG_ERR("[rcar_cpg_mssr_init]mutex init error. ret:%d.\n", ret);
+	}
+	/* Set base_address to rcar_data */
+	rcar_data->base_address = rcar_config->base_address;
+
+	return ret;
+}
+
+static int cpg_set_rate(const struct device * dev, clock_control_subsys_t sys,
+						clock_control_subsys_rate_t rate) /* PRQA S 3673 */
+{
+	struct rcar_cpg_clk * clk = (struct rcar_cpg_clk *)sys; /* PRQA S 316 */
+	int ret;
+
+	if (NULL == dev->data)
+	{
+		ret = -EINVAL;
+		LOG_ERR("[cpg_set_rate]: dev->data error(NULL).\n");
+	}
+	else
+	{
+		if (clk->domain == CPG_DIVISION_RATIO)
+		{
+			/* Set division ratio */
+			ret = R_CPG_SetClock((r_cpg_ClockName_t)clk->module, (uint32_t)rate, dev->data); /* PRQA S 317 */
+		}
+		else
+		{
+			LOG_ERR("[cpg_set_rate]error domain:%d.\n", clk->domain);
+			ret = -ENOTSUP;
+		}
+	}
+
+	return ret;
+}
+
+
+static enum clock_control_status cpg_get_module_stop_status(const struct device * dev,
+												clock_control_subsys_t sys)
+{
+	struct rcar_cpg_clk * clk = (struct rcar_cpg_clk *)sys; /* PRQA S 316 */
+	enum clock_control_status ret;
+	bool enable = false; /* PRQA S 1056 */
+	int r_cpg;
+	uint32_t regidx;
+	uint32_t bit_number;
+
+	regidx = clk->module / 100u; /* Value of n in the MSTPSRn register */
+	bit_number = clk->module % 100u;    /* Bit number of the MSTPSR register */
+
+	/* Get a state of the module stop for specified module */
+	r_cpg = R_CPG_GetModuleStopStat((r_cpg_RegIdx_t)regidx, (r_cpg_BitPos_t)bit_number, &enable, dev->data); /* PRQA S 317 */
+	if (0 == r_cpg)
+	{
+		/* Module Stop: enable */
+		if (true == enable)
+		{
+			/* Module: Disable */
+			ret = CLOCK_CONTROL_STATUS_OFF;
+		}
+		/* Module Stop: Disable */
+		else
+		{
+			/* Module: Enable */
+			ret = CLOCK_CONTROL_STATUS_ON;
+		}
+	}
+	else
+	{
+		LOG_ERR("[cpg_get_module_stop_status]NG GetModuleStopStat r_cpg:%d.\n", r_cpg);
+		ret = CLOCK_CONTROL_STATUS_UNKNOWN;
+	}
+
+	return ret;
+}
+
+static enum clock_control_status cpg_get_clock_stop_status(const struct device * dev,
+												clock_control_subsys_t sys)
+{
+	struct rcar_cpg_clk * clk = (struct rcar_cpg_clk *)sys; /* PRQA S 316 */
+	enum clock_control_status ret;
+	int r_cpg;
+	bool enable = false; /* PRQA S 1056 */
+
+	/* Get a state of the clock stop for specified module */
+	r_cpg = R_CPG_GetClockStopStat((r_cpg_ClockName_t)clk->module, &enable, dev->data); /* PRQA S 317 */
+	if (0 == r_cpg)
+	{
+		/* Clock Stop: enable */
+		if (true == enable)
+		{
+			/* Clock: Disable */
+			ret = CLOCK_CONTROL_STATUS_OFF;
+		}
+		/* Clock Stop: Disable */
+		else
+		{
+			/* Clock: Enable */
+			ret = CLOCK_CONTROL_STATUS_ON;
+		}
+	}
+	else
+	{
+		LOG_ERR("[cpg_get_clock_stop_status]NG GetClockStopStat r_cpg:%d.\n", r_cpg);
+		ret = CLOCK_CONTROL_STATUS_UNKNOWN;
+	}
+	return ret;
+}
+
+static enum clock_control_status cpg_get_reset_status(const struct device * dev,
+												clock_control_subsys_t sys)
+{
+	struct rcar_cpg_clk * clk = (struct rcar_cpg_clk *)sys; /* PRQA S 316 */
+	enum clock_control_status ret;
+	int r_cpg;
+	uint32_t reset_status = 0u;
+	uint32_t regidx;
+	uint32_t bit_number;
+
+	regidx = clk->module / 100u; /* Value of n in the SRCRn register */
+	bit_number = clk->module % 100u;    /* Bit number of the SRCR register */
+
+	/* Get a state of the CPG reset for specified module */
+	r_cpg = R_CPG_GetResetStat((r_cpg_RegIdx_t)regidx, (r_cpg_BitPos_t)bit_number, &reset_status, dev->data); /* PRQA S 317 */
+	if (0 == r_cpg)
+	{
+		/* SRCR target bit is 0 */
+		if (0u == reset_status)
+		{
+			/* SRCR target bit is 0 */
+			ret = CLOCK_CONTROL_STATUS_OFF;
+		}
+		/* SRCR target bit is 1 */
+		else
+		{
+			/* SRCR target bit is 1 */
+			ret = CLOCK_CONTROL_STATUS_ON;
+		}
+	}
+	else
+	{
+		LOG_ERR("[cpg_get_reset_status]NG GetClockStopStat r_cpg:%d.\n", r_cpg);
+		ret = CLOCK_CONTROL_STATUS_UNKNOWN;
+	}
+	return ret;
+}
+
+
+static enum clock_control_status cpg_get_status(const struct device * dev,
+												clock_control_subsys_t sys)
+{
+	struct rcar_cpg_clk * clk = (struct rcar_cpg_clk *)sys; /* PRQA S 316 */
+	enum clock_control_status ret;
+
+	if (NULL == dev->data)
+	{
+		ret = CLOCK_CONTROL_STATUS_UNKNOWN;
+		LOG_ERR("[cpg_get_status]: dev->data error(NULL).\n");
+	}
+	else
+	{
+		switch (clk->domain) {
+		case (unsigned int)CPG_MOD:
+			ret = cpg_get_module_stop_status(dev, sys);
+			break;
+		case (unsigned int)CPG_CORE:
+			ret = cpg_get_clock_stop_status(dev, sys);
+			break;
+		case (unsigned int)CPG_RESET:
+			ret = cpg_get_reset_status(dev, sys);
+			break;
+		default:
+			LOG_ERR("[cpg_get_status]error domain:%d.\n", clk->domain);
+			ret = CLOCK_CONTROL_STATUS_UNKNOWN;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static struct rcar_cpg_mssr_data cpg_data;
+
+static const struct clock_control_driver_api rcar_cpg_mssr_api = {
+	.on = &cpg_mssr_blocking_start,                     /* PRQA S 1053 */
+	.off = &cpg_mssr_stop,
+	.get_rate = &cpg_get_rate,
+	.set_rate = &cpg_set_rate,
+	.get_status = &cpg_get_status,
+};
+
+#define RCAR_MSSR_INIT(inst)									\
+	static struct rcar_mssr_config rcar_mssr##inst##_config = { \
+		.base_address = DT_INST_REG_ADDR(inst)					\
+	};															\
+																\
+	DEVICE_DT_INST_DEFINE(inst,									\
+						&rcar_cpg_mssr_init,					\
+						NULL,									\
+						&cpg_data, &rcar_mssr##inst##_config,	\
+						PRE_KERNEL_1,							\
+						CONFIG_CLOCK_CONTROL_INIT_PRIORITY,		\
+						&rcar_cpg_mssr_api); /* PRQA S 342,3412 */
+
+DT_INST_FOREACH_STATUS_OKAY(RCAR_MSSR_INIT)
diff --git a/drivers/ethernet/CMakeLists.txt b/drivers/ethernet/CMakeLists.txt
index 97896e1609..4f3693ad4d 100644
--- a/drivers/ethernet/CMakeLists.txt
+++ b/drivers/ethernet/CMakeLists.txt
@@ -28,6 +28,7 @@ zephyr_library_sources_ifdef(CONFIG_ETH_STM32_HAL	eth_stm32_hal.c)
 zephyr_library_sources_ifdef(CONFIG_ETH_W5500		eth_w5500.c)
 zephyr_library_sources_ifdef(CONFIG_ETH_SAM_GMAC	eth_sam_gmac.c)
 zephyr_library_sources_ifdef(CONFIG_DSA_KSZ8XXX		dsa_ksz8xxx.c)
+zephyr_library_sources_ifdef(CONFIG_ETH_RCAR		eth_rcar.c)
 
 if(CONFIG_ETH_NATIVE_POSIX)
   set(native_posix_source_files eth_native_posix.c eth_native_posix_adapt.c)
diff --git a/drivers/ethernet/Kconfig b/drivers/ethernet/Kconfig
index 1b25045a32..3685024aa4 100644
--- a/drivers/ethernet/Kconfig
+++ b/drivers/ethernet/Kconfig
@@ -1,6 +1,7 @@
 # Ethernet drivers configuration options
 
 # Copyright (c) 2015 Intel Corporation
+# Copyright (c) 2022 Renesas Electronics Corporation
 # SPDX-License-Identifier: Apache-2.0
 
 menu "Ethernet Drivers"
@@ -59,6 +60,7 @@ source "drivers/ethernet/Kconfig.gecko"
 source "drivers/ethernet/Kconfig.w5500"
 source "drivers/ethernet/Kconfig.dsa"
 source "drivers/ethernet/Kconfig.xlnx_gem"
+source "drivers/ethernet/Kconfig.rcar"
 
 source "drivers/ethernet/phy/Kconfig"
 
diff --git a/drivers/ethernet/Kconfig.rcar b/drivers/ethernet/Kconfig.rcar
new file mode 100644
index 0000000000..c6bf7248ed
--- /dev/null
+++ b/drivers/ethernet/Kconfig.rcar
@@ -0,0 +1,72 @@
+# Rcar ethernet driver configuration options
+
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+menuconfig ETH_RCAR
+	bool "Rcar Ethernet driver"
+	depends on SOC_SERIES_RCAR_GEN4
+	help
+	  Enable rcar ethernet driver. Note, this driver is run inside
+	  a process in your host system.
+
+if ETH_RCAR
+config ETH_RCAR_INTERFACE_COUNT
+	int "Number of network interfaces created"
+	default 1
+	range 1 3
+	help
+	  By default only one network interface is created. It is possible
+	  to create multiple interfaces in certain use cases.
+
+config ETH_RCAR_DRV_NAME
+	string "Ethernet driver name"
+	default "zeth"
+	help
+	  This option sets the driver name and name of the network interface
+	  in your host system. If there are multiple network interfaces defined,
+	  then this value is used as a prefix and the interface names will be
+	  zeth0, zeth1, etc.
+
+config ETH_RCAR_MAC_ADDR
+	string "MAC address of R-Car board"
+	default "11:22:33:44:55:66"
+	help
+	  Specify a MAC address for the ethernet interface in the form of
+	  six hex 8-bit chars separated by colons (e.g.:
+	  aa:33:cc:22:e2:c0).  The default is 11:22:33:44:55:66.
+
+config ETH_RCAR_RX_BUF_TOTAL
+	int "Number of RX buffer"
+	default 20
+	range 1 255
+	help
+	  The number of receive descriptor for store packet.
+
+config ETH_RCAR_TX_BUF_TOTAL
+	int "Number of TX buffer"
+	default 10
+	range 1 255
+	help
+	  The number of transmit descriptor for store packet.
+
+config ETH_RCAR_RX_BUF_SIZE
+	int "Size of RX buffer"
+	default 128
+	range 64 1522
+	help
+	  Size of receive buffer.
+
+config ETH_RCAR_TX_BUF_SIZE
+	int "Size of TX buffer"
+	default 128
+	range 64 1522
+	help
+	  Size of transmit buffer.
+
+config ETH_RCAR_SPEED
+	int "Transfer speed"
+	default 100
+	help
+	  This value should be 100 or 1000.
+endif # ETH_RCAR
diff --git a/drivers/ethernet/eth_rcar.c b/drivers/ethernet/eth_rcar.c
new file mode 100644
index 0000000000..89d3883b40
--- /dev/null
+++ b/drivers/ethernet/eth_rcar.c
@@ -0,0 +1,1537 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define LOG_MODULE_NAME eth_rcar
+
+#define DT_DRV_COMPAT renesas_rcar_eth
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_ETHERNET_LOG_LEVEL);
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <stddef.h>
+#include <zephyr/kernel.h>
+#include <zephyr/net/net_pkt.h>
+#include <zephyr/net/net_core.h>
+#include <zephyr/net/net_if.h>
+#include <zephyr/net/ethernet.h>
+#include <zephyr/net/lldp.h>
+#include <zephyr/drivers/clock_control.h>
+#include <zephyr/drivers/clock_control/rcar_clock_control.h>
+#include <zephyr/sys/sys_io.h>
+
+/****************************************************************/
+/* R-Car ETH Register                                           */
+/****************************************************************/
+#define RCAR_ETH_REG_CCC		0x0000u		/* AVB-DMAC Mode Register (CCC) */
+#define RCAR_ETH_REG_DBAT		0x0004u		/* Descriptor Base Address Table Register (DBAT) */
+#define RCAR_ETH_REG_CDAR0		0x0010u		/* Current Descriptor Address Register 0 (CDAR) */
+#define RCAR_ETH_REG_CSR		0x000Cu		/* AVB-DMAC Status Register (CSR) */
+#define RCAR_ETH_REG_ESR		0x0088u		/* Error Status Register (ESR) */
+#define RCAR_ETH_REG_APSR		0x008Cu		/* AVB-DMAC Product Specific Register (APSR) */
+#define RCAR_ETH_REG_RCR		0x0090u		/* Receive Configuration Register (RCR) */
+#define RCAR_ETH_REG_UFCV0		0x00C4u		/* Unread Frame Counter Register 0 (UFCV0) */
+#define RCAR_ETH_REG_UFCD0		0x00E0u		/* Unread Frame Counter Decrement Register 0 (UFCD0) */
+#define RCAR_ETH_REG_TGC		0x0300u		/* Transmit Configuration Register (TGC) */
+#define RCAR_ETH_REG_TCCR		0x0304u		/* Transmit Configuration Control Register (TCCR) */
+#define RCAR_ETH_REG_DIS		0x0354u		/* Descriptor Interrupt Status Register (DIS) */
+#define RCAR_ETH_REG_EIC		0x0358u		/* Error Interrupt Control Register (EIC) */
+#define RCAR_ETH_REG_EIS		0x035Cu		/* Error Interrupt Status Register (EIS) */
+#define RCAR_ETH_REG_RIC0		0x0360u		/* Receive Interrupt Control Register 0 (RIC0) */
+#define RCAR_ETH_REG_RIS0		0x0364u		/* Receive Interrupt Status Register 0 (RIS0) */
+#define RCAR_ETH_REG_RIC1		0x0368u		/* Receive Interrupt Control Register 1 (RIC1) */
+#define RCAR_ETH_REG_RIS1		0x036Cu		/* Receive Interrupt Status Register 1 (RIS1) */
+#define RCAR_ETH_REG_RIC2		0x0370u		/* Receive Interrupt Control Register 2 (RIC2) */
+#define RCAR_ETH_REG_RIS2		0x0374u		/* Receive Interrupt Status Register 2 (RIS2) */
+#define RCAR_ETH_REG_TIC		0x0378u		/* Transmit Interrupt Control Register (TIC) */
+#define RCAR_ETH_REG_TIS		0x037Cu		/* Transmit Interrupt Status Register (TIS) */
+#define RCAR_ETH_REG_ISS		0x0380u		/* Interrupt Summary Status Register (ISS) */
+#define RCAR_ETH_REG_CIE		0x0384u		/* Common Interrupt Enable register (CIE) */
+#define RCAR_ETH_REG_DIL		0x0440u		/* Descriptor Interrupt Line selection register (DIL) */
+#define RCAR_ETH_REG_EIL		0x0444u		/* Error Interrupt Line selection register (EIL) */
+#define RCAR_ETH_REG_TIL		0x0448u		/* Transmission Interrupt Line selection register (TIL) */
+#define RCAR_ETH_REG_DID		0x0454u		/* Descriptor Interrupt Disable register (DID) */
+#define RCAR_ETH_REG_EIE		0x0458u		/* Error Interrupt Enable register (EIE) */
+#define RCAR_ETH_REG_EID		0x045Cu		/* Error Interrupt Disable register (EID) */
+#define RCAR_ETH_REG_RIE0		0x0460u		/* Reception Interrupt Enable register 0 (RIE0) */
+#define RCAR_ETH_REG_RID0		0x0464u		/* Reception Interrupt Disable register 0 (RID0) */
+#define RCAR_ETH_REG_RIE1		0x0468u		/* Reception Interrupt Enable register 1 (RIE1) */
+#define RCAR_ETH_REG_RID1		0x046Cu		/* Reception Interrupt Disable register 1 (RID1) */
+#define RCAR_ETH_REG_RIE2		0x0470u		/* Reception Interrupt Enable register 2 (RIE2) */
+#define RCAR_ETH_REG_RID2		0x0474u		/* Reception Interrupt Disable register 2 (RID2) */
+#define RCAR_ETH_REG_TIE		0x0478u		/* Transmission Interrupt Enable register (TIE) */
+#define RCAR_ETH_REG_TID		0x047Cu		/* Transmission Interrupt Disable register (TID) */
+#define RCAR_ETH_REG_ECMR		0x0500u		/* E-MAC Mode Register (ECMR) */
+#define RCAR_ETH_REG_RFLR		0x0508u		/* Receive Frame Length Register (RFLR) */
+#define RCAR_ETH_REG_ECSR		0x0510u		/* E-MAC Status Register (ECSR) */
+#define RCAR_ETH_REG_ECSIPR		0x0518u		/* E-MAC Interrupt Permission Register (ECSIPR) */
+#define RCAR_ETH_REG_GECMR		0x05b0u		/* E-MAC Mode Register 2 (GECMR) */
+#define RCAR_ETH_REG_MAHR		0x05c0u		/* E-MAC Address High Register (MAHR) */
+#define RCAR_ETH_REG_MALR		0x05c8u		/* E-MAC Address Low Register (MALR) */
+
+/****************************************************************/
+/* Value of R-Car ETH Register                                  */
+/****************************************************************/
+#define ETH_TCCR_TSRQ_MASK			BIT_MASK(4)			/* Mask for Transmit Start Request TCCR.TSRQ[3:0] */
+#define ETH_EIS_QEF_BIT				BIT(2)				/* Mask for Queue Error Flag */
+#define ETH_EIS_INT_MASK			0x000107FFu			/* Mask for all Interrupt Status */
+#define ETH_EIE_QES_BIT				ETH_EIS_QEF_BIT		/* Enable Queue Error interrupt */
+#define ETH_EID_QED_BIT				ETH_EIS_QEF_BIT		/* Disable Queue Error interrupt */
+#define ETH_DID_INT_MASK			0x0000FFFEu			/* Mask for DID to disable all Descriptor Interrupt */
+#define ETH_CIE_VALUE				0x00020101u			/* Enable CL0M, CTIE, CRIE for CIE */
+#define ETH_RIE0_FRS0_BIT			BIT(0)				/* Enable Receive Frame 0 */
+#define ETH_RID0_INT_MASK			BIT_MASK(18)		/* Disable all Receive interrupt RID0.FRDx[17:0] */
+#define ETH_RIE2_VALUE				(BIT(31) | BIT(0))	/* Enable FIFO Full and RX queue 0 interrupt */
+#define ETH_RID2_INT_MASK			0x8003FFFFu			/* Disable all RX FIFO/queue interrupt */
+#define ETH_TIE_FTS0_BIT			BIT(0)				/* Enable TX queue 0 interrupt */
+#define ETH_TID_INT_MASK			0x000F0F0Fu			/* Disable all TX interrupt */
+#define ETH_RIS2_RFFF_BIT			BIT(31)				/* Mask for RFFF */
+#define ETH_RIS2_QFF_MASK			BIT_MASK(18)		/* Mask for RIS2.QEFx[17:0] */
+#define ETH_UFCV_CV_MASK			BIT_MASK(6)			/* Mask for UFCVi.CVx[5:0] */
+#define ETH_ECMR_DM_BIT				BIT(1)				/* Duplex Mode bit of ECMR */
+#define ETH_ECMR_TE_BIT				BIT(5)				/* Transmission Enable bit of ECMR */
+#define ETH_ECMR_RE_BIT				BIT(6)				/* Reception Enable bit of ECMR */
+#define ETH_CCC_OPC_CONFIG			0x00000001u			/* OPC=b'01: Configuration mode */
+#define ETH_CCC_OPC_OPERATION		0x00000002u			/* OPC=b'10: Operation mode */
+#define ETH_CCC_OPC_MASK			BIT_MASK(2)			/* Mask for CCC.OPC[1:0] */
+#define ETH_CSR_OPS_CONFIG			0x00000002u			/* OPS=b'0010: Configuration mode */
+#define ETH_CSR_OPS_MASK			BIT_MASK(4)			/* Mask for CSR.OPS[3:0] */
+#define ETH_GECMR_SPEED_100_VALUE	0x00000000u			/* Transfer Speed Setting 100 Mbps */
+#define ETH_GECMR_SPEED_1000_VALUE	0x00000001u			/* Transfer Speed Setting 1000 Mbps */
+#define ETH_RCR_VALUE				0x18000000u			/* Default value */
+#define ETH_TGC_VALUE				0x00222200u			/* Default value */
+
+/****************************************************************/
+/* R-Car PFC (Pin Function Controller) Register and Value       */
+/****************************************************************/
+#define RCAR_PFC_PMMR(addr)			((addr) & 0xFFFFF800u)	/* LSI Multiplexed Pin Setting Mask Register */
+
+/* for AVB0 */
+#define RCAR_PFC_REG_GPSR7					0xE6061840u	/* GPIO/Peripheral_Function Select register PortGroup 7 */
+#define RCAR_PFC_REG_IP0SR7					0xE6061860u	/* Peripheral Function Select register 0 PortGroup 7 */
+#define RCAR_PFC_REG_IP1SR7					0xE6061864u	/* Peripheral Function Select register 1 PortGroup 7 */
+#define RCAR_PFC_REG_IP2SR7					0xE6061868u	/* Peripheral Function Select register 2 PortGroup 7 */
+#define RCAR_PFC_GPSR7_ETH_ENABLE_MASK		0x001FFFFFu	/* [20:0]: Select AVB0_RX_CTL - AVB0_AVTP_PPS except bit 10 */
+#define RCAR_PFC_GPSR7_ETH_ENABLE			0x001FFBFFu	/* [20:0]: Select AVB0_RX_CTL - AVB0_AVTP_PPS except bit 10 */
+#define RCAR_PFC_IP0SR7_ETH_ENABLE_MASK		0xFFFFFFFFu	/* [31:0]: Set to 0 */
+#define RCAR_PFC_IP1SR7_ETH_ENABLE_MASK		0xFFFFFFFFu	/* [31:0]: Set to 0 */
+#define RCAR_PFC_IP2SR7_ETH_ENABLE_MASK		0x000FFFFFu	/* [19:0]: Set to 0 */
+
+/* for AVB1 */
+#define RCAR_PFC_REG_GPSR6					0xE6061040u	/* GPIO/Peripheral_Function Select register PortGroup 6 */
+#define RCAR_PFC_REG_IP0SR6					0xE6061060u	/* Peripheral Function Select register 0 PortGroup 6 */
+#define RCAR_PFC_REG_IP1SR6					0xE6061064u	/* Peripheral Function Select register 1 PortGroup 6 */
+#define RCAR_PFC_REG_IP2SR6					0xE6061068u	/* Peripheral Function Select register 2 PortGroup 6 */
+#define RCAR_PFC_GPSR6_ETH_ENABLE_MASK		0x001FFFFFu	/* [20:0]: Select AVB1_RX_TXCREFCLK - AVB1_MDIO except bit 1 */
+#define RCAR_PFC_GPSR6_ETH_ENABLE			0x001FFFFDu	/* [20:0]: Select AVB1_RX_TXCREFCLK - AVB1_MDIO except bit 1 */
+#define RCAR_PFC_IP0SR6_ETH_ENABLE_MASK		0xFFFFFFFFu	/* [31:0]: Set to 0 */
+#define RCAR_PFC_IP1SR6_ETH_ENABLE_MASK		0xFFFFFFFFu	/* [31:0]: Set to 0 */
+#define RCAR_PFC_IP2SR6_ETH_ENABLE_MASK		0x000FFFFFu	/* [19:0]: Set to 0 */
+
+/* for AVB2 */
+#define RCAR_PFC_REG_GPSR5					0xE6060840u	/* GPIO/Peripheral_Function Select register PortGroup 5 */
+#define RCAR_PFC_REG_IP0SR5					0xE6060860u	/* Peripheral Function Select register 0 PortGroup 5 */
+#define RCAR_PFC_REG_IP1SR5					0xE6060864u	/* Peripheral Function Select register 1 PortGroup 5 */
+#define RCAR_PFC_REG_IP2SR5					0xE6060868u	/* Peripheral Function Select register 2 PortGroup 5 */
+#define RCAR_PFC_GPSR5_ETH_ENABLE_MASK		0x001FFFFFu	/* [20:0]: Select AVB2_RX_CTL - AVB2_AVTP_PPS except bit 5 */
+#define RCAR_PFC_GPSR5_ETH_ENABLE			0x001FFFDFu	/* [20:0]: Select AVB2_RX_CTL - AVB2_AVTP_PPS except bit 5 */
+#define RCAR_PFC_IP0SR5_ETH_ENABLE_MASK		0xFFFFFFFFu	/* [31:0]: Set to 0 */
+#define RCAR_PFC_IP1SR5_ETH_ENABLE_MASK		0xFFFFFFFFu	/* [31:0]: Set to 0 */
+#define RCAR_PFC_IP2SR5_ETH_ENABLE_MASK		0x000FFFFFu	/* [19:0]: Set to 0 */
+
+/****************************************************************/
+/* Global Symbols                                               */
+/****************************************************************/
+/* Number of Descriptor */
+#define ETH_TXQ_MAXNUM			4u
+#define ETH_RXQ_MAXNUM			18u
+#define DBAT_ENTRY_NUM			(ETH_TXQ_MAXNUM + ETH_RXQ_MAXNUM)
+
+/* Number of Buffer */
+#define ETH_RX_BUF_TOTAL		(uint8_t)CONFIG_ETH_RCAR_RX_BUF_TOTAL /* Num of RX buffer: valid size is 1 to 255 */
+#define ETH_TX_BUF_TOTAL		(uint8_t)CONFIG_ETH_RCAR_TX_BUF_TOTAL /* Num of TX buffer: valid size is 1 to 255 */
+#define ETH_RX_BUF_SIZE			(uint32_t)CONFIG_ETH_RCAR_RX_BUF_SIZE /* RX buffer size: valid size is 64 to 1522 */
+#define ETH_TX_BUF_SIZE			(uint32_t)CONFIG_ETH_RCAR_TX_BUF_SIZE /* RX buffer size: valid size is 64 to 1522 */
+
+/* Size definitions */
+#define ETH_MAX_FRAME_SIZE		1522u	/* Maximum frame length */
+#define ETH_VLFRAME_SIZE		1524u	/* Add 2 bytes to make 4-byte aligned */
+#define ETH_NORMAL_DESC_SIZE	8u		/* Normal descriptor size(in byte) */
+#define ETH_EXTRA_FOR_LINKDESC	1u		/* Link descriptor number */
+#define ETH_EXTRA_FOR_EOSDESC	1u		/* EOS descriptor */
+#define ETH_MACADDR_SIZE		6u		/* MAC address size */
+#define NUM_RX_QUEUE			1u		/* Number of enabled RX queues (MAX 18 but current supported only BE queue) */
+#define NUM_TX_QUEUE			1u		/* Number of enabled RX queues (MAX 4 but current supported only BE queue) */
+#define ETH_CACHE_LINE_SIZE		64u		/* Cache alignment */
+#define ETH_CTRL_RX_BUF_LEN_CACHE_ALIGN \
+	(ETH_RX_BUF_SIZE + (ETH_CACHE_LINE_SIZE - (ETH_RX_BUF_SIZE % ETH_CACHE_LINE_SIZE)))
+#define ETH_CTRL_TX_BUF_LEN_CACHE_ALIGN \
+	(ETH_TX_BUF_SIZE + (ETH_CACHE_LINE_SIZE - (ETH_TX_BUF_SIZE % ETH_CACHE_LINE_SIZE)))
+#define ETH_RX_BUF_SIZE_CACHE_ALIGN \
+	(NUM_RX_QUEUE * ETH_RX_BUF_TOTAL * ETH_CTRL_RX_BUF_LEN_CACHE_ALIGN)
+#define ETH_TX_BUF_SIZE_CACHE_ALIGN \
+	(ETH_TX_BUF_TOTAL * ETH_CTRL_TX_BUF_LEN_CACHE_ALIGN)
+#define ETH_VLFRAME_SIZE_CACHE_ALIGN \
+	((ETH_VLFRAME_SIZE) + (ETH_CACHE_LINE_SIZE - (ETH_VLFRAME_SIZE % ETH_CACHE_LINE_SIZE)))
+
+/* Timeout definitions */
+#define ETH_NET_BUF_TIMEOUT		K_MSEC(100)	/* for net_pkt_rx_alloc_with_buffer */
+#define ETH_REG_WAIT_RETRY		10000u		/* for register read retry */
+#define ETH_REG_WAIT_TIMEOUT	K_USEC(10)	/* for register read interval */
+
+/* Descriptor Types */
+#define ETH_DESC_FMID			4u	/* Frame Middle */
+#define ETH_DESC_FSTART			5u	/* Frame Start */
+#define ETH_DESC_FEND			6u	/* Frame End */
+#define ETH_DESC_FSINGLE		7u	/* Frame Single */
+#define ETH_DESC_LINKFIX		9u	/* Fixed Link */
+#define ETH_DESC_EOS			10u	/* End Of Set */
+#define ETH_DESC_FEMPTY			12u	/* Frame Empty */
+
+/****************************************************************/
+/* Global Data Types                                            */
+/****************************************************************/
+typedef struct {
+	uint32_t Ds		: 12;
+	uint32_t Ctrl	: 12;
+	uint32_t Die	: 4;
+	uint32_t Dt		: 4;
+} Eth_DataDescLowType;
+
+typedef struct {
+	Eth_DataDescLowType	Header;
+	uint32_t			Dptr;
+} Eth_DataDescType;
+
+typedef struct {
+	uint32_t Res	: 24;
+	uint32_t Die	: 4;
+	uint32_t Dt		: 4;
+} Eth_LinkDescLowType;
+
+typedef struct {
+	Eth_LinkDescLowType	Header;
+	uint32_t			Dptr;
+} Eth_LinkDescType;
+
+struct queue_state {
+	bool is_using;	/* true: using, false: not using */
+	Eth_DataDescType * descAddr;
+};
+
+struct eth_rcar_dev_data {
+	uint8_t mac_addr[ETH_MACADDR_SIZE];
+	struct net_linkaddr ll_addr;
+	struct net_if * iface;
+	const char *if_name;
+	struct k_sem rx_sem[NUM_RX_QUEUE];
+	k_tid_t rx_thread;
+	bool init_done;
+	bool status;
+	struct queue_state tx_status[NUM_TX_QUEUE];
+	struct queue_state rx_status[NUM_RX_QUEUE];
+};
+
+typedef void (*init_func_t)(const struct device * dev);
+
+struct eth_rcar_dev_cfg {
+	struct z_thread_stack_element *rx_stack;
+	size_t rx_stack_size;
+	init_func_t init_func;
+	uint32_t base_address;
+	const struct device *clock_dev;
+	struct rcar_cpg_clk mod_clk;
+	int channel;
+	int speed; /* 100 or 1000 BASE */
+};
+
+/* Queue definition */
+enum RAVB_QUEUE {
+	RAVB_BE = 0,	/* Best Effort Queue */
+	RAVB_NC			/* Network Control Queue (Not used) */
+};
+
+/* Rx Frame definition */
+typedef struct {
+	uint32_t	FrameAddr;
+	uint32_t	FrameLength;
+} Eth_RxSingleFrameType;
+
+/****************************************************************/
+/* Global Data                                                  */
+/****************************************************************/
+/* Non-cached data (Descriptor and Buffer)  */
+#define __eth_rcar_desc_buf __attribute__((section(".eth_non_cache"))) __aligned(32)
+static Eth_DataDescType Eth_DescTable[DBAT_ENTRY_NUM] __eth_rcar_desc_buf;
+static Eth_DataDescType Eth_RxBeQueue[ETH_RX_BUF_TOTAL + ETH_EXTRA_FOR_LINKDESC] __eth_rcar_desc_buf;
+static Eth_DataDescType Eth_TxQueue[NUM_TX_QUEUE][ETH_TX_BUF_TOTAL +
+										ETH_EXTRA_FOR_EOSDESC + ETH_EXTRA_FOR_LINKDESC] __eth_rcar_desc_buf;
+static uint8_t Eth_RxBuff[ETH_RX_BUF_SIZE_CACHE_ALIGN] __eth_rcar_desc_buf;
+static uint8_t Eth_TxBuff[ETH_TX_BUF_SIZE_CACHE_ALIGN] __eth_rcar_desc_buf;
+static uint8_t Eth_RxMultiBuffFrame[NUM_RX_QUEUE][ETH_VLFRAME_SIZE_CACHE_ALIGN] __eth_rcar_desc_buf;
+
+/****************************************************************/
+/* Function Prototypes                                          */
+/****************************************************************/
+static inline uint32_t eth_rcar_ravb_read(uint32_t base, uint32_t reg);
+static inline void eth_rcar_ravb_write(uint32_t base, uint32_t data, uint32_t reg);
+static void eth_rcar_ravb_modify(uint32_t base, uint32_t reg, uint32_t clear, uint32_t set);
+static int eth_rcar_ravb_wait(uint32_t base, uint32_t reg, uint32_t mask, uint32_t value);
+static void eth_rcar_Desc_SetLinkFix(Eth_LinkDescType * LinkDesc, uint32_t AddrToLink);
+static void eth_rcar_Desc_SetFempty(Eth_DataDescType * DataDesc, int queue, uint8_t BufIndex);
+static void eth_rcar_Desc_Update(Eth_DataDescType * DataDesc);
+static int eth_rcar_Desc_Init(const struct device * dev);
+static int eth_rcar_Dmac_Init(const struct device * dev);
+static void eth_rcar_Emac_Init(const struct device * dev);
+static void eth_rcar_InterruptStatus_Init(uint32_t base_address);
+static void eth_rcar_PFC_Init(const int avb_ch);
+static void eth_rcar_SetMacAddr(uint32_t base_address, uint8_t * addr);
+static int eth_rcar_CompareMacAddr(volatile uint8_t * pSrcMac, uint8_t * pDstMac);
+static int eth_rcar_CheckRxFrame(uint8_t * mac_addr, uint32_t FrameAddr);
+static int eth_rcar_RxNormalQueueProcess(struct eth_rcar_dev_data * ctx, int queue, Eth_RxSingleFrameType * RxFrame,
+										Eth_DataDescType * DataDesc);
+static void eth_rcar_PassReceivedData(struct eth_rcar_dev_data * ctx, Eth_RxSingleFrameType * RxFrame);
+static void eth_rcar_Interrupt_rx(const struct device * dev, int queue);
+static void eth_rcar_Interrupt_tx(const struct device * dev, int queue);
+
+static void eth_rcar_isr_rx_be(const struct device * dev);
+static void eth_rcar_isr_tx_be(const struct device * dev);
+static void eth_rcar_isr_err(const struct device * dev);
+static void eth_rcar_ReceiveThread(const struct device * dev);
+static int eth_rcar_init(const struct device * dev);
+
+static void eth_rcar_iface_init(struct net_if * iface);
+static int eth_rcar_start_device(const struct device * dev);
+static int eth_rcar_stop_device(const struct device * dev);
+static enum ethernet_hw_caps eth_rcar_get_capabilities(const struct device * dev);
+static int eth_rcar_set_config(const struct device * dev, enum ethernet_config_type type,
+								const struct ethernet_config * config);
+static int eth_rcar_get_config(const struct device * dev, enum ethernet_config_type type,
+								struct ethernet_config * config);
+static int eth_rcar_send(const struct device * dev, struct net_pkt * pkt);
+
+/****************************************************************/
+/* Function Definitions                                         */
+/****************************************************************/
+
+/* Register Read */
+static inline uint32_t eth_rcar_ravb_read(uint32_t base, uint32_t reg)
+{
+	uint32_t data;
+
+	data = sys_read32(base + reg);
+	return data;
+}
+
+/* Register Write */
+static inline void eth_rcar_ravb_write(uint32_t base, uint32_t data, uint32_t reg)
+{
+	sys_write32(data, base + reg);
+}
+
+/* Register Read Modify Write */
+static void eth_rcar_ravb_modify(uint32_t base, uint32_t reg, uint32_t clear, uint32_t set)
+{
+	eth_rcar_ravb_write(base, (eth_rcar_ravb_read(base, reg) & ~clear) | set, reg);
+}
+
+/* Register Wait */
+static int eth_rcar_ravb_wait(uint32_t base, uint32_t reg, uint32_t mask, uint32_t value)
+{
+	int i;
+
+	for (i = 0; i < ETH_REG_WAIT_RETRY; i++)
+	{
+		if ((eth_rcar_ravb_read(base, reg) & mask) == value)
+		{
+			return 0;
+		}
+		k_sleep(ETH_REG_WAIT_TIMEOUT);
+	}
+
+	return -ETIMEDOUT;
+}
+
+/* Set descriptor for LinkFix */
+static void eth_rcar_Desc_SetLinkFix(Eth_LinkDescType * LinkDesc, uint32_t AddrToLink)
+{
+	if (NULL != LinkDesc)
+	{
+		LinkDesc->Header.Dt		= ETH_DESC_LINKFIX;
+		LinkDesc->Header.Die	= 0;
+		LinkDesc->Header.Res	= 0;
+		LinkDesc->Dptr			= AddrToLink;
+	}
+}
+
+/* Set descriptor for FEmpty */
+static void eth_rcar_Desc_SetFempty(Eth_DataDescType * DataDesc, int queue, uint8_t BufIndex)
+{
+	if (NULL != DataDesc)
+	{
+		if (queue == RAVB_BE)
+		{
+			/* RX Queue[0] (BE) */
+			DataDesc->Header.Dt		= ETH_DESC_FEMPTY;
+			DataDesc->Header.Die	= 0;
+			DataDesc->Header.Ctrl	= 0;
+			DataDesc->Header.Ds		= ETH_RX_BUF_SIZE;
+			DataDesc->Dptr			= (uint32_t)(&Eth_RxBuff[((queue * ETH_RX_BUF_TOTAL) + BufIndex) *
+													ETH_CTRL_RX_BUF_LEN_CACHE_ALIGN]);
+		}
+		else if (queue == (ETH_RXQ_MAXNUM + RAVB_BE))
+		{
+			/* TX Queue[0] */
+			DataDesc->Header.Dt		= ETH_DESC_FEMPTY;
+			DataDesc->Header.Die	= 0;
+			DataDesc->Header.Ctrl	= 0;
+			/* It will be set only during Transmission at run time */
+			DataDesc->Header.Ds		= 0;
+			DataDesc->Dptr			= 0;
+		}
+		else
+		{
+			LOG_ERR("[eth_rcar_Desc_SetFempty] Currently not support queue [%d]\n", queue);
+		}
+	}
+}
+
+/* Update descriptor */
+static void eth_rcar_Desc_Update(Eth_DataDescType * DataDesc)
+{
+	if (NULL != DataDesc)
+	{
+		DataDesc->Header.Dt		= ETH_DESC_FEMPTY;
+		DataDesc->Header.Die	= 0;
+		DataDesc->Header.Ctrl	= 0;
+		DataDesc->Header.Ds		= ETH_RX_BUF_SIZE;
+	}
+}
+
+/* Initialize descriptor */
+static int eth_rcar_Desc_Init(const struct device * dev)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	int ret = 0;
+	Eth_LinkDescType * LinkDesc;
+	Eth_DataDescType * CurrentDataDesc;
+	int i;
+	int bufIndex;
+
+	LinkDesc = (Eth_LinkDescType *)&Eth_DescTable[0];
+	for (i = 0; DBAT_ENTRY_NUM > i; i++)
+	{
+		if (i == RAVB_BE)
+		{
+			/* TX Queue[0] */
+			eth_rcar_Desc_SetLinkFix(LinkDesc, (uint32_t)&Eth_TxQueue[i]);
+			ctx->tx_status[i].descAddr = &Eth_TxQueue[i][0];
+		}
+		else if (i == (ETH_TXQ_MAXNUM + RAVB_BE))
+		{
+			/* RX Queue[0] (BE) */
+			eth_rcar_Desc_SetLinkFix(LinkDesc, (uint32_t)&Eth_RxBeQueue[0]);
+			ctx->rx_status[i - ETH_TXQ_MAXNUM].descAddr = &Eth_RxBeQueue[0];
+		}
+		else
+		{
+			/* Queue not use, wet Null Dptr field in Link Descriptor*/
+			eth_rcar_Desc_SetLinkFix(LinkDesc, 0x00000000u);
+		}
+		LinkDesc++;
+	}
+
+	/* Confirm current status is configuration mode */
+	ret = eth_rcar_ravb_wait(cfg->base_address, RCAR_ETH_REG_CSR, ETH_CSR_OPS_MASK, ETH_CSR_OPS_CONFIG);
+	if (ret != 0)
+	{
+		LOG_ERR("[eth_rcar_Desc_Init] Current status is not configuration mode, eth_rcar_ravb_wait [ret:%d]\n", ret);
+	}
+	else
+	{
+		/* Register Descriptor base table address to DBAT*/
+		eth_rcar_ravb_write(cfg->base_address, (uint32_t)&Eth_DescTable[0], RCAR_ETH_REG_DBAT);
+	}
+
+	LinkDesc = (Eth_LinkDescType *)(&Eth_DescTable[0]);
+	/* Initialize  Eth_TxQueue */
+	for (i = ETH_RXQ_MAXNUM; i < DBAT_ENTRY_NUM; i++)
+	{
+		if (LinkDesc->Dptr != 0)
+		{
+			/* TX */
+			CurrentDataDesc = (Eth_DataDescType *)(LinkDesc->Dptr);
+			for (bufIndex = 0; bufIndex < ETH_TX_BUF_TOTAL; bufIndex++)
+			{
+				/* Set FEmpty */
+				eth_rcar_Desc_SetFempty(CurrentDataDesc, i, 0);
+				CurrentDataDesc++;
+			}
+			/* Set FEmpty for EOS */
+			eth_rcar_Desc_SetFempty(CurrentDataDesc, i, 0);
+			CurrentDataDesc++;
+			/* Set LinkFix */
+			eth_rcar_Desc_SetLinkFix((Eth_LinkDescType *)CurrentDataDesc, LinkDesc->Dptr);
+		}
+		LinkDesc++;
+	}
+
+	/* Initialize  Eth_RxBeQueue */
+	for (i = 0; i < ETH_RXQ_MAXNUM; i++)
+	{
+		if (LinkDesc->Dptr != 0)
+		{
+			/* RX TimeStamp disable */
+			CurrentDataDesc = (Eth_DataDescType *)(LinkDesc->Dptr);
+			for (bufIndex = 0; bufIndex < ETH_RX_BUF_TOTAL; bufIndex++)
+			{
+				/* Set FEmpty for normal descriptor */
+				eth_rcar_Desc_SetFempty(CurrentDataDesc, i, bufIndex);
+				CurrentDataDesc++;
+			}
+			/* Set LinkFix */
+			eth_rcar_Desc_SetLinkFix((Eth_LinkDescType *)CurrentDataDesc, LinkDesc->Dptr);
+			if (i == 0)
+			{
+				ctx->rx_status[i].descAddr = (Eth_DataDescType *)(LinkDesc->Dptr);
+			}
+		}
+		LinkDesc++;
+	}
+
+	return ret;
+}
+
+/* Initialize device for Ethernet AVB */
+static int eth_rcar_Dmac_Init(const struct device * dev)
+{
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	int ret;
+
+	/* Set config mode */
+	eth_rcar_ravb_modify(cfg->base_address, RCAR_ETH_REG_CCC, ETH_CCC_OPC_MASK, ETH_CCC_OPC_CONFIG);
+	/* Check if the operating mode is changed to the config mode */
+	ret = eth_rcar_ravb_wait(cfg->base_address, RCAR_ETH_REG_CSR, ETH_CSR_OPS_MASK, ETH_CSR_OPS_CONFIG);
+	if (ret != 0)
+	{
+		LOG_ERR("[eth_rcar_Dmac_Init] failed to switch device to config mode, eth_rcar_ravb_wait ret:%d\n", ret);
+		return ret;
+	}
+
+	/* Initialize descrptor */
+	ret = eth_rcar_Desc_Init(dev);
+	if (ret != 0)
+	{
+		LOG_ERR("[eth_rcar_Dmac_Init] eth_rcar_Desc_Init error [ret:%d]\n", ret);
+		return ret;
+	}
+
+	/* Set AVB RX (Timestamp disable, Use only queue 0(BE), Disable error frame */
+	eth_rcar_ravb_write(cfg->base_address, ETH_RCR_VALUE, RCAR_ETH_REG_RCR);
+
+	/* Set FIFO size (Same as HW default value) */
+	eth_rcar_ravb_write(cfg->base_address, ETH_TGC_VALUE, RCAR_ETH_REG_TGC);
+
+	/* Initialize Ethernet AVB interrupt status */
+	eth_rcar_InterruptStatus_Init(cfg->base_address);
+
+	/* Enable/Disable interrupt settings */
+	eth_rcar_ravb_write(cfg->base_address, ETH_CIE_VALUE, RCAR_ETH_REG_CIE);	/* Enable CL0M, CTIE, CRIE for CIE */
+	eth_rcar_ravb_write(cfg->base_address, ETH_EIE_QES_BIT, RCAR_ETH_REG_EIE);	/* Enable Queue Error interrupt */
+	eth_rcar_ravb_write(cfg->base_address, ETH_DID_INT_MASK, RCAR_ETH_REG_DID);	/* Not use descriptor interrupt */
+	eth_rcar_ravb_write(cfg->base_address, 0u, RCAR_ETH_REG_DIL);				/* Select Line A */
+	eth_rcar_ravb_write(cfg->base_address, 0u, RCAR_ETH_REG_EIL);				/* Select Line A */
+	eth_rcar_ravb_write(cfg->base_address, 0u, RCAR_ETH_REG_TIL);				/* Select Line A */
+	eth_rcar_ravb_write(cfg->base_address, ETH_RIE0_FRS0_BIT, RCAR_ETH_REG_RIE0); /* Enable RX queue 0 */
+	eth_rcar_ravb_write(cfg->base_address, 0u, RCAR_ETH_REG_RID1);				/* Disable RX warning */
+	eth_rcar_ravb_write(cfg->base_address, ETH_RIE2_VALUE, RCAR_ETH_REG_RIE2);	/* Enable FIFO full and RX queue 0 */
+	eth_rcar_ravb_write(cfg->base_address, ETH_TIE_FTS0_BIT, RCAR_ETH_REG_TIE);	/* Enable TX queue 0 interrupt */
+
+	/* Setting the control will start the AVB-DMAC process. */
+	eth_rcar_ravb_modify(cfg->base_address, RCAR_ETH_REG_CCC, ETH_CCC_OPC_MASK, ETH_CCC_OPC_OPERATION);
+
+	return 0;
+}
+
+/* Initialize E-MAC */
+static void eth_rcar_Emac_Init(const struct device * dev)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+
+	/* Receive frame limit set register */
+	eth_rcar_ravb_write(cfg->base_address, ETH_RX_BUF_SIZE, RCAR_ETH_REG_RFLR);
+
+	/* PAUSE prohibition */
+	eth_rcar_ravb_write(cfg->base_address, ETH_ECMR_DM_BIT | ETH_ECMR_TE_BIT | ETH_ECMR_RE_BIT, RCAR_ETH_REG_ECMR);
+
+	/* Set rate */
+	switch (cfg->speed)
+	{
+		case 100:		/* 100BASE */
+			eth_rcar_ravb_write(cfg->base_address, ETH_GECMR_SPEED_100_VALUE, RCAR_ETH_REG_GECMR);
+			break;
+		case 1000:		/* 1000BASE */
+			eth_rcar_ravb_write(cfg->base_address, ETH_GECMR_SPEED_1000_VALUE, RCAR_ETH_REG_GECMR);
+			break;
+		default:
+			/* When other value, default GECMR.SPEED = 0 (100 Mbps) */
+			LOG_ERR("[eth_rcar_Emac_Init] Wrong speed set %d\n", cfg->speed);
+			break;
+	}
+
+	/* Set MAC address */
+	eth_rcar_SetMacAddr(cfg->base_address, ctx->mac_addr);
+
+	/* E-MAC status register clear */
+	eth_rcar_ravb_write(cfg->base_address, 0x0000000u, RCAR_ETH_REG_ECSR);
+
+	/* E-MAC interrupt enable register */
+	eth_rcar_ravb_write(cfg->base_address, 0x0000000u, RCAR_ETH_REG_ECSIPR); /* Error detect/Magic packet off */
+}
+
+/* Clear interrupt status */
+static void eth_rcar_InterruptStatus_Init(uint32_t base_address)
+{
+	eth_rcar_ravb_write(base_address, 0u, RCAR_ETH_REG_DIS);
+	eth_rcar_ravb_write(base_address, 0u, RCAR_ETH_REG_EIS);
+	eth_rcar_ravb_write(base_address, 0u, RCAR_ETH_REG_RIS0);
+	eth_rcar_ravb_write(base_address, 0u, RCAR_ETH_REG_RIS1);
+	eth_rcar_ravb_write(base_address, 0u, RCAR_ETH_REG_RIS2);
+	eth_rcar_ravb_write(base_address, 0u, RCAR_ETH_REG_TIS);
+	eth_rcar_ravb_write(base_address, 0u, RCAR_ETH_REG_ISS);
+}
+
+/* Initialize PFC */
+static void eth_rcar_PFC_Init(const int avb_ch)
+{
+	uint32_t drv_data;
+
+	if (0 == avb_ch)
+	{
+		/* GPSR7:Set All 1 to [20:0] except AVB0_MAGIC */
+		drv_data = sys_read32(RCAR_PFC_REG_GPSR7);
+		drv_data = drv_data & ~RCAR_PFC_GPSR7_ETH_ENABLE_MASK;
+		drv_data = drv_data | RCAR_PFC_GPSR7_ETH_ENABLE;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_GPSR7));
+		sys_write32(drv_data, RCAR_PFC_REG_GPSR7);
+
+		/* IP0SR7:Set 0 to [31:0] */
+		drv_data = sys_read32(RCAR_PFC_REG_IP0SR7);
+		drv_data = drv_data & ~RCAR_PFC_IP0SR7_ETH_ENABLE_MASK;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_IP0SR7));
+		sys_write32(drv_data, RCAR_PFC_REG_IP0SR7);
+		/* IP1SR7:Set 0 to [31:0] */
+		drv_data = sys_read32(RCAR_PFC_REG_IP1SR7);
+		drv_data = drv_data & ~RCAR_PFC_IP1SR7_ETH_ENABLE_MASK;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_IP1SR7));
+		sys_write32(drv_data, RCAR_PFC_REG_IP1SR7);
+		/* IP2SR7:Set 0 to [19:0] */
+		drv_data = sys_read32(RCAR_PFC_REG_IP2SR7);
+		drv_data = drv_data & ~RCAR_PFC_IP2SR7_ETH_ENABLE_MASK;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_IP2SR7));
+		sys_write32(drv_data, RCAR_PFC_REG_IP2SR7);
+	}
+	else if (1 == avb_ch)
+	{
+		/* GPSR6:Set All 1 to [20:0] except AVB0_MAGIC */
+		drv_data = sys_read32(RCAR_PFC_REG_GPSR6);
+		drv_data = drv_data & ~RCAR_PFC_GPSR6_ETH_ENABLE_MASK;
+		drv_data = drv_data | RCAR_PFC_GPSR6_ETH_ENABLE;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_GPSR6));
+		sys_write32(drv_data, RCAR_PFC_REG_GPSR6);
+
+		/* IP0SR6:Set 0 to [31:0] */
+		drv_data = sys_read32(RCAR_PFC_REG_IP0SR6);
+		drv_data = drv_data & ~RCAR_PFC_IP0SR6_ETH_ENABLE_MASK;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_IP0SR6));
+		sys_write32(drv_data, RCAR_PFC_REG_IP0SR6);
+		/* IP1SR6:Set 0 to [31:0] */
+		drv_data = sys_read32(RCAR_PFC_REG_IP1SR6);
+		drv_data = drv_data & ~RCAR_PFC_IP1SR6_ETH_ENABLE_MASK;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_IP1SR6));
+		sys_write32(drv_data, RCAR_PFC_REG_IP1SR6);
+		/* IP2SR6:Set 0 to [19:0] */
+		drv_data = sys_read32(RCAR_PFC_REG_IP2SR6);
+		drv_data = drv_data & ~RCAR_PFC_IP2SR6_ETH_ENABLE_MASK;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_IP2SR6));
+		sys_write32(drv_data, RCAR_PFC_REG_IP2SR6);
+	}
+	else if (2 == avb_ch)
+	{
+		/* GPSR5:Set All 1 to [20:0] except AVB0_MAGIC */
+		drv_data = sys_read32(RCAR_PFC_REG_GPSR5);
+		drv_data = drv_data & ~RCAR_PFC_GPSR5_ETH_ENABLE_MASK;
+		drv_data = drv_data | RCAR_PFC_GPSR5_ETH_ENABLE;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_GPSR5));
+		sys_write32(drv_data, RCAR_PFC_REG_GPSR5);
+
+		/* IP0SR5:Set 0 to [31:0] */
+		drv_data = sys_read32(RCAR_PFC_REG_IP0SR5);
+		drv_data = drv_data & ~RCAR_PFC_IP0SR5_ETH_ENABLE_MASK;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_IP0SR5));
+		sys_write32(drv_data, RCAR_PFC_REG_IP0SR5);
+		/* IP1SR5:Set 0 to [31:0] */
+		drv_data = sys_read32(RCAR_PFC_REG_IP1SR5);
+		drv_data = drv_data & ~RCAR_PFC_IP1SR5_ETH_ENABLE_MASK;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_IP1SR5));
+		sys_write32(drv_data, RCAR_PFC_REG_IP1SR5);
+		/* IP2SR5:Set 0 to [19:0] */
+		drv_data = sys_read32(RCAR_PFC_REG_IP2SR5);
+		drv_data = drv_data & ~RCAR_PFC_IP2SR5_ETH_ENABLE_MASK;
+		sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_REG_IP2SR5));
+		sys_write32(drv_data, RCAR_PFC_REG_IP2SR5);
+	}
+	else
+	{
+		LOG_ERR("[eth_rcar_PFC_Init] Invalid channel [%d]\n", avb_ch);
+	}
+}
+
+/* Set MAC address for Ethernet AVB */
+static void eth_rcar_SetMacAddr(uint32_t base, uint8_t * addr)
+{
+	eth_rcar_ravb_write(base, (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | (addr[3]), RCAR_ETH_REG_MAHR);
+	eth_rcar_ravb_write(base, (addr[4] << 8) | (addr[5]), RCAR_ETH_REG_MALR);
+}
+
+/* Compare MAC address whether they are same value */
+static int eth_rcar_CompareMacAddr(volatile uint8_t * pSrcMac, uint8_t * pDstMac)
+{
+	int ret;
+	int i = 0;
+
+	while ((ETH_MACADDR_SIZE > i) && (pSrcMac[i] == pDstMac[i]))
+	{
+		i++;
+	}
+
+	if (ETH_MACADDR_SIZE == i)
+	{
+		/* Address matches */
+		ret = 0;
+	}
+	else
+	{
+		/* Address are different */
+		ret = -1;
+	}
+
+	return ret;
+}
+
+/* Check RX Frame whether it includes same MAC address of the board */
+static int eth_rcar_CheckRxFrame(uint8_t * mac_addr, uint32_t FrameAddr)
+{
+	int ret;
+	int isFrameAddrUnicast;
+	int isFrameAddrBroadcast;
+	/* Broadcast address */
+	const uint8_t Eth_BroadcastAddr[ETH_MACADDR_SIZE] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+
+	/* Compare MAC address to filter address */
+	isFrameAddrUnicast = eth_rcar_CompareMacAddr((uint8_t *)FrameAddr, mac_addr);
+	/* Compare MAC address to Broadcast address */
+	isFrameAddrBroadcast = eth_rcar_CompareMacAddr((uint8_t *)FrameAddr, (uint8_t *)Eth_BroadcastAddr);
+	if (0 == isFrameAddrUnicast)
+	{
+		ret = 0;
+	}
+	else if (0 == isFrameAddrBroadcast)
+	{
+		ret = -1;
+		LOG_DBG("[eth_rcar_CheckRxFrame] Broadcast received.");
+	}
+	else
+	{
+		ret = -1;
+		LOG_DBG("[eth_rcar_CheckRxFrame] Not valid frame received.");
+	}
+
+	return ret;
+}
+
+static int eth_rcar_RxNormalQueueProcess(struct eth_rcar_dev_data * ctx, int queue, Eth_RxSingleFrameType * RxFrame,
+										Eth_DataDescType * DataDesc)
+{
+	uint8_t * MultiBuff;
+	uint32_t NextFreeDataIdx = 0;
+	int ret = 0;
+	int bufIndex = 0;
+	uint32_t RxQueueStart;
+	uint32_t RxQueueEnd;
+	uint32_t CopyDataSize;
+
+	/* Get Start Descriptor Address for the corresponding Queue */
+	RxQueueStart = Eth_DescTable[ETH_TXQ_MAXNUM + queue].Dptr;
+
+	/* Get End Descriptor Address for the corresponding Queue */
+	RxQueueEnd = RxQueueStart + (ETH_NORMAL_DESC_SIZE * (ETH_RX_BUF_TOTAL - 1));
+
+	if (ETH_DESC_FSINGLE == (DataDesc->Header).Dt)
+	{
+		/* Descriptor type correct */
+		RxFrame->FrameAddr = DataDesc->Dptr;
+		RxFrame->FrameLength = (DataDesc->Header).Ds;
+	}
+	else if (ETH_DESC_FSTART == (DataDesc->Header).Dt)
+	{
+		/* Single frame multi buffer */
+		/* Get the multi buffer address of corresponding Queue */
+		MultiBuff = Eth_RxMultiBuffFrame[queue];
+		/* Assign address of the combined received frame */
+		RxFrame->FrameAddr = (uint32_t)(MultiBuff);
+		/* Get the size of buffer to be copied */
+		CopyDataSize = (DataDesc->Header).Ds;
+		if ((NextFreeDataIdx + CopyDataSize) > ETH_MAX_FRAME_SIZE)
+		{
+			/* Only copy the portion up to ETH_MAX_FRAME_SIZE */
+			CopyDataSize = ETH_MAX_FRAME_SIZE - NextFreeDataIdx;
+		}
+		/* Copy the START of received frame to combined frame */
+		/* Cast to be compatible with type of input parameter */
+		memcpy((MultiBuff + NextFreeDataIdx), (void *)DataDesc->Dptr, CopyDataSize);
+		/* Increase to the next free buffer index */
+		NextFreeDataIdx += CopyDataSize;
+		/* Cumulate the size */
+		RxFrame->FrameLength = CopyDataSize;
+
+		/* Start cumulating the size and combining frame until the end */
+		for (bufIndex = 1; bufIndex < ETH_RX_BUF_TOTAL; bufIndex++)
+		{
+			/* Increase to the next descriptor */
+			DataDesc++;
+			if (ETH_DESC_LINKFIX == (DataDesc->Header).Dt)
+			{
+				DataDesc = (Eth_DataDescType *)DataDesc->Dptr;
+			}
+			if (ETH_DESC_FMID == (DataDesc->Header).Dt)
+			{
+				/* Get the size of buffer to be copied */
+				CopyDataSize = (DataDesc->Header).Ds;
+				if ((NextFreeDataIdx + CopyDataSize) > ETH_MAX_FRAME_SIZE)
+				{
+					/* Only copy the portion up to ETH_MAX_FRAME_SIZE */
+					CopyDataSize = ETH_MAX_FRAME_SIZE - NextFreeDataIdx;
+				}
+				/* Copy the MID of received frame to combined frame */
+				/* Cast to be compatible with type of input parameter */
+				memcpy((MultiBuff + NextFreeDataIdx), (void *)DataDesc->Dptr, CopyDataSize);
+				/* Increase to the next free buffer index */
+				NextFreeDataIdx += CopyDataSize;
+				/* Cumulate the size */
+				RxFrame->FrameLength += CopyDataSize;
+				/* Reset descriptor to FEMPTY */
+				eth_rcar_Desc_Update(DataDesc);
+			}
+			else if (ETH_DESC_FEND == (DataDesc->Header).Dt)
+			{
+				/* End of frame */
+				/* Get the size of buffer to be copied */
+				CopyDataSize = (DataDesc->Header).Ds;
+				if ((NextFreeDataIdx + CopyDataSize) > ETH_MAX_FRAME_SIZE)
+				{
+					/* Only copy the portion up to ETH_MAX_FRAME_SIZE */
+					CopyDataSize = ETH_MAX_FRAME_SIZE - NextFreeDataIdx;
+				}
+				/* Copy the END of received frame to combined frame */
+				/* Cast to be compatible with type of input parameter */
+				memcpy((MultiBuff + NextFreeDataIdx), (void *)DataDesc->Dptr, CopyDataSize);
+				/* Cumulate the size */
+				RxFrame->FrameLength += CopyDataSize;
+				/* Reset descriptor to FEMPTY */
+				eth_rcar_Desc_Update(DataDesc);
+				break;
+			}
+			else
+			{
+				/* Invalid Descriptor type */
+				LOG_ERR("[eth_rcar_RxNormalQueueProcess] (DataDesc->Header).Dt is [%d], DataDesc is [0x%08X]\n",
+						(DataDesc->Header).Dt, (uint32_t)DataDesc);
+				ret = -1;
+				break;
+			}
+		}
+	}
+	else
+	{
+		/* Invalid Descriptor type */
+		LOG_ERR("[eth_rcar_RxNormalQueueProcess] (DataDesc->Header).Dt is [%d], DataDesc is [0x%08X]\n",
+				(DataDesc->Header).Dt, (uint32_t)DataDesc);
+		ret = -1;
+	}
+
+	if ((ETH_RX_BUF_TOTAL > bufIndex) && (0 == ret) &&
+		((uint32_t)DataDesc <= RxQueueEnd) && ((uint32_t)DataDesc >= RxQueueStart))
+	{
+		/* No error happened, increase to next descriptor */
+		DataDesc++;
+		if (ETH_DESC_LINKFIX == (DataDesc->Header).Dt)
+		{
+			DataDesc = (Eth_DataDescType *)DataDesc->Dptr;
+		}
+		if (((uint32_t)DataDesc > RxQueueEnd) || ((uint32_t)DataDesc < RxQueueStart))
+		{
+			/* Invalid Descriptor type */
+			LOG_ERR("[eth_rcar_RxNormalQueueProcess] DataDesc[0x%08X] is out of range from [0x%08X] to [0x%08X]\n",
+					(uint32_t)DataDesc, RxQueueStart, RxQueueEnd);
+			ret = -1;
+		}
+		else
+		{
+			ctx->rx_status[queue].descAddr = DataDesc;
+		}
+	}
+	else
+	{
+		/* Error happened in previous step */
+		LOG_ERR("[eth_rcar_RxNormalQueueProcess] error happened\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+/* Pass received data for upper layer */
+static void eth_rcar_PassReceivedData(struct eth_rcar_dev_data * ctx, Eth_RxSingleFrameType * RxFrame)
+{
+	struct net_pkt * rx_frame = NULL;
+	int ret;
+
+	/* Filter the received frame */
+	ret = eth_rcar_CheckRxFrame(ctx->mac_addr, RxFrame->FrameAddr);
+	if (ret == 0)
+	{
+		LOG_DBG("Received len %d\n", RxFrame->FrameLength);
+
+		/* Allocate room for full frame */
+		rx_frame = net_pkt_rx_alloc_with_buffer(ctx->iface, RxFrame->FrameLength, AF_UNSPEC, 0, ETH_NET_BUF_TIMEOUT);
+		if (rx_frame == NULL)
+		{
+			LOG_ERR("[eth_rcar_PassReceivedData] net_pkt_rx_alloc_with_buffer returns NULL\n");
+		}
+		else
+		{
+			/* Write data for upper layer */
+			ret = net_pkt_write(rx_frame, (void *)RxFrame->FrameAddr, RxFrame->FrameLength);
+			if (ret != 0)
+			{
+				net_pkt_unref(rx_frame);
+				LOG_ERR("[eth_rcar_PassReceivedData] net_pkt_write returns %d\n", ret);
+			}
+			else
+			{
+				/* All data for this frame received */
+				ret = net_recv_data(ctx->iface, rx_frame);
+				if (ret != 0)
+				{
+					LOG_ERR("[eth_rcar_PassReceivedData] net_recv_data returns %d\n", ret);
+					net_pkt_unref(rx_frame);
+				}
+			}
+		}
+	}
+}
+
+static void eth_rcar_Interrupt_rx(const struct device * dev, int queue)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+
+	uint32_t ris0 = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_RIS0);
+	uint32_t ric0 = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_RIC0);
+
+	if (((ris0 & ric0) & BIT(queue)) != 0)
+	{
+		/* Disable Frame Transmitted interrupt */
+		eth_rcar_ravb_write(cfg->base_address, BIT(queue), RCAR_ETH_REG_RID0);
+
+		/* Clear RX interrupt */
+		eth_rcar_ravb_modify(cfg->base_address, RCAR_ETH_REG_RIS0, BIT(queue), 0);
+
+		/* Semaphore give for receive */
+		k_sem_give(&ctx->rx_sem[queue]);
+
+		/* Re-enable RX interrupts */
+		eth_rcar_ravb_write(cfg->base_address, BIT(queue), RCAR_ETH_REG_RIE0);
+	}
+	else
+	{
+		LOG_ERR("[eth_rcar_Interrupt_rx] Invalid interrupt. RIS0=0x%08X, RIC0=0x%08X, queue=%d\n", ris0, ric0, queue);
+	}
+}
+
+static void eth_rcar_Interrupt_tx(const struct device * dev, int queue)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	Eth_DataDescType * DataDesc;
+
+	uint32_t tis = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_TIS);
+	uint32_t tic = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_TIC);
+
+	if ((tis & tic & BIT(queue)) != 0)
+	{
+		/* Disable Frame Transmitted interrupt */
+		eth_rcar_ravb_write(cfg->base_address, BIT(queue), RCAR_ETH_REG_TID);
+
+		/* Clear TX interrupt */
+		eth_rcar_ravb_modify(cfg->base_address, RCAR_ETH_REG_TIS, BIT(queue), 0);
+
+		/* Check the descriptor of corresponding buffer */
+		DataDesc = ctx->tx_status[queue].descAddr;
+		if (ETH_DESC_FEMPTY != DataDesc->Header.Dt)
+		{
+			LOG_ERR("[eth_rcar_Interrupt_tx] Bad descriptor DataDesc->Header.Dt=%d\n", DataDesc->Header.Dt);
+		}
+
+		/* Update TX status for internal */
+		ctx->tx_status[queue].is_using = false;
+
+		/* Re-enable TX interrupts */
+		eth_rcar_ravb_write(cfg->base_address, BIT(queue), RCAR_ETH_REG_TIE);
+	}
+	else
+	{
+		LOG_ERR("[eth_rcar_Interrupt_tx] Invalid interrupt. TIS=0x%08X, TIC=0x%08X, queue=%d\n", tis, tic, queue);
+	}
+}
+
+/* Interrupt handler for EthernetAVB.ch0 */
+static void eth_rcar_isr_rx_be(const struct device * dev)
+{
+	eth_rcar_Interrupt_rx(dev, RAVB_BE);
+}
+
+/* Interrupt handler for EthernetAVB.ch18 */
+static void eth_rcar_isr_tx_be(const struct device * dev)
+{
+	eth_rcar_Interrupt_tx(dev, RAVB_BE);
+}
+
+/* Interrupt handler for EthernetAVB.ch22 */
+static void eth_rcar_isr_err(const struct device * dev)
+{
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	uint32_t eis;
+	uint32_t eic;
+	uint32_t esr;
+	uint32_t ris2;
+	uint32_t ric2;
+	int i;
+	uint32_t qff_status;
+
+	/* Read EIS.QEF, EIC.QEE */
+	eis = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_EIS);
+	eic = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_EIC);
+	if ((eis & eic & ETH_EIS_QEF_BIT) != 0)
+	{
+		/* Clear EIS.QEF */
+		esr = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_ESR);
+		LOG_ERR("[eth_rcar_isr_err] Queue error is detected. ESR is 0x%08X\n", esr);
+		eth_rcar_ravb_write(cfg->base_address, ((~ETH_EIS_QEF_BIT) & ETH_EIS_INT_MASK), RCAR_ETH_REG_EIS);
+	}
+
+	/* Read RIS2.RFFF, RIC2.RFFE */
+	ris2 = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_RIS2);
+	ric2 = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_RIC2);
+	if ((ris2 & ric2 & ETH_RIS2_RFFF_BIT) != 0)
+	{
+		/* Clear RIS2.RFFF */
+		LOG_ERR("[eth_rcar_isr_err] Receive FIFO Full Interrupt is happen.\n");
+		eth_rcar_ravb_write(cfg->base_address, ((~ETH_RIS2_RFFF_BIT) & ETH_RIS2_QFF_MASK), RCAR_ETH_REG_RIS2);
+	}
+
+	/* Read RIS2.QFFx, RIC2.QFEx */
+	ris2 = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_RIS2);
+	ric2 = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_RIC2);
+	if ((ris2 & ric2 & ETH_RIS2_QFF_MASK) != 0)
+	{
+		for (i = 0; i < ETH_RXQ_MAXNUM; i++)
+		{
+			qff_status = (ris2 & (1 << i));
+			if ((qff_status != 0) && ((ric2 & (1 << i)) != 0))
+			{
+				/* Clear RIS2.QFFx */
+				LOG_ERR("[eth_rcar_isr_err] Receive Queue %d Full Interrupt is happen.\n", i);
+				qff_status = (~qff_status) & ETH_RIS2_QFF_MASK;
+				eth_rcar_ravb_write(cfg->base_address, (qff_status | ETH_RIS2_RFFF_BIT), RCAR_ETH_REG_RIS2);
+			}
+		}
+	}
+}
+
+/* Receive thread */
+static void eth_rcar_ReceiveThread(const struct device * dev)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	int ret;
+	uint32_t RxUnread;
+	Eth_DataDescType * DescAddr;
+	Eth_RxSingleFrameType RxFrame = {0u, 0u};
+	int queue = RAVB_BE; /* Currently supported only queue 0. When support more queue, need to update. */
+
+	while (1)
+	{
+		ret = k_sem_take(&ctx->rx_sem[queue], K_FOREVER); /* Wait interrupt */
+		if (ret == 0)
+		{
+			/* ---- Read start ---- */
+			/* Get Unread Frame Counter and continue to read until it becomes No Unread Frame */
+			RxUnread = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_UFCV0);
+			RxUnread = ((RxUnread >> ((queue % 4) * 8)) & ETH_UFCV_CV_MASK);
+			while (RxUnread > 0)
+			{
+				/* Decrement unread frame counter by 1 */
+				eth_rcar_ravb_write(cfg->base_address, (uint32_t)(1 << ((queue % 4) * 8)), RCAR_ETH_REG_UFCD0);
+
+				DescAddr = ctx->rx_status[queue].descAddr;
+				if (RAVB_BE == queue)
+				{
+					/* Best effort channel, Timestamp disabled */
+					ret = eth_rcar_RxNormalQueueProcess(ctx, queue, &RxFrame, DescAddr);
+				}
+				else
+				{
+					/* For other channel, currently not supported  */
+					LOG_ERR("[eth_rcar_ReceiveThread] Not supported queue [%d]\n", queue);
+					ret = -1;
+				}
+				if (ret == 0)
+				{
+					/* Check received data and pass it to upperlayer when the message is for this device */
+					eth_rcar_PassReceivedData(ctx, &RxFrame);
+
+					/* Update descriptor chain to FEmpty */
+					eth_rcar_Desc_Update(DescAddr);
+				}
+				else
+				{
+					LOG_ERR("[eth_rcar_ReceiveThread] Error in Queue Process [%d]\n", ret);
+				}
+				/* Get Unread Frame Counter */
+				RxUnread = eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_UFCV0);
+				RxUnread = ((RxUnread >> ((queue % 4) * 8)) & ETH_UFCV_CV_MASK);
+			}
+		}
+		else
+		{
+			LOG_ERR("[eth_rcar_ReceiveThread] k_sem_take err ret %d\n", ret);
+		}
+	}
+}
+
+/* Initialize API */
+static int eth_rcar_init(const struct device * dev)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	int ret;
+
+	if (cfg->clock_dev == NULL)
+	{
+		LOG_ERR("[eth_rcar_init] clock_dev is NULL.\n");
+		return -ENODEV;
+	}
+	/* Set module enable. In other words, disable Module Stop */
+	ret = clock_control_on(cfg->clock_dev, (clock_control_subsys_t *)&cfg->mod_clk);
+	if (ret < 0)
+	{
+		LOG_ERR("[eth_rcar_init] clock_control_on error [ret:%d]\n", ret);
+		return ret;
+	}
+
+	/* Register interrupt */
+	cfg->init_func(dev);
+
+	/* Initial PFC */
+	eth_rcar_PFC_Init(cfg->channel);
+
+	/* Set AVB config mode (CCC.OPC to Configuration Mode) */
+	eth_rcar_ravb_modify(cfg->base_address, RCAR_ETH_REG_CCC, ETH_CCC_OPC_MASK, ETH_CCC_OPC_CONFIG);
+
+	/* Print device information */
+	LOG_DBG("[eth_rcar_init] [dev->name:%s][if_name:%s][channel:%d][domain:%d, module:%d][base_address:0x%08X]\n",
+		dev->name, ctx->if_name, cfg->channel, cfg->mod_clk.domain, cfg->mod_clk.module, cfg->base_address);
+
+	return 0;
+}
+
+
+#if defined(CONFIG_THREAD_MAX_NAME_LEN)
+#define THREAD_MAX_NAME_LEN CONFIG_THREAD_MAX_NAME_LEN
+#else
+#define THREAD_MAX_NAME_LEN 1
+#endif
+
+/* Initialize specific interface API */
+static void eth_rcar_iface_init(struct net_if * iface)
+{
+	const struct device * dev = net_if_get_device(iface);
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	struct net_linkaddr * ll_addr;
+	int queue;
+	char name[THREAD_MAX_NAME_LEN];
+
+	ctx->ll_addr.addr = ctx->mac_addr;
+	ctx->ll_addr.len = sizeof(ctx->mac_addr);
+	ll_addr = &ctx->ll_addr;
+
+	/* The iface pointer in ctx should contain the main interface
+	 * if the VLANs are enabled.
+	 */
+	if (ctx->iface == NULL)
+	{
+		ctx->iface = iface;
+	}
+
+	ethernet_init(iface);
+
+	if (ctx->init_done)
+	{
+		LOG_ERR("[eth_rcar_iface_init] ctx->init_done:%d\n", ctx->init_done);
+		return;
+	}
+
+	net_lldp_set_lldpdu(iface);
+
+	ctx->init_done = true;
+
+	/* Set MAC address */
+	if (CONFIG_ETH_RCAR_MAC_ADDR[0] != 0)
+	{
+		if (net_bytes_from_str(ctx->mac_addr, sizeof(ctx->mac_addr), CONFIG_ETH_RCAR_MAC_ADDR) < 0)
+		{
+			LOG_ERR("Invalid MAC address %s", CONFIG_ETH_RCAR_MAC_ADDR);
+		}
+	}
+	eth_rcar_SetMacAddr(cfg->base_address, ctx->mac_addr);
+
+	/* If we have only one network interface, then use the name
+	 * defined in the Kconfig directly. This way there is no need to
+	 * change the documentation etc. and break things.
+	 */
+	if (CONFIG_ETH_RCAR_INTERFACE_COUNT == 1)
+	{
+		ctx->if_name = CONFIG_ETH_RCAR_DRV_NAME;
+	}
+
+	LOG_DBG("Interface %p using \"%s\"", iface, log_strdup(ctx->if_name));
+
+	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len, NET_LINK_ETHERNET);
+
+	/* Create semaphore for receive */
+	for (queue = 0; queue < NUM_RX_QUEUE; queue++)
+	{
+		k_sem_init(&ctx->rx_sem[queue], 0, ETH_RX_BUF_TOTAL);
+	}
+
+	/* Create receive thread */
+	k_thread_create(ctx->rx_thread,
+			cfg->rx_stack,
+			cfg->rx_stack_size,
+			(k_thread_entry_t)eth_rcar_ReceiveThread,
+			(void *)dev, NULL, NULL, K_PRIO_COOP(14),
+			0, K_NO_WAIT);
+
+	if (IS_ENABLED(CONFIG_THREAD_NAME))
+	{
+		snprintk(name, sizeof(name), "eth_rcar_rx-%s", ctx->if_name);
+		k_thread_name_set(ctx->rx_thread, name);
+	}
+}
+
+/* Start device API */
+static int eth_rcar_start_device(const struct device * dev)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	int ret;
+	int i;
+
+	ctx->status = true;
+
+	/* dmac init */
+	ret = eth_rcar_Dmac_Init(dev);
+	if (0 != ret)
+	{
+		LOG_ERR("[eth_rcar_start_device] eth_rcar_Dmac_Init error, ret:%d\n", ret);
+		return ret;
+	}
+
+	/* emac init */
+	eth_rcar_Emac_Init(dev);
+
+	/* Clear TX status */
+	for (i = 0; i < NUM_TX_QUEUE; i++)
+	{
+		ctx->tx_status[i].is_using = false;
+	}
+
+	return ret;
+}
+
+/* Stop device API */
+static int eth_rcar_stop_device(const struct device * dev)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+
+	ctx->status = false;
+
+	/* Disable TX and RX */
+	eth_rcar_ravb_modify(cfg->base_address, RCAR_ETH_REG_ECMR, ETH_ECMR_RE_BIT | ETH_ECMR_TE_BIT, 0);
+
+	/* Disable interrupt settings */
+	eth_rcar_ravb_write(cfg->base_address, 0u, RCAR_ETH_REG_CIE);		/* Disable Common Transmit/Receive Interrupt */
+	eth_rcar_ravb_write(cfg->base_address, ETH_EID_QED_BIT, RCAR_ETH_REG_EID);		/* Disable Queue Error interrupt */
+	eth_rcar_ravb_write(cfg->base_address, ETH_RID0_INT_MASK, RCAR_ETH_REG_RID0);	/* Disable all Receive interrupt */
+	eth_rcar_ravb_write(cfg->base_address, ETH_RID2_INT_MASK, RCAR_ETH_REG_RID2);	/* Disable all RX full interrupt */
+	eth_rcar_ravb_write(cfg->base_address, ETH_TID_INT_MASK, RCAR_ETH_REG_TID);		/* Disable all TX interrupt */
+
+	/* Initialize Ethernet AVB interrupt status */
+	eth_rcar_InterruptStatus_Init(cfg->base_address);
+
+	return 0;
+}
+
+/* Get the device capabilities API */
+static enum ethernet_hw_caps eth_rcar_get_capabilities(const struct device * dev)
+{
+	ARG_UNUSED(dev);
+	return ETHERNET_LINK_100BASE_T | ETHERNET_LINK_1000BASE_T;
+}
+
+/* Set specific hardware configuration API */
+static int eth_rcar_set_config(const struct device * dev,
+								enum ethernet_config_type type,
+								const struct ethernet_config * config)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	int ret = 0;
+
+	switch (type)
+	{
+		case ETHERNET_CONFIG_TYPE_MAC_ADDRESS:
+			memcpy(ctx->mac_addr, config->mac_address.addr, sizeof(ctx->mac_addr));
+			eth_rcar_SetMacAddr(cfg->base_address, ctx->mac_addr);
+			net_if_set_link_addr(ctx->iface, ctx->mac_addr, sizeof(ctx->mac_addr), NET_LINK_ETHERNET);
+			break;
+		default:
+			LOG_ERR("[eth_rcar_set_config] Not supported type:%d\n", type);
+			ret = -ENOTSUP;
+			break;
+	}
+
+	return ret;
+}
+
+/* Get specific hardware configuration API */
+static int eth_rcar_get_config(const struct device * dev,
+								enum ethernet_config_type type,
+								struct ethernet_config * config)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	int ret = 0;
+
+	switch (type)
+	{
+		case ETHERNET_CONFIG_TYPE_AUTO_NEG:
+			config->auto_negotiation = true;
+			break;
+		case ETHERNET_CONFIG_TYPE_LINK:
+			if (cfg->speed == 1000)
+			{
+				config->l.link_10bt = false;
+				config->l.link_100bt = false;
+				config->l.link_1000bt = true;
+			}
+			else
+			{
+				config->l.link_10bt = false;
+				config->l.link_100bt = true;
+				config->l.link_1000bt = false;
+			}
+			break;
+		case ETHERNET_CONFIG_TYPE_DUPLEX:
+			config->full_duplex = true;
+			break;
+		case ETHERNET_CONFIG_TYPE_MAC_ADDRESS:
+			memcpy(config->mac_address.addr, ctx->mac_addr, sizeof(ctx->mac_addr));
+			break;
+		case ETHERNET_CONFIG_TYPE_PROMISC_MODE:
+			config->promisc_mode = false;
+			break;
+		default:
+			LOG_ERR("[eth_rcar_get_config] Not supported type:%d\n", type);
+			ret = -ENOTSUP;
+			break;
+	}
+
+	return ret;
+}
+
+/* Send a network packet API */
+static int eth_rcar_send(const struct device * dev, struct net_pkt * pkt)
+{
+	struct eth_rcar_dev_data * ctx = dev->data;
+	const struct eth_rcar_dev_cfg * cfg = dev->config;
+	int count;
+	int ret = -EALREADY;
+	int queue;
+	volatile uint8_t * BufPtr;
+	const uint16_t FrameType = 0x806u; /* ETH_ARP_TYPE */
+	Eth_DataDescType * DataDesc;
+
+	/* Find empty queue */
+	for (queue = 0; queue < NUM_TX_QUEUE; queue++)
+	{
+		if (ctx->tx_status[queue].is_using == false)
+		{
+			ctx->tx_status[queue].is_using = true;
+			ret = 0;
+			break;
+		}
+	}
+	if (ret != 0)
+	{
+		LOG_ERR("[eth_rcar_send] error, currently sending status.\n");
+		return ret;
+	}
+
+	count = net_pkt_get_len(pkt);
+	if (count > ETH_TX_BUF_SIZE)
+	{
+		ctx->tx_status[queue].is_using = false;
+		ret = -ERANGE;
+		LOG_ERR("[eth_rcar_send] net_pkt_get_len size error [count:%d][ETH_TX_BUF_SIZE:%d]\n", count, ETH_TX_BUF_SIZE);
+		return ret;
+	}
+
+	/* Get data from upper layer */
+	ret = net_pkt_read(pkt, &Eth_TxBuff[0], count); /* Currently TX buffer is prepared one */
+	if (ret != 0)
+	{
+		ctx->tx_status[queue].is_using = false;
+		LOG_ERR("[eth_rcar_send] net_pkt_read error [ret:%d]\n", ret);
+		return ret;
+	}
+
+	LOG_DBG("Send pkt %p len %d", pkt, count);
+
+	BufPtr = (volatile uint8_t *)&Eth_TxBuff[12];
+	/* Cast from uint16 to Eth_DataType (uint8) to get higher bits */
+	*BufPtr = (uint8_t)((FrameType & 0xFF00u) >> 8u);
+	BufPtr++;
+	/* Cast from uint16 to Eth_DataType (uint8) to get lower bits */
+	*BufPtr = (uint8_t)(FrameType & 0x00FFu);
+
+	ret = eth_rcar_ravb_wait(cfg->base_address, RCAR_ETH_REG_TCCR, (1 << queue), 0);
+	if (ret != 0)
+	{
+		ctx->tx_status[queue].is_using = false;
+		LOG_ERR("[eth_rcar_send] eth_rcar_ravb_wait [ret:%d]\n", ret);
+		return ret;
+	}
+
+	DataDesc = (Eth_DataDescType *)eth_rcar_ravb_read(cfg->base_address, RCAR_ETH_REG_CDAR0 + (queue * 4));
+	if (DataDesc == NULL)
+	{
+		ctx->tx_status[queue].is_using = false;
+		LOG_ERR("[eth_rcar_send] eth_rcar_ravb_read CDAR is NULL\n");
+		return -1;
+	}
+
+	if (ETH_DESC_LINKFIX == (DataDesc->Header).Dt)
+	{
+		DataDesc = (Eth_DataDescType *)DataDesc->Dptr;
+	}
+
+	/* Build the descriptor */
+	DataDesc->Header.Dt		= ETH_DESC_FSINGLE;
+	DataDesc->Header.Die	= 0; /* Descriptor Interrupt is disabled */
+	DataDesc->Header.Ctrl	= 0; /* Currently buf index is only 1 */
+	DataDesc->Header.Ds		= count;
+	DataDesc->Dptr			= (uint32_t)&Eth_TxBuff[0];
+
+	/* End of Set */
+	DataDesc++;
+	if (ETH_DESC_LINKFIX == (DataDesc->Header).Dt)
+	{
+		DataDesc = (Eth_DataDescType *)DataDesc->Dptr;
+	}
+
+	DataDesc->Header.Dt		= ETH_DESC_EOS;
+	DataDesc->Header.Die	= 0; /* Descriptor Interrupt is disabled */
+	DataDesc->Header.Ctrl	= 0; /* Currently buf index is only 1 */
+	DataDesc->Header.Ds		= 0;
+	DataDesc->Dptr			= 0x00000000u;
+
+	/* Issue a request to start transmission for corresponding queue */
+	eth_rcar_ravb_modify(cfg->base_address, RCAR_ETH_REG_TCCR, ETH_TCCR_TSRQ_MASK, 1 << queue);
+
+	return 0;
+}
+
+static const struct ethernet_api eth_if_api = {
+	.iface_api.init = eth_rcar_iface_init,
+	.start = eth_rcar_start_device,
+	.stop = eth_rcar_stop_device,
+	.get_capabilities = eth_rcar_get_capabilities,
+	.set_config = eth_rcar_set_config,
+	.get_config = eth_rcar_get_config,
+	.send = eth_rcar_send,
+};
+
+#define CONFIG_ARCH_RCAR_RECOMMENDED_STACK_SIZE		1000
+#define DEFINE_RX_THREAD(x, _)								\
+	K_KERNEL_STACK_DEFINE(rx_thread_stack_##x,				\
+			      CONFIG_ARCH_RCAR_RECOMMENDED_STACK_SIZE);	\
+	static struct k_thread rx_thread_data_##x
+
+LISTIFY(CONFIG_ETH_RCAR_INTERFACE_COUNT, DEFINE_RX_THREAD, (;), _);
+
+#define ETH_RCAR_INIT(n)													\
+	static void eth_rcar_##n##_init(const struct device * dev);				\
+	static struct eth_rcar_dev_data eth_rcar_data_##n = {					\
+		.if_name = CONFIG_ETH_RCAR_DRV_NAME #n,								\
+		.rx_thread = &rx_thread_data_##n,									\
+	};																		\
+	static const struct eth_rcar_dev_cfg eth_rcar_cfg_##n = {				\
+		.rx_stack = rx_thread_stack_##n,									\
+		.rx_stack_size = K_KERNEL_STACK_SIZEOF(rx_thread_stack_##n),		\
+		.init_func = eth_rcar_##n##_init,									\
+		.base_address = DT_INST_REG_ADDR(n),								\
+		.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),					\
+		.mod_clk.module = DT_INST_CLOCKS_CELL_BY_IDX(n, 0, module),			\
+		.mod_clk.domain = DT_INST_CLOCKS_CELL_BY_IDX(n, 0, domain),			\
+		.channel = n,														\
+		.speed = CONFIG_ETH_RCAR_SPEED,										\
+	};																		\
+	ETH_NET_DEVICE_DT_INST_DEFINE(n, eth_rcar_init,							\
+		    NULL, &eth_rcar_data_##n, &eth_rcar_cfg_##n,					\
+		    CONFIG_ETH_INIT_PRIORITY, &eth_if_api, NET_ETH_MTU);			\
+	static void eth_rcar_##n##_init(const struct device * dev)				\
+	{																		\
+		IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 0, irq), DT_INST_IRQ(n, priority),\
+					eth_rcar_isr_rx_be, DEVICE_DT_INST_GET(n), 0);			\
+		IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 1, irq), DT_INST_IRQ(n, priority),\
+					eth_rcar_isr_tx_be, DEVICE_DT_INST_GET(n), 0);			\
+		IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 2, irq), DT_INST_IRQ(n, priority),\
+					eth_rcar_isr_err, DEVICE_DT_INST_GET(n), 0);			\
+		irq_enable(DT_INST_IRQ_BY_IDX(n, 0, irq));							\
+		irq_enable(DT_INST_IRQ_BY_IDX(n, 1, irq));							\
+		irq_enable(DT_INST_IRQ_BY_IDX(n, 2, irq));							\
+	}
+
+DT_INST_FOREACH_STATUS_OKAY(ETH_RCAR_INIT)
+
diff --git a/drivers/ethernet/phy/CMakeLists.txt b/drivers/ethernet/phy/CMakeLists.txt
index 2592f9d477..c6aac3e24a 100644
--- a/drivers/ethernet/phy/CMakeLists.txt
+++ b/drivers/ethernet/phy/CMakeLists.txt
@@ -1,3 +1,4 @@
 # SPDX-License-Identifier: Apache-2.0
 
 zephyr_library_sources_ifdef(CONFIG_PHY_GENERIC_MII	 phy_mii.c)
+zephyr_library_sources_ifdef(CONFIG_PHY_GENERIC_RCAR	phy_rcar.c)
diff --git a/drivers/ethernet/phy/Kconfig b/drivers/ethernet/phy/Kconfig
index 070bd8960c..5031a7079e 100644
--- a/drivers/ethernet/phy/Kconfig
+++ b/drivers/ethernet/phy/Kconfig
@@ -1,6 +1,7 @@
 # Ethernet PHY drivers configuration options
 
 # Copyright (c) 2021 IP-Logix Inc.
+# Copyright (c) 2022 Renesas Electronics Corporation
 # SPDX-License-Identifier: Apache-2.0
 
 menu "Ethernet PHY Drivers"
@@ -44,4 +45,10 @@ config PHY_MONITOR_PERIOD
 	  periodically executed to detect and report any changes in the
 	  PHY link status to the operating system.
 
+config PHY_GENERIC_RCAR
+	bool "Generic RCAR PHY Driver"
+	default y if ETH_RCAR
+	help
+	  Enable support for Renesas RCar ETH PHY driver.
+
 endmenu # "Ethernet PHY Drivers"
diff --git a/drivers/ethernet/phy/phy_rcar.c b/drivers/ethernet/phy/phy_rcar.c
new file mode 100644
index 0000000000..38f19bb879
--- /dev/null
+++ b/drivers/ethernet/phy/phy_rcar.c
@@ -0,0 +1,511 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT ethernet_phy_rcar
+
+#include <errno.h>
+#include <zephyr/device.h>
+#include <zephyr/init.h>
+#include <soc.h>
+#include <zephyr/net/phy.h>
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(phy_rcar, CONFIG_PHY_LOG_LEVEL);
+
+struct phy_rcar_dev_config {
+	uint32_t base_address;	/* Base address of EthernetAVB */
+	int channel;			/* Channel number of EthernetAVB */
+	uint8_t phy_addr;		/* PHY address */
+};
+
+/****************************************************************/
+/* R-Car ETH Register                                           */
+/****************************************************************/
+#define RCAR_ETH_REG_PIR			(0x0520u)	/* PHY Interface Register (PIR) */
+
+/****************************************************************/
+/* Value of R-Car ETH Register                                  */
+/****************************************************************/
+#define RCAR_ETH_PIR_MDC_BIT		BIT(0)		/* PIR MDC mask */
+#define RCAR_ETH_PIR_MMD_BIT		BIT(1)		/* PIR MMD mask */
+#define RCAR_ETH_PIR_MDO_BIT		BIT(2)		/* PIR MDO mask */
+#define RCAR_ETH_PIR_MDI_BIT		BIT(3)		/* PIR MDI mask */
+#define RCAR_ETH_PIR_CLEAR			0x00000000u	/* PIR All 0 */
+
+/****************************************************************/
+/* KSZ9031RNX Standard Register                                 */
+/****************************************************************/
+#define PHY_REG_CTRL				0x00u		/* Basic Control */
+#define PHY_REG_STAT				0x01u		/* Basic Status */
+#define PHY_REG_1000T_CTRL			0x09u		/* 1000BASE-T Control */
+#define PHY_REG_MMD_ACCESS_CTRL		0x0Du		/* MMD Access Control */
+#define PHY_REG_MMD_ACCESS_DATA		0x0Eu		/* MMD Access Register/Data */
+
+/****************************************************************/
+/* Value of KSZ9031RNX Standard Register                        */
+/****************************************************************/
+/* For Basic Control */
+#define PHY_CTRL_AUTO_NEGOTIATION_DISABLE	0x0000u	/* Basic Control[12] = b'0 : Disable auto-negotiation process */
+#define PHY_CTRL_AUTO_NEGOTIATION_RESTART	(BIT(12) | BIT(9) | BIT(8))
+/* Basic Control[12] = b'1 : Enable auto-negotiation process */
+/* Basic Control[9]  = b'1 : Restart auto-negotiation process  */
+/* Basic Control[8]  = b'1 : Full-duplex */
+
+/* For Basic Status */
+#define PHY_STAT_AUTO_NEGOTIATION_ACTIVE	(BIT(5) | BIT(3))
+/* Basic Status[5] = b'1 : Auto-negotiation process completed */
+/* Basic Status[3] = b'1 : Can perform auto-negotiation */
+#define PHY_STAT_LINK_UP					BIT(2)	/* Basic Status[2] = b'1 : Link is up */
+
+/* For 1000BASE-T Control */
+#define PHY_1000T_CTRL_NOT_1000BASE			0x0000u
+/* 1000BASE-T Control[9] = b'0 : Advertise PHY is not 1000BASE-T full-duplex capable */
+/* 1000BASE-T Control[8] = b'0 : Advertise PHY is not 1000BASE-T half-duplex capable */
+#define PHY_1000T_CTRL_1000BASE				BIT(9)
+/* 1000BASE-T Control[9] = b'1 : Advertise PHY is 1000BASE-T full-duplex capable */
+/* 1000BASE-T Control[8] = b'0 : Advertise PHY is not 1000BASE-T half-duplex capable */
+
+/* For MMD Access Control */
+#define PHY_MMD_CTRL_MODE_REGISTER			0x0000u	/* MMD Access Control[15:14] = b'00 : Register */
+#define PHY_MMD_CTRL_MODE_DATA_NO_POST_INC	0x4000u	/* MMD Access Control[15:14] = b'01 : Data, no post increment */
+
+/****************************************************************/
+/* R-Car PFC (Pin Function Controller) Register and Value       */
+/****************************************************************/
+/* for AVB0 */
+#define RCAR_PFC_REG_OUTDT7			0xE6061988u	/* GPIO output register PortGroup 7 */
+#define RCAR_PFC_OUTDT7_PHY_RESET	BIT(10)		/* bit 10 for GPIO */
+/* for AVB1 */
+#define RCAR_PFC_REG_OUTDT6			0xE6061188u	/* GPIO output register PortGroup 6 */
+#define RCAR_PFC_OUTDT6_PHY_RESET	BIT(1)		/* bit 1 for GPIO */
+/* for AVB2 */
+#define RCAR_PFC_REG_OUTDT5			0xE6060988u	/* GPIO output register PortGroup 5 */
+#define RCAR_PFC_OUTDT5_PHY_RESET	BIT(5)		/* bit 5 for GPIO */
+
+/****************************************************************/
+/* Value for Parameter Check                                    */
+/****************************************************************/
+#define MIN_AVB_CHANNEL			0
+#define MAX_AVB_CHANNEL			2
+#define MIN_PHY_ADDRESS			0
+#define MAX_PHY_ADDRESS			0x1F
+#define MAX_REG_ADDRESS			0x1F
+#define MAX_REG_DATA			0xFFFF
+
+/****************************************************************/
+/* Global Data                                                  */
+/****************************************************************/
+#define PHY_RESET_DELAY			10u	/* PHY reset time (ms) */
+#define PHY_MDC_DELAY			8u	/* PHY wait time (us) */
+#define PHY_LINKUP_TIMEOUT		15u	/* Retry times for confirm link-up */
+
+/****************************************************************/
+/* Function Prototypes                                          */
+/****************************************************************/
+static void phy_rcar_PhyReset(const struct device * dev);
+static void phy_rcar_PhyWrite_OneBit(uint8_t WriteData, uint32_t base_address);
+static void phy_rcar_MIIFrameHeaderSet(uint8_t PhyAddr, uint8_t RegAddr, bool isWrite, uint32_t base_address);
+static void phy_rcar_WriteMii(uint8_t RegAddr, uint16_t RegValue, const struct device * dev);
+static void phy_rcar_ReadMii(uint8_t RegAddr, uint16_t * const RegValue, const struct device * dev);
+static int phy_rcar_RGMIIClockPadSkew(const struct device * dev);
+static int phy_rcar_initialize(const struct device * dev);
+static int phy_rcar_get_link_state(const struct device * dev, struct phy_link_state * state);
+static int phy_rcar_cfg_link(const struct device * dev, enum phy_link_speed adv_speeds);
+static int phy_rcar_link_cb_set(const struct device * dev, phy_callback_t cb, void * user_data);
+static int phy_rcar_read(const struct device * dev, uint16_t reg_addr, uint32_t * data);
+static int phy_rcar_write(const struct device * dev, uint16_t reg_addr, uint32_t data);
+
+/****************************************************************/
+/* Function Definitions                                         */
+/****************************************************************/
+
+/* Reset ETH external PHY */
+static void phy_rcar_PhyReset(const struct device * dev)
+{
+	const struct phy_rcar_dev_config * const cfg = dev->config;
+	int ch = cfg->channel;
+	uint32_t drv_data;
+	uint32_t reg;
+	uint32_t mask;
+
+	if (0 == ch)
+	{
+		/* Set for GP7_10 */
+		reg = RCAR_PFC_REG_OUTDT7;
+		mask = RCAR_PFC_OUTDT7_PHY_RESET;
+	}
+	else if (1 == ch)
+	{
+		/* Set for GP6_1 */
+		reg = RCAR_PFC_REG_OUTDT6;
+		mask = RCAR_PFC_OUTDT6_PHY_RESET;
+	}
+	else if (2 == ch)
+	{
+		/* Set for GP5_5 */
+		reg = RCAR_PFC_REG_OUTDT5;
+		mask = RCAR_PFC_OUTDT5_PHY_RESET;
+	}
+	else
+	{
+		LOG_ERR("[phy_rcar_PhyReset] Bad channel [%d]\n", ch);
+		return;
+	}
+
+	drv_data = sys_read32(reg);
+	drv_data &= ~mask;
+	sys_write32(drv_data, reg);
+
+	/* Delay for stabling supply voltages to de-assertion of reset */
+	k_sleep(K_MSEC(PHY_RESET_DELAY));
+
+	drv_data = sys_read32(reg);
+	drv_data |= mask;
+	sys_write32(drv_data, reg);
+}
+
+/* Write one bit data for PHY */
+static void phy_rcar_PhyWrite_OneBit(uint8_t WriteData, uint32_t base_address)
+{
+	uint32_t write_data = (WriteData == 1u) ? RCAR_ETH_PIR_MDO_BIT : 0u;
+
+	/* MMD = 1, MDO = WriteData, MDC = 0 */
+	sys_write32((write_data | RCAR_ETH_PIR_MMD_BIT), base_address + RCAR_ETH_REG_PIR);
+	/* MMD = 1, MDO = WriteData, MDC = 1 */
+	sys_write32((write_data | RCAR_ETH_PIR_MMD_BIT | RCAR_ETH_PIR_MDC_BIT), base_address + RCAR_ETH_REG_PIR);
+	/* MDC Pulse Delay */
+	k_sleep(K_USEC(PHY_MDC_DELAY));
+	/* MMD = 1, MDO = WriteData, MDC = 0 */
+	sys_write32((write_data | RCAR_ETH_PIR_MMD_BIT), base_address + RCAR_ETH_REG_PIR);
+	/* MDC Pulse Delay */
+	k_sleep(K_USEC(PHY_MDC_DELAY));
+}
+
+/* Write MII Management Frame Header for PHY */
+static void phy_rcar_MIIFrameHeaderSet(uint8_t PhyAddr, uint8_t RegAddr, bool isWrite, uint32_t base_address)
+{
+	int i;
+	uint16_t data = 0u; /* ST + OP = data[15:12], PHYAD = data[11:7], REGAD = data[6:2] */
+
+	if (true == isWrite)
+	{
+		/* ST + OP = b'0101 (Write) */
+		data = BIT(14) | BIT(12);
+	}
+	else
+	{
+		/* ST + OP = b'0110 (Read) */
+		data = BIT(14) | BIT(13);
+	}
+
+	/* Phy address (5 bit) */
+	data |= (PhyAddr << 7u);
+
+	/* Register address (5 bit) */
+	data |= (RegAddr << 2u);
+
+	/* Write preamble (32 bit) */
+	for (i = 32; i >= 0; i--)
+	{
+		phy_rcar_PhyWrite_OneBit(1u, base_address); /* Write 1 */
+	}
+
+	/* Write data[15:2] for ST, OP, PHYAD, REGAD */
+	for (i = 15; i >= 2; i--)
+	{
+		phy_rcar_PhyWrite_OneBit((data & BIT(i)) >> i, base_address); /* Write 0 or 1 */
+	}
+}
+
+/* Write data for PHY register */
+static void phy_rcar_WriteMii(uint8_t RegAddr, uint16_t RegValue, const struct device * dev)
+{
+	const struct phy_rcar_dev_config * const cfg = dev->config;
+	uint32_t base_address = cfg->base_address;
+	int i;
+
+	/* Parameter check for REGAD */
+	if (MAX_REG_ADDRESS < RegAddr)
+	{
+		LOG_ERR("[phy_rcar_WriteMii] Bad register address [0x%02X]\n", RegAddr);
+	}
+
+	/* Frame header (ST + OP + PHYAD + REGAD) */
+	phy_rcar_MIIFrameHeaderSet(cfg->phy_addr, RegAddr, true, base_address);
+
+	/* TA = b'10 */
+	phy_rcar_PhyWrite_OneBit(1u, base_address); /* Write 1 */
+	phy_rcar_PhyWrite_OneBit(0u, base_address); /* Write 0 */
+
+	/* Write DATA for PHY chip (16 bit) */
+	for (i = 15; i >= 0; i--)
+	{
+		phy_rcar_PhyWrite_OneBit((RegValue & BIT(i)) >> i, base_address); /* Write 0 or 1 */
+	}
+
+	/* Independent bus release */
+	sys_write32(RCAR_ETH_PIR_CLEAR, base_address + RCAR_ETH_REG_PIR);
+}
+
+/* Read data from PHY register */
+static void phy_rcar_ReadMii(uint8_t RegAddr, uint16_t * const RegValue, const struct device * dev)
+{
+	const struct phy_rcar_dev_config * const cfg = dev->config;
+	uint32_t base_address = cfg->base_address;
+	int i;
+	uint16_t readValue;
+
+	/* Parameter check for REGAD */
+	if (MAX_REG_ADDRESS < RegAddr)
+	{
+		LOG_ERR("[phy_rcar_ReadMii] Bad register address [0x%02X]\n", RegAddr);
+	}
+
+	/* frame header (ST + OP + PHYAD + REGAD) */
+	phy_rcar_MIIFrameHeaderSet(cfg->phy_addr, RegAddr, false, base_address);
+
+	/* TA (Bus release performed) */
+	/* MMD = 0, MDC = 0 */
+	sys_write32(RCAR_ETH_PIR_CLEAR, base_address + RCAR_ETH_REG_PIR);
+	/* MMD = 0, MDC = 1 */
+	sys_write32(RCAR_ETH_PIR_MDC_BIT, base_address + RCAR_ETH_REG_PIR);
+	/* MDC Pulse Delay */
+	k_sleep(K_USEC(PHY_MDC_DELAY));
+	/* MMD = 0, MDC = 0 */
+	sys_write32(RCAR_ETH_PIR_CLEAR, base_address + RCAR_ETH_REG_PIR);
+	/* MDC Pulse Delay */
+	k_sleep(K_USEC(PHY_MDC_DELAY));
+
+	/* Read DATA from PHY chip (16 bit) */
+	readValue = 0u;
+	for (i = 0; i < 16; i++)
+	{
+		/* MMD = 0, MDC = 1 */
+		sys_write32(RCAR_ETH_PIR_MDC_BIT, base_address + RCAR_ETH_REG_PIR);
+		/* MDC Pulse Delay */
+		k_sleep(K_USEC(PHY_MDC_DELAY));
+		/* MMD = 0, MDC = 0 */
+		sys_write32(RCAR_ETH_PIR_CLEAR, base_address + RCAR_ETH_REG_PIR);
+		/* Read MDI */
+		readValue <<= 1u;
+		readValue |= (uint16_t)((sys_read32(base_address + RCAR_ETH_REG_PIR) & RCAR_ETH_PIR_MDI_BIT) >> 3u);
+		/* MDC Pulse Delay */
+		k_sleep(K_USEC(PHY_MDC_DELAY));
+	}
+	*RegValue = readValue;
+}
+
+/* Set RGMII RX_CLK output pad skew control */
+static int phy_rcar_RGMIIClockPadSkew(const struct device * dev)
+{
+	uint16_t readValue;						/* read data */
+	uint16_t mode;							/* MMD - Operation Mode */
+	const uint16_t devAddr		= 0x0002u;	/* MMD Device Address = 2h */
+	const uint16_t regAddr		= 0x0008u;	/* MMD Register Address = 8h (RGMII Clock Pad Skew) */
+	const uint16_t writeValue	= (0x0fu << 5u) | 0x19u; /* GTX_CLK input: NoDalay, RX_CLK output: +0.60ns */
+
+	/* Select MMD device address */
+	mode = PHY_MMD_CTRL_MODE_REGISTER;
+	phy_rcar_WriteMii(PHY_REG_MMD_ACCESS_CTRL, (mode | devAddr), dev);
+	phy_rcar_ReadMii(PHY_REG_MMD_ACCESS_CTRL, &readValue, dev);
+	if (readValue != (mode | devAddr))
+	{
+		LOG_ERR("[phy_rcar_RGMIIClockPadSkew] readValue=0x%04X, (mode|devAddr)=0x%04X\n", readValue, (mode | devAddr));
+		return -1;
+	}
+	/* Select MMD register address */
+	phy_rcar_WriteMii(PHY_REG_MMD_ACCESS_DATA, regAddr, dev);
+	phy_rcar_ReadMii(PHY_REG_MMD_ACCESS_DATA, &readValue, dev);
+	if (readValue != regAddr)
+	{
+		LOG_ERR("[phy_rcar_RGMIIClockPadSkew] readValue=0x%04X, regAddr=0x%04X\n", readValue, regAddr);
+		return -1;
+	}
+	/* Select MMD operation mode */
+	mode = PHY_MMD_CTRL_MODE_DATA_NO_POST_INC;
+	phy_rcar_WriteMii(PHY_REG_MMD_ACCESS_CTRL, (mode | devAddr), dev);
+	phy_rcar_ReadMii(PHY_REG_MMD_ACCESS_CTRL, &readValue, dev);
+	if (readValue != (mode | devAddr))
+	{
+		LOG_ERR("[phy_rcar_RGMIIClockPadSkew] readValue=0x%04X, (mode|devAddr)=0x%04X\n", readValue, (mode | devAddr));
+		return -1;
+	}
+	/* Write the value */
+	phy_rcar_WriteMii(PHY_REG_MMD_ACCESS_DATA, writeValue, dev);
+	phy_rcar_ReadMii(PHY_REG_MMD_ACCESS_DATA, &readValue, dev);
+	if (readValue != writeValue)
+	{
+		LOG_ERR("[phy_rcar_RGMIIClockPadSkew] readValue=0x%04X, writeValue=0x%04X\n", readValue, writeValue);
+		return -1;
+	}
+
+	return 0;
+}
+
+/* PHY driver initialize */
+static int phy_rcar_initialize(const struct device * dev)
+{
+	const struct phy_rcar_dev_config * const cfg = dev->config;
+	int ret;
+	uint16_t readValue = 0u;
+	uint32_t delayCounter = 0u;
+
+	/* Parameter check for channel */
+	if ((cfg->channel < MIN_AVB_CHANNEL) || (MAX_AVB_CHANNEL < cfg->channel))
+	{
+		LOG_ERR("[phy_rcar_initialize] Bad EthernetAVB channel in device tree [channel:%d]\n", cfg->channel);
+	}
+
+	/* Parameter check for phy_addr */
+	if ((cfg->phy_addr < MIN_PHY_ADDRESS) || (MAX_PHY_ADDRESS < cfg->phy_addr))
+	{
+		LOG_ERR("[phy_rcar_initialize] Bad PHY address in device tree [address:%d]\n", cfg->phy_addr);
+	}
+
+	/* Reset PHY */
+	phy_rcar_PhyReset(dev);
+
+	/* Set RGMII RX_CLK output pad skew control */
+	ret = phy_rcar_RGMIIClockPadSkew(dev);
+	if (ret != 0)
+	{
+		LOG_ERR("[phy_rcar_initialize] phy_rcar_RGMIIClockPadSkew error [%d]\n", ret);
+		return ret;
+	}
+
+	if (CONFIG_ETH_RCAR_SPEED == 1000)
+	{
+		/* Setting PHY to auto-negotiate 1000 Mbps */
+		/* Remove auto-negotiation advertisement for 1000Mbps full/half duplex  */
+		phy_rcar_WriteMii(PHY_REG_1000T_CTRL, PHY_1000T_CTRL_1000BASE, dev);
+	}
+	else
+	{
+		/* Setting PHY to auto-negotiate 100 Mbps */
+		/* Disable auto-negotiation process */
+		phy_rcar_WriteMii(PHY_REG_CTRL, PHY_CTRL_AUTO_NEGOTIATION_DISABLE, dev);
+		/* Remove auto-negotiation advertisement for 1000Mbps full/half duplex  */
+		phy_rcar_WriteMii(PHY_REG_1000T_CTRL, PHY_1000T_CTRL_NOT_1000BASE, dev);
+	}
+
+	/* Enable & Restart auto-negotiation process */
+	phy_rcar_WriteMii(PHY_REG_CTRL, PHY_CTRL_AUTO_NEGOTIATION_RESTART, dev);
+
+	/* Check whether the Link is Up */
+	while (delayCounter < PHY_LINKUP_TIMEOUT)
+	{
+		delayCounter++;
+		/* Check the Phy interface is Initialized */
+		phy_rcar_ReadMii(PHY_REG_STAT, &readValue, dev);
+
+		if (((readValue & PHY_STAT_AUTO_NEGOTIATION_ACTIVE) == PHY_STAT_AUTO_NEGOTIATION_ACTIVE) &&
+			((readValue & PHY_STAT_LINK_UP) == PHY_STAT_LINK_UP))
+		{
+			LOG_DBG("[phy_rcar_initialize] success link up\n");
+			break;
+		}
+	}
+	if (delayCounter == PHY_LINKUP_TIMEOUT)
+	{
+		LOG_ERR("[phy_rcar_initialize] link up failed\n");
+	}
+
+	return 0;
+}
+
+/* Get link state (Not supported) */
+static int phy_rcar_get_link_state(const struct device * dev, struct phy_link_state * state)
+{
+	LOG_ERR("[phy_rcar_get_link_state] Not supported this function.");
+	return 0;
+}
+
+/* Configure link (Not supported) */
+static int phy_rcar_cfg_link(const struct device * dev, enum phy_link_speed adv_speeds)
+{
+	LOG_ERR("[phy_rcar_cfg_link] Not supported this function.");
+	return 0;
+}
+
+/* Set callback to be invoked when link state changes (Not supported) */
+static int phy_rcar_link_cb_set(const struct device * dev, phy_callback_t cb, void * user_data)
+{
+	LOG_ERR("[phy_rcar_link_cb_set] Not supported this function.");
+	return 0;
+}
+
+/* Read PHY register */
+static int phy_rcar_read(const struct device * dev, uint16_t reg_addr, uint32_t * data)
+{
+	int ret = 0;
+	uint16_t read_data;
+
+	/* Parameter check for REGAD */
+	if (MAX_REG_ADDRESS < reg_addr)
+	{
+		LOG_ERR("[phy_rcar_read] Bad register address [reg_addr:0x%04X]\n", reg_addr);
+		ret = -EIO;
+	}
+	else
+	{
+		/* Read data */
+		phy_rcar_ReadMii((uint8_t)reg_addr, &read_data, dev);
+		*data = (uint32_t)read_data;
+	}
+	return ret;
+}
+
+/* Write PHY register */
+static int phy_rcar_write(const struct device * dev, uint16_t reg_addr, uint32_t data)
+{
+	int ret = 0;
+
+	/* Parameter check for REGAD */
+	if (MAX_REG_ADDRESS < reg_addr)
+	{
+		LOG_ERR("[phy_rcar_write] Bad register address [reg_addr:0x%04X]\n", reg_addr);
+		ret = -EIO;
+	}
+	else if (MAX_REG_DATA < data)
+	{
+		LOG_ERR("[phy_rcar_write] Bad data [data:0x%08X]\n", data);
+		ret = -EIO;
+	}
+	else
+	{
+		/* write data */
+		phy_rcar_WriteMii((uint8_t)reg_addr, (uint16_t)data, dev);
+	}
+	return ret;
+}
+
+static const struct ethphy_driver_api phy_rcar_driver_api = {
+	.get_link = phy_rcar_get_link_state,
+	.cfg_link = phy_rcar_cfg_link,
+	.link_cb_set = phy_rcar_link_cb_set,
+	.read = phy_rcar_read,
+	.write = phy_rcar_write,
+};
+
+#define PHY_RCAR_CONFIG(n)											\
+static const struct phy_rcar_dev_config phy_rcar_dev_config_##n = {	\
+	.base_address = DT_INST_PROP(n, base_reg),						\
+	.channel = DT_INST_PROP(n, channel),							\
+	.phy_addr = DT_INST_PROP(n, address),							\
+};
+
+#define PHY_RCAR_DEVICE(n)					\
+	PHY_RCAR_CONFIG(n);						\
+	DEVICE_DT_INST_DEFINE(n,				\
+				&phy_rcar_initialize,		\
+				NULL,						\
+				NULL,						\
+				&phy_rcar_dev_config_##n,	\
+				POST_KERNEL,				\
+				CONFIG_PHY_INIT_PRIORITY,	\
+				&phy_rcar_driver_api);
+
+DT_INST_FOREACH_STATUS_OKAY(PHY_RCAR_DEVICE)
diff --git a/drivers/i2c/Kconfig.rcar b/drivers/i2c/Kconfig.rcar
index e997306483..3d6d5dfd6f 100644
--- a/drivers/i2c/Kconfig.rcar
+++ b/drivers/i2c/Kconfig.rcar
@@ -1,13 +1,14 @@
 # Renesas R-Car Gen3 I2C configuration options
 
 # Copyright (c) 2021 IoT.bzh
+# Copyright (c) 2022 Renesas Electronics Corporation
 # SPDX-License-Identifier: Apache-2.0
 
 DT_COMPAT_RENESAS_RCAR_I2C := renesas,rcar-i2c
 
 config I2C_RCAR
 	bool "Renesas R-Car I2C Driver"
-	depends on SOC_FAMILY_RCAR
+	depends on SOC_FAMILY_RCAR  || SOC_SERIES_RCAR_GEN4
 	default $(dt_compat_enabled,$(DT_COMPAT_RENESAS_RCAR_I2C))
 	help
 	  Enable Renesas R-Car I2C Driver.
diff --git a/drivers/i2c/i2c_common.c b/drivers/i2c/i2c_common.c
index 765285d80b..70981668e1 100644
--- a/drivers/i2c/i2c_common.c
+++ b/drivers/i2c/i2c_common.c
@@ -12,19 +12,21 @@
 
 #define LOG_LEVEL CONFIG_I2C_LOG_LEVEL
 #include <zephyr/logging/log.h>
-LOG_MODULE_REGISTER(i2c);
+LOG_MODULE_REGISTER(i2c, LOG_LEVEL);
 
 void i2c_dump_msgs(const char *name, const struct i2c_msg *msgs,
 		   uint8_t num_msgs, uint16_t addr)
 {
-	LOG_DBG("I2C msg: %s, addr=%x", name, addr);
-	for (unsigned int i = 0; i < num_msgs; i++) {
-		const struct i2c_msg *msg = &msgs[i];
+	if (msgs != NULL) {
+		LOG_DBG("I2C msg: %s, addr=%x", name, addr);
+		for (unsigned int i = 0; i < num_msgs; i++) {
+			const struct i2c_msg *msg = &msgs[i];
 
-		LOG_DBG("   %c len=%02x: ",
-			msg->flags & I2C_MSG_READ ? 'R' : 'W', msg->len);
-		if (!(msg->flags & I2C_MSG_READ)) {
-			LOG_HEXDUMP_DBG(msg->buf, msg->len, "contents:");
+			LOG_DBG("   %c len=%02x: ",
+				msg->flags & I2C_MSG_READ ? 'R' : 'W', msg->len);
+			if (!(msg->flags & I2C_MSG_READ)) {
+				LOG_HEXDUMP_DBG(msg->buf, msg->len, "contents:");
+			}
 		}
 	}
 }
diff --git a/drivers/i2c/i2c_rcar.c b/drivers/i2c/i2c_rcar.c
index b41a627bbd..84f7e2237b 100644
--- a/drivers/i2c/i2c_rcar.c
+++ b/drivers/i2c/i2c_rcar.c
@@ -13,13 +13,14 @@
 #include <zephyr/drivers/i2c.h>
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/clock_control/rcar_clock_control.h>
+#include <zephyr/sys/sys_io.h>
 
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(i2c_rcar);
 
 #include "i2c-priv.h"
 
-typedef void (*init_func_t)(const struct device *dev);
+typedef void (*init_func_t)(const struct device * dev);
 
 struct i2c_rcar_cfg {
 	uint32_t reg_addr;
@@ -35,171 +36,212 @@ struct i2c_rcar_data {
 };
 
 /* Registers */
-#define RCAR_I2C_ICSCR          0x00    /* Slave Control Register */
-#define RCAR_I2C_ICMCR          0x04    /* Master Control Register */
-#define RCAR_I2C_ICSIER         0x10    /* Slave IRQ Enable */
-#define RCAR_I2C_ICMIER         0x14    /* Master IRQ Enable */
-#define RCAR_I2C_ICSSR          0x08    /* Slave Status */
-#define RCAR_I2C_ICMSR          0x0c    /* Master Status */
-#define RCAR_I2C_ICCCR          0x18    /* Clock Control Register */
-#define RCAR_I2C_ICSAR          0x1c    /* Slave Address Register */
-#define RCAR_I2C_ICMAR          0x20    /* Master Address Register */
-#define RCAR_I2C_ICRXD_ICTXD    0x24    /* Receive Transmit Data Register */
-#define RCAR_I2C_ICFBSCR        0x38    /* First Bit Setup Cycle (Gen3).*/
-#define RCAR_I2C_ICFBSCR_TCYC17 0x0f    /* 17*Tcyc */
-
-#define RCAR_I2C_ICMCR_MDBS     BIT(7)  /* Master Data Buffer Select */
-#define RCAR_I2C_ICMCR_FSCL     BIT(6)  /* Forced SCL */
-#define RCAR_I2C_ICMCR_FSDA     BIT(5)  /* Forced SDA */
-#define RCAR_I2C_ICMCR_OBPC     BIT(4)  /* Override Bus Pin Control */
-#define RCAR_I2C_ICMCR_MIE      BIT(3)  /* Master Interface Enable */
-#define RCAR_I2C_ICMCR_TSBE     BIT(2)  /* Start Byte Transmission Enable */
-#define RCAR_I2C_ICMCR_FSB      BIT(1)  /* Forced Stop onto the Bus */
-#define RCAR_I2C_ICMCR_ESG      BIT(0)  /* Enable Start Generation */
+#define RCAR_I2C_ICSCR          0x00u    /* Slave Control Register */
+#define RCAR_I2C_ICMCR          0x04u    /* Master Control Register */
+#define RCAR_I2C_ICSIER         0x10u    /* Slave IRQ Enable */
+#define RCAR_I2C_ICMIER         0x14u    /* Master IRQ Enable */
+#define RCAR_I2C_ICSSR          0x08u    /* Slave Status */
+#define RCAR_I2C_ICMSR          0x0cu    /* Master Status */
+#define RCAR_I2C_ICCCR          0x18u    /* Clock Control Register */
+#define RCAR_I2C_ICSAR          0x1cu    /* Slave Address Register */
+#define RCAR_I2C_ICMAR          0x20u    /* Master Address Register */
+#define RCAR_I2C_ICRXD_ICTXD    0x24u    /* Receive Transmit Data Register */
+#define RCAR_I2C_ICFBSCR        0x38u    /* First Bit Setup Cycle (Gen3).*/
+#define RCAR_I2C_ICFBSCR_TCYC17 0x0fu    /* 17*Tcyc */
+
+#define RCAR_I2C_ICMCR_MDBS     BIT(7u)  /* Master Data Buffer Select */
+#define RCAR_I2C_ICMCR_FSCL     BIT(6u)  /* Forced SCL */
+#define RCAR_I2C_ICMCR_FSDA     BIT(5u)  /* Forced SDA */
+#define RCAR_I2C_ICMCR_OBPC     BIT(4u)  /* Override Bus Pin Control */
+#define RCAR_I2C_ICMCR_MIE      BIT(3u)  /* Master Interface Enable */
+#define RCAR_I2C_ICMCR_TSBE     BIT(2u)  /* Start Byte Transmission Enable */
+#define RCAR_I2C_ICMCR_FSB      BIT(1u)  /* Forced Stop onto the Bus */
+#define RCAR_I2C_ICMCR_ESG      BIT(0u)  /* Enable Start Generation */
 #define RCAR_I2C_ICMCR_MASTER   (RCAR_I2C_ICMCR_MDBS | RCAR_I2C_ICMCR_MIE)
 
+#define RCAR_PFC_PMMR(addr)	((addr) & 0xFFFFF800u)	/* R/W 32 LSI Multiplexed Pin Setting Mask Register */
+#define RCAR_PFC_GPSR8		0xE6068040u		/* R/W 32 GPIO/Peripheral_Function Select Register PortGroup 8 */
+#define RCAR_PFC_IP0SR8		0xE6068060u		/* R/W 32 Peripheral Function Select Register 0 PortGroup 8 */
+#define RCAR_PFC_IP1SR8		0xE6068064u		/* R/W 32 Peripheral Function Select Register 1 PortGroup 8 */
+
 /* Bits to manage ICMIER and ICMSR registers */
-#define RCAR_I2C_MNR            BIT(6)  /* Master Nack Received */
-#define RCAR_I2C_MAL            BIT(5)  /* Master Arbitration lost */
-#define RCAR_I2C_MST            BIT(4)  /* Master Stop Transmitted */
-#define RCAR_I2C_MDE            BIT(3)  /* Master Data Empty */
-#define RCAR_I2C_MDT            BIT(2)  /* Master Data Transmitted */
-#define RCAR_I2C_MDR            BIT(1)  /* Master Data Received */
-#define RCAR_I2C_MAT            BIT(0)  /* Master Address Transmitted */
+#define RCAR_I2C_MNR            BIT(6u)  /* Master Nack Received */
+#define RCAR_I2C_MAL            BIT(5u)  /* Master Arbitration lost */
+#define RCAR_I2C_MST            BIT(4u)  /* Master Stop Transmitted */
+#define RCAR_I2C_MDE            BIT(3u)  /* Master Data Empty */
+#define RCAR_I2C_MDT            BIT(2u)  /* Master Data Transmitted */
+#define RCAR_I2C_MDR            BIT(1u)  /* Master Data Received */
+#define RCAR_I2C_MAT            BIT(0u)  /* Master Address Transmitted */
 
 /* Recommended bitrate settings from official documentation */
-#define RCAR_I2C_ICCCR_CDF_100_KHZ  6
-#define RCAR_I2C_ICCCR_CDF_400_KHZ  6
-#define RCAR_I2C_ICCCR_SCGD_100_KHZ 21
-#define RCAR_I2C_ICCCR_SCGD_400_KHZ 3
-
-#define MAX_WAIT_US 100
-
-static uint32_t i2c_rcar_read(const struct i2c_rcar_cfg *config,
-			      uint32_t offs)
+#define RCAR_I2C_ICCCR_CDF_100_KHZ  6u
+#define RCAR_I2C_ICCCR_CDF_400_KHZ  6u
+#define RCAR_I2C_ICCCR_SCGD_100_KHZ 21u
+#define RCAR_I2C_ICCCR_SCGD_400_KHZ 3u
+#define RCAR_I2C_ICCCR_SCGD_MASK    0x000001F8u
+
+/* Bits to manage GPSR8 */
+#define RCAR_I2C_GPSR8_CH0 (uint32_t)(BIT(1u) | BIT(0u))
+#define RCAR_I2C_GPSR8_CH1 (uint32_t)(BIT(3u) | BIT(2u))
+#define RCAR_I2C_GPSR8_CH2 (uint32_t)(BIT(5u) | BIT(4u))
+#define RCAR_I2C_GPSR8_CH3 (uint32_t)(BIT(7u) | BIT(6u))
+#define RCAR_I2C_GPSR8_CH4 (uint32_t)(BIT(9u) | BIT(8u))
+#define RCAR_I2C_GPSR8_CH5 (uint32_t)(BIT(11u) | BIT(10u))
+
+/* Bits to manage IP0SR8 */
+#define RCAR_I2C_IP0SR8_CH0 (uint32_t)0x000000FFu
+#define RCAR_I2C_IP0SR8_CH1 (uint32_t)0x0000FF00u
+#define RCAR_I2C_IP0SR8_CH2 (uint32_t)0x00FF0000u
+#define RCAR_I2C_IP0SR8_CH3 (uint32_t)0xFF000000u
+
+/* Bits to manage IP1SR8 */
+#define RCAR_I2C_IP1SR8_CH4 (uint32_t)0x000000FFu
+#define RCAR_I2C_IP1SR8_CH5 (uint32_t)0x0000FF00u
+
+#define MAX_WAIT_MS 1000ul
+#define I2C_RECOVERY_CLK_CNT 9u
+#define LOOP_TIMEOUT 1024u
+
+static uint32_t i2c_rcar_read(const struct i2c_rcar_cfg * config, uint32_t offs);
+static void i2c_rcar_write(const struct i2c_rcar_cfg * config, uint32_t offs, uint32_t value);
+static void i2c_rcar_isr(const struct device * dev);
+static int i2c_rcar_wait_for_state(const struct device * dev, uint8_t mask);
+static int i2c_rcar_finish(const struct device * dev);
+static int i2c_rcar_set_addr(const struct device * dev, uint8_t chip, uint8_t read);
+static int i2c_rcar_transfer_msg(const struct device * dev, struct i2c_msg * msg);
+static int i2c_rcar_transfer_sub(const struct device * dev, struct i2c_msg * msgs, uint8_t num_msgs, uint16_t addr);
+static int i2c_rcar_transfer(const struct device * dev, struct i2c_msg * msgs, uint8_t num_msgs, uint16_t addr);
+static int i2c_rcar_configure(const struct device * dev, uint32_t dev_config);
+static int i2c_rcar_get_config(const struct device * dev, uint32_t * dev_config);
+static int i2c_rcar_recover_bus(const struct device * dev);
+static void i2c_rcar_pfc_init(const struct device * dev);
+static int i2c_rcar_init(const struct device * dev);
+
+
+static uint32_t i2c_rcar_read(const struct i2c_rcar_cfg * config, uint32_t offs)
 {
 	return sys_read32(config->reg_addr + offs);
 }
 
-static void i2c_rcar_write(const struct i2c_rcar_cfg *config,
-			   uint32_t offs, uint32_t value)
+static void i2c_rcar_write(const struct i2c_rcar_cfg * config, uint32_t offs, uint32_t value)
 {
 	sys_write32(value, config->reg_addr + offs);
 }
 
-static void i2c_rcar_isr(const struct device *dev)
+static void i2c_rcar_isr(const struct device * dev) /* PRQA S 3219 */
 {
-	const struct i2c_rcar_cfg *config = dev->config;
-	struct i2c_rcar_data *data = dev->data;
+	const struct i2c_rcar_cfg * drv_config = dev->config;  /* PRQA S 317 */
+	struct i2c_rcar_data * drv_data = dev->data;  /* PRQA S 317 */
 
-	if (((i2c_rcar_read(config, RCAR_I2C_ICMSR)) & data->status_mask) ==
-	    data->status_mask) {
-		k_sem_give(&data->int_sem);
-		i2c_rcar_write(config, RCAR_I2C_ICMIER, 0);
+	if (((i2c_rcar_read(drv_config, RCAR_I2C_ICMSR)) & drv_data->status_mask) ==
+		drv_data->status_mask) {
+		k_sem_give(&drv_data->int_sem);
+		i2c_rcar_write(drv_config, RCAR_I2C_ICMIER, 0u);
 	}
 }
 
-static int i2c_rcar_wait_for_state(const struct device *dev, uint8_t mask)
+static int i2c_rcar_wait_for_state(const struct device * dev, uint8_t mask)
 {
-	const struct i2c_rcar_cfg *config = dev->config;
-	struct i2c_rcar_data *data = dev->data;
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
+	struct i2c_rcar_data * drv_data = dev->data; /* PRQA S 317 */
 
-	data->status_mask = mask;
+	drv_data->status_mask = mask;
 
 	/* Reset interrupts semaphore */
-	k_sem_reset(&data->int_sem);
+	k_sem_reset(&drv_data->int_sem);
 
 	/* Enable interrupts */
-	i2c_rcar_write(config, RCAR_I2C_ICMIER, mask);
+	i2c_rcar_write(drv_config, RCAR_I2C_ICMIER, (uint32_t)mask);
 
 	/* Wait for the interrupts */
-	return k_sem_take(&data->int_sem, K_USEC(MAX_WAIT_US));
+	return k_sem_take(&drv_data->int_sem, K_MSEC(MAX_WAIT_MS));
 }
 
-static int i2c_rcar_finish(const struct device *dev)
+static int i2c_rcar_finish(const struct device * dev)
 {
-	const struct i2c_rcar_cfg *config = dev->config;
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
 	int ret;
 
 	/* Enable STOP generation */
-	i2c_rcar_write(config, RCAR_I2C_ICMCR, RCAR_I2C_ICMCR_MASTER | RCAR_I2C_ICMCR_FSB);
-	i2c_rcar_write(config, RCAR_I2C_ICMSR, 0);
+	i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, (uint32_t)(RCAR_I2C_ICMCR_MASTER | RCAR_I2C_ICMCR_FSB));
+	i2c_rcar_write(drv_config, RCAR_I2C_ICMSR, 0u);
 
 	/* Wait for STOP to be transmitted */
-	ret = i2c_rcar_wait_for_state(dev, RCAR_I2C_MST);
-	i2c_rcar_write(config, RCAR_I2C_ICMSR, 0);
+	ret = i2c_rcar_wait_for_state(dev, (uint8_t)RCAR_I2C_MST);
+	i2c_rcar_write(drv_config, RCAR_I2C_ICMSR, 0u);
 
 	/* Disable STOP generation */
-	i2c_rcar_write(config, RCAR_I2C_ICMCR, RCAR_I2C_ICMCR_MASTER);
+	i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, (uint32_t)RCAR_I2C_ICMCR_MASTER);
 
 	return ret;
 }
 
-static int i2c_rcar_set_addr(const struct device *dev,
-			     uint8_t chip, uint8_t read)
+static int i2c_rcar_set_addr(const struct device * dev, uint8_t chip, uint8_t read)
 {
-	const struct i2c_rcar_cfg *config = dev->config;
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
+	int ret;
 
 	/* Set slave address & transfer mode */
-	i2c_rcar_write(config, RCAR_I2C_ICMAR, (chip << 1) | read);
+	i2c_rcar_write(drv_config, RCAR_I2C_ICMAR, (((uint32_t)chip << 1u) | (uint32_t)read));
 	/* Reset */
-	i2c_rcar_write(config, RCAR_I2C_ICMCR, RCAR_I2C_ICMCR_MASTER | RCAR_I2C_ICMCR_ESG);
+	i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, (uint32_t)(RCAR_I2C_ICMCR_MASTER | RCAR_I2C_ICMCR_ESG));
 	/* Clear Status */
-	i2c_rcar_write(config, RCAR_I2C_ICMSR, 0);
+	i2c_rcar_write(drv_config, RCAR_I2C_ICMSR, 0u);
 
 	/* Wait for address & transfer mode to be transmitted */
-	if (read != 0) {
-		return i2c_rcar_wait_for_state(dev, RCAR_I2C_MAT | RCAR_I2C_MDR);
+	if (read != 0u) {
+		ret = i2c_rcar_wait_for_state(dev, (uint8_t)(RCAR_I2C_MAT | RCAR_I2C_MDR));
 	} else {
-		return i2c_rcar_wait_for_state(dev, RCAR_I2C_MAT | RCAR_I2C_MDE);
+		ret = i2c_rcar_wait_for_state(dev, (uint8_t)(RCAR_I2C_MAT | RCAR_I2C_MDE));
 	}
+	return ret;
 }
 
-static int i2c_rcar_transfer_msg(const struct device *dev, struct i2c_msg *msg)
+static int i2c_rcar_transfer_msg(const struct device * dev, struct i2c_msg * msg)
 {
-	const struct i2c_rcar_cfg *config = dev->config;
-	uint32_t i, reg;
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
+	uint32_t i;
+	uint32_t reg;
 	int ret = 0;
 
 	if ((msg->flags & I2C_MSG_RW_MASK) == I2C_MSG_READ) {
 		/* Reading as master */
-		i2c_rcar_write(config, RCAR_I2C_ICMCR, RCAR_I2C_ICMCR_MASTER);
+		i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, (uint32_t)RCAR_I2C_ICMCR_MASTER);
 
-		for (i = 0; i < msg->len; i++) {
-			if (msg->len - 1 == i) {
-				i2c_rcar_write(config, RCAR_I2C_ICMCR, RCAR_I2C_ICMCR_MASTER |
-					       RCAR_I2C_ICMCR_FSB);
+		for (i = 0u; i < msg->len; i++) {
+			if ((msg->len - 1u) == i) {
+				i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, (uint32_t)(RCAR_I2C_ICMCR_MASTER | RCAR_I2C_ICMCR_FSB));
 			}
 
 			/* Start data reception */
-			reg = i2c_rcar_read(config, RCAR_I2C_ICMSR);
-			reg &= ~RCAR_I2C_MDR;
-			i2c_rcar_write(config, RCAR_I2C_ICMSR, reg);
+			reg = i2c_rcar_read(drv_config, RCAR_I2C_ICMSR);
+			reg &= (uint32_t)~RCAR_I2C_MDR;
+			i2c_rcar_write(drv_config, RCAR_I2C_ICMSR, reg);
 
 			/* Wait for data to be received */
-			ret = i2c_rcar_wait_for_state(dev, RCAR_I2C_MDR);
-			if (ret != 0) {
-				return ret;
+			ret = i2c_rcar_wait_for_state(dev, (uint8_t)RCAR_I2C_MDR);
+			if (0 != ret) {
+				break;
+			} else {
+				msg->buf[i] = (uint8_t)(i2c_rcar_read(drv_config, RCAR_I2C_ICRXD_ICTXD) & 0xff); /* PRQA S 491,1841 */
 			}
-
-			msg->buf[i] = i2c_rcar_read(config, RCAR_I2C_ICRXD_ICTXD) & 0xff;
 		}
 	} else {
 		/* Writing as master */
-		for (i = 0; i < msg->len; i++) {
-			i2c_rcar_write(config, RCAR_I2C_ICRXD_ICTXD, msg->buf[i]);
+		for (i = 0u; i < msg->len; i++) {
+			i2c_rcar_write(drv_config, RCAR_I2C_ICRXD_ICTXD, (uint32_t)msg->buf[i]); /* PRQA S 491 */
 
-			i2c_rcar_write(config, RCAR_I2C_ICMCR, RCAR_I2C_ICMCR_MASTER);
+			i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, (uint32_t)RCAR_I2C_ICMCR_MASTER);
 
 			/* Start data transmission */
-			reg = i2c_rcar_read(config, RCAR_I2C_ICMSR);
-			reg &= ~RCAR_I2C_MDE;
-			i2c_rcar_write(config, RCAR_I2C_ICMSR, reg);
+			reg = i2c_rcar_read(drv_config, RCAR_I2C_ICMSR);
+			reg &= (uint32_t)~RCAR_I2C_MDE;
+			i2c_rcar_write(drv_config, RCAR_I2C_ICMSR, reg);
 
 			/* Wait for all data to be transmitted */
-			ret = i2c_rcar_wait_for_state(dev, RCAR_I2C_MDE);
-			if (ret != 0) {
-				return ret;
+			ret = i2c_rcar_wait_for_state(dev, (uint8_t)RCAR_I2C_MDE);
+			if (0 != ret) {
+				break;
 			}
 		}
 	}
@@ -207,176 +249,397 @@ static int i2c_rcar_transfer_msg(const struct device *dev, struct i2c_msg *msg)
 	return ret;
 }
 
-static int i2c_rcar_transfer(const struct device *dev,
-			     struct i2c_msg *msgs, uint8_t num_msgs,
-			     uint16_t addr)
+static int i2c_rcar_transfer_sub(const struct device * dev,
+				struct i2c_msg * msgs, uint8_t num_msgs,
+				uint16_t addr)
 {
-	const struct i2c_rcar_cfg *config = dev->config;
-	uint16_t timeout = 0;
-	int ret;
-
-	if (!num_msgs) {
-		return 0;
-	}
-
-	/* Wait for the bus to be available */
-	while ((i2c_rcar_read(config, RCAR_I2C_ICMCR) & RCAR_I2C_ICMCR_FSDA) && (timeout < 10)) {
-		k_busy_wait(USEC_PER_MSEC);
-		timeout++;
-	}
-	if (timeout == 10) {
-		return -EIO;
-	}
+	int ret = 0;
 
 	do {
 		/* We are not supporting 10-bit addressing */
 		if ((msgs->flags & I2C_MSG_ADDR_10_BITS) == I2C_MSG_ADDR_10_BITS) {
-			return -ENOTSUP;
+			ret = -ENOTSUP;
 		}
 
-		/* Send slave address */
-		if (i2c_rcar_set_addr(dev, addr, !!(msgs->flags & I2C_MSG_READ))) {
-			return -EIO; /* No ACK received */
+		if (0 == ret) {
+			/* Send slave address */
+			if (i2c_rcar_set_addr(dev, (uint8_t)addr, (uint8_t)!!(msgs->flags & I2C_MSG_READ)) != 0) {
+				ret =  -EIO; /* No ACK received */
+			}
 		}
 
-		/* Transfer data */
-		if (msgs->len) {
-			ret = i2c_rcar_transfer_msg(dev, msgs);
-			if (ret != 0) {
-				return ret;
+		if (0 == ret) {
+			/* Transfer data */
+			if (0u != msgs->len) {
+				ret = i2c_rcar_transfer_msg(dev, msgs);
 			}
 		}
 
-		/* Finish the transfer */
-		if ((msgs->flags & I2C_MSG_STOP) == I2C_MSG_STOP) {
-			ret = i2c_rcar_finish(dev);
-			if (ret != 0) {
-				return ret;
+		if (0 == ret) {
+			/* Finish the transfer */
+			if ((msgs->flags & I2C_MSG_STOP) == I2C_MSG_STOP) {
+				ret = i2c_rcar_finish(dev);
 			}
 		}
 
+		if (0 != ret) {
+			break;
+		}
+
 		/* Next message */
-		msgs++;
+		msgs++;		/* PRQA S 489 */
 		num_msgs--;
-	} while (num_msgs);
+	} while (0u != num_msgs);
+
+	return ret;
+}
+
+static int i2c_rcar_transfer(const struct device * dev,
+							struct i2c_msg * msgs, uint8_t num_msgs,
+							uint16_t addr)
+{
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
+	uint16_t drv_timeout = 0u;
+	int ret = 0;
+
+	if (0u < num_msgs) {
+		/* Wait for the bus to be available */
+		while (((i2c_rcar_read(drv_config, RCAR_I2C_ICMCR) & RCAR_I2C_ICMCR_FSDA) != 0u) &&
+			(drv_timeout < LOOP_TIMEOUT)) {
+			k_busy_wait(1u);
+			drv_timeout++;
+		}
 
-	/* Complete without error */
-	return 0;
+		if (LOOP_TIMEOUT <= drv_timeout) {
+			ret = -EIO;
+		} else {
+			ret = i2c_rcar_transfer_sub(dev, msgs, num_msgs, addr);
+		}
+	}
+
+	return ret;
 }
 
-static int i2c_rcar_configure(const struct device *dev, uint32_t dev_config)
+
+static int i2c_rcar_configure(const struct device * dev, uint32_t dev_config)
 {
-	const struct i2c_rcar_cfg *config = dev->config;
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
 	uint8_t cdf, scgd;
+	int ret = 0;
 
 	/* We only support Master mode */
 	if ((dev_config & I2C_MODE_MASTER) != I2C_MODE_MASTER) {
-		return -ENOTSUP;
+		ret = -ENOTSUP;
 	}
 
 	/* We are not supporting 10-bit addressing */
 	if ((dev_config & I2C_ADDR_10_BITS) == I2C_ADDR_10_BITS) {
-		return -ENOTSUP;
+		ret = -ENOTSUP;
 	}
 
-	switch (I2C_SPEED_GET(dev_config)) {
-	case I2C_SPEED_STANDARD:
-		/* Use recommended value for 100 kHz bus */
-		cdf = RCAR_I2C_ICCCR_CDF_100_KHZ;
-		scgd = RCAR_I2C_ICCCR_SCGD_100_KHZ;
+	if (0 == ret) {
+		switch ((uint32_t)I2C_SPEED_GET(dev_config)) {
+		case I2C_SPEED_STANDARD:
+			/* Use recommended value for 100 kHz bus */
+			cdf = RCAR_I2C_ICCCR_CDF_100_KHZ;
+			scgd = RCAR_I2C_ICCCR_SCGD_100_KHZ;
+			break;
+		case I2C_SPEED_FAST:
+			/* Use recommended value for 400 kHz bus */
+			cdf = RCAR_I2C_ICCCR_CDF_400_KHZ;
+			scgd = RCAR_I2C_ICCCR_SCGD_400_KHZ;
+			break;
+		default:
+			ret = -ENOTSUP;
+			break;
+		}
+		if (0 == ret) {
+			/* Setting ICCCR to recommended value */
+			i2c_rcar_write(drv_config, RCAR_I2C_ICCCR, (((uint32_t)scgd << 3u) | cdf));
+
+			/* Reset slave mode */
+			i2c_rcar_write(drv_config, RCAR_I2C_ICSIER, 0u);
+			i2c_rcar_write(drv_config, RCAR_I2C_ICSAR, 0u);
+			i2c_rcar_write(drv_config, RCAR_I2C_ICSCR, 0u);
+			i2c_rcar_write(drv_config, RCAR_I2C_ICSSR, 0u);
+
+			/* Reset master mode */
+			i2c_rcar_write(drv_config, RCAR_I2C_ICMIER, 0u);
+			i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, 0u);
+			i2c_rcar_write(drv_config, RCAR_I2C_ICMSR, 0u);
+			i2c_rcar_write(drv_config, RCAR_I2C_ICMAR, 0u);
+		}
+	}
+
+	return ret;
+}
+
+static int i2c_rcar_get_config(const struct device * dev, uint32_t * dev_config)
+{
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
+	uint32_t reg;
+	int ret = 0;
+
+	reg = i2c_rcar_read(drv_config, RCAR_I2C_ICCCR);
+
+	switch ((reg & RCAR_I2C_ICCCR_SCGD_MASK) >> 3u) {
+	case RCAR_I2C_ICCCR_SCGD_100_KHZ:
+		*dev_config = (uint32_t)I2C_MODE_MASTER | I2C_SPEED_SET(I2C_SPEED_STANDARD);
 		break;
-	case I2C_SPEED_FAST:
-		/* Use recommended value for 400 kHz bus */
-		cdf = RCAR_I2C_ICCCR_CDF_400_KHZ;
-		scgd = RCAR_I2C_ICCCR_SCGD_400_KHZ;
+	case RCAR_I2C_ICCCR_SCGD_400_KHZ:
+		*dev_config = (uint32_t)I2C_MODE_MASTER | I2C_SPEED_SET(I2C_SPEED_FAST);
 		break;
 	default:
-		return -ENOTSUP;
+		ret = -ERANGE;
+		break;
 	}
 
-	/* Setting ICCCR to recommended value */
-	i2c_rcar_write(config, RCAR_I2C_ICCCR, (scgd << 3) | cdf);
+	return ret;
+}
+
+static int i2c_rcar_recover_bus(const struct device * dev)
+{
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
+	uint8_t cnt;
+	uint8_t scl = 1u;
+	uint32_t reg;
+	uint32_t recovery_delay;
+	uint32_t dev_config;
+	int ret;
 
-	/* Reset slave mode */
-	i2c_rcar_write(config, RCAR_I2C_ICSIER, 0);
-	i2c_rcar_write(config, RCAR_I2C_ICSAR, 0);
-	i2c_rcar_write(config, RCAR_I2C_ICSCR, 0);
-	i2c_rcar_write(config, RCAR_I2C_ICSSR, 0);
+	ret = i2c_rcar_get_config(dev, &dev_config);
 
-	/* Reset master mode */
-	i2c_rcar_write(config, RCAR_I2C_ICMIER, 0);
-	i2c_rcar_write(config, RCAR_I2C_ICMCR, 0);
-	i2c_rcar_write(config, RCAR_I2C_ICMSR, 0);
-	i2c_rcar_write(config, RCAR_I2C_ICMAR, 0);
+	if (0 == ret) {
+		/* Determine duration of clock pulses for generating clock pulses */
+		if (I2C_SPEED_GET(dev_config) == I2C_SPEED_STANDARD) {
+			/* Generate clock with I2C_SPEED_STANDARD(100kHz) and so duration of both clock levels is 10000ns/2 */
+			recovery_delay = 5000u;
+		} else {
+			/* Generate clock with I2C_SPEED_FAST(400kHz) and so duration of both clock levels is 2500ns/2 */
+			recovery_delay = 1250u;
+		}
 
-	return 0;
+		/* Send stop command by floating SDA from low to high while SCL is at high level */
+		reg = i2c_rcar_read(drv_config, RCAR_I2C_ICMCR);
+		reg |= (uint32_t)RCAR_I2C_ICMCR_FSCL;
+		i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, reg);
+
+		k_busy_wait(recovery_delay / 1000u / 2u);
+
+		reg = i2c_rcar_read(drv_config, RCAR_I2C_ICMCR);
+		reg |= (uint32_t)RCAR_I2C_ICMCR_FSDA;
+		i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, reg);
+
+		k_busy_wait(recovery_delay / 1000u / 2u);
+
+		/* By this time SCL is high, as we need to give 9 falling-rising edges */
+		for (cnt = 0u; cnt < (I2C_RECOVERY_CLK_CNT * 2u); cnt++)
+		{
+			if (0u != scl) {
+				reg = i2c_rcar_read(drv_config, RCAR_I2C_ICMCR);
+				/* SCL shouldn't be low here */
+				if (0u == (reg & (uint32_t)RCAR_I2C_ICMCR_FSCL)) {
+					ret = -EBUSY;
+					LOG_ERR("SCL is stuck low, exit recovery");
+					break;
+				}
+			}
+
+			/* Switch scl to 1 or 0 */
+			scl ^= 1u;
+
+			/* Send stop command by floating SDA from low to high while SCL is at high level */
+			reg = i2c_rcar_read(drv_config, RCAR_I2C_ICMCR);
+			if (0u == scl) {
+				reg &= ~(uint32_t)RCAR_I2C_ICMCR_FSCL;
+			} else {
+				reg |= (uint32_t)RCAR_I2C_ICMCR_FSCL;
+			}
+			i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, reg);
+
+			k_busy_wait(recovery_delay / 1000u / 2u);
+
+			reg = i2c_rcar_read(drv_config, RCAR_I2C_ICMCR);
+			if (0u == scl) {
+				reg &= ~(uint32_t)RCAR_I2C_ICMCR_FSDA;
+			} else {
+				reg |= (uint32_t)RCAR_I2C_ICMCR_FSDA;
+			}
+			i2c_rcar_write(drv_config, RCAR_I2C_ICMCR, reg);
+
+			k_busy_wait(recovery_delay / 1000u / 2u);
+
+
+			if (0u != scl) {
+				reg = i2c_rcar_read(drv_config, RCAR_I2C_ICMCR);
+				if (0u != (reg & (uint32_t)RCAR_I2C_ICMCR_FSDA)) {
+					ret = 0;
+					break;
+				} else {
+					ret = -EBUSY;
+				}
+			}
+		}
+	}
+
+	return ret;
 }
 
-static int i2c_rcar_init(const struct device *dev)
+static void i2c_rcar_pfc_init(const struct device * dev)
 {
-	const struct i2c_rcar_cfg *config = dev->config;
-	struct i2c_rcar_data *data = dev->data;
-	uint32_t bitrate_cfg;
-	int ret;
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
+	uint32_t reg;
+	uint32_t base_addr;
+
+	base_addr = drv_config->reg_addr;
 
-	k_sem_init(&data->int_sem, 0, 1);
+	switch (base_addr) {
+	case 0xE6500000u:
+		reg = sys_read32(RCAR_PFC_GPSR8);
+		reg = reg | RCAR_I2C_GPSR8_CH0;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_GPSR8));
+		sys_write32(reg, RCAR_PFC_GPSR8);
+
+		reg = sys_read32(RCAR_PFC_IP0SR8);
+		reg = reg & ~RCAR_I2C_IP0SR8_CH0;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_IP0SR8));
+		sys_write32(reg, RCAR_PFC_IP0SR8);
+
+		break;
+	case 0xE6508000u:
+		reg = sys_read32(RCAR_PFC_GPSR8);
+		reg = reg | RCAR_I2C_GPSR8_CH1;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_GPSR8));
+		sys_write32(reg, RCAR_PFC_GPSR8);
+
+		reg = sys_read32(RCAR_PFC_IP0SR8);
+		reg = reg & ~RCAR_I2C_IP0SR8_CH1;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_IP0SR8));
+		sys_write32(reg, RCAR_PFC_IP0SR8);
+
+		break;
+	case 0xE6510000u:
+		reg = sys_read32(RCAR_PFC_GPSR8);
+		reg = reg | RCAR_I2C_GPSR8_CH2;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_GPSR8));
+		sys_write32(reg, RCAR_PFC_GPSR8);
 
-	ret = clock_control_on(config->clock_dev,
-			       (clock_control_subsys_t *)&config->mod_clk);
+		reg = sys_read32(RCAR_PFC_IP0SR8);
+		reg = reg & ~RCAR_I2C_IP0SR8_CH2;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_IP0SR8));
+		sys_write32(reg, RCAR_PFC_IP0SR8);
 
-	if (ret != 0) {
-		return ret;
+		break;
+	case 0xE66D0000u:
+		reg = sys_read32(RCAR_PFC_GPSR8);
+		reg = reg | RCAR_I2C_GPSR8_CH3;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_GPSR8));
+		sys_write32(reg, RCAR_PFC_GPSR8);
+
+		reg = sys_read32(RCAR_PFC_IP0SR8);
+		reg = reg & ~RCAR_I2C_IP0SR8_CH3;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_IP0SR8));
+		sys_write32(reg, RCAR_PFC_IP0SR8);
+
+		break;
+	case 0xE66D8000u:
+		reg = sys_read32(RCAR_PFC_GPSR8);
+		reg = reg | RCAR_I2C_GPSR8_CH4;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_GPSR8));
+		sys_write32(reg, RCAR_PFC_GPSR8);
+
+		reg = sys_read32(RCAR_PFC_IP1SR8);
+		reg = reg & ~RCAR_I2C_IP1SR8_CH4;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_IP1SR8));
+		sys_write32(reg, RCAR_PFC_IP1SR8);
+
+		break;
+	case 0xE66E0000u:
+		reg = sys_read32(RCAR_PFC_GPSR8);
+		reg = reg | RCAR_I2C_GPSR8_CH5;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_GPSR8));
+		sys_write32(reg, RCAR_PFC_GPSR8);
+
+		reg = sys_read32(RCAR_PFC_IP1SR8);
+		reg = reg & ~RCAR_I2C_IP1SR8_CH5;
+		sys_write32(~reg, RCAR_PFC_PMMR(RCAR_PFC_IP1SR8));
+		sys_write32(reg, RCAR_PFC_IP1SR8);
+
+		break;
+	default:
+		break;
 	}
+}
+
+static int i2c_rcar_init(const struct device * dev) /* PRQA S 3219 */
+{
+	const struct i2c_rcar_cfg * drv_config = dev->config; /* PRQA S 317 */
+	struct i2c_rcar_data * drv_data = dev->data; /* PRQA S 317 */
+	uint32_t bitrate_cfg;
+	int ret;
 
-	bitrate_cfg = i2c_map_dt_bitrate(config->bitrate);
+	ret = k_sem_init(&drv_data->int_sem, 0u, 1u);
 
-	ret = i2c_rcar_configure(dev, I2C_MODE_MASTER | bitrate_cfg);
-	if (ret != 0) {
-		return ret;
+	if (0 == ret) {
+		ret = clock_control_on(drv_config->clock_dev,
+					(clock_control_subsys_t *)&drv_config->mod_clk); /* PRQA S 310 */
 	}
 
-	config->init_func(dev);
+	if (0 == ret) {
+		bitrate_cfg = i2c_map_dt_bitrate(drv_config->bitrate);
+		if (bitrate_cfg == 0u) {
+			LOG_ERR("Invalid I2C bit rate value");
+		}
 
-	return 0;
+		ret = i2c_rcar_configure(dev, (uint32_t)(I2C_MODE_MASTER | bitrate_cfg));
+		if (0 == ret) {
+			drv_config->init_func(dev);
+		}
+	}
+
+	return ret;
 }
 
 static const struct i2c_driver_api i2c_rcar_driver_api = {
-	.configure = i2c_rcar_configure,
-	.transfer = i2c_rcar_transfer,
+	.configure = &i2c_rcar_configure,               /* PRQA S 1053 */
+	.transfer = &i2c_rcar_transfer,
+	.get_config = &i2c_rcar_get_config,
+	.recover_bus = &i2c_rcar_recover_bus,
 };
 
 /* Device Instantiation */
-#define I2C_RCAR_INIT(n)						       \
-	static void i2c_rcar_##n##_init(const struct device *dev);	       \
-	static const struct i2c_rcar_cfg i2c_rcar_cfg_##n = {		       \
-		.reg_addr = DT_INST_REG_ADDR(n),			       \
-		.init_func = i2c_rcar_##n##_init,			       \
-		.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),	       \
-		.bitrate = DT_INST_PROP(n, clock_frequency),		       \
-		.mod_clk.module =					       \
-			DT_INST_CLOCKS_CELL_BY_IDX(n, 0, module),	       \
-		.mod_clk.domain =					       \
-			DT_INST_CLOCKS_CELL_BY_IDX(n, 0, domain),	       \
-	};								       \
-									       \
-	static struct i2c_rcar_data i2c_rcar_data_##n;			       \
-									       \
-	I2C_DEVICE_DT_INST_DEFINE(n,					       \
-			      i2c_rcar_init,				       \
-			      NULL,					       \
-			      &i2c_rcar_data_##n,			       \
-			      &i2c_rcar_cfg_##n,			       \
-			      POST_KERNEL, CONFIG_I2C_INIT_PRIORITY,	       \
-			      &i2c_rcar_driver_api			       \
-			      );					       \
-	static void i2c_rcar_##n##_init(const struct device *dev)	       \
-	{								       \
-		IRQ_CONNECT(DT_INST_IRQN(n),				       \
-			    0,						       \
-			    i2c_rcar_isr,				       \
-			    DEVICE_DT_INST_GET(n), 0);			       \
-									       \
-		irq_enable(DT_INST_IRQN(n));				       \
-	}
+#define I2C_RCAR_INIT(n)										\
+	static void i2c_rcar_##n##_init(const struct device * dev);	\
+	static const struct i2c_rcar_cfg i2c_rcar_cfg_##n = {		\
+		.reg_addr = DT_INST_REG_ADDR(n),						\
+		.init_func = i2c_rcar_##n##_init,						\
+		.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),		\
+		.bitrate = DT_INST_PROP(n, clock_frequency),			\
+		.mod_clk.module =										\
+			DT_INST_CLOCKS_CELL_BY_IDX(n, 0, module),			\
+		.mod_clk.domain =										\
+			DT_INST_CLOCKS_CELL_BY_IDX(n, 0, domain),			\
+	};															\
+																\
+	static struct i2c_rcar_data i2c_rcar_data_##n;				\
+																\
+	I2C_DEVICE_DT_INST_DEFINE(n,								\
+				i2c_rcar_init,									\
+				NULL,											\
+				&i2c_rcar_data_##n,								\
+				&i2c_rcar_cfg_##n,								\
+				POST_KERNEL, CONFIG_I2C_INIT_PRIORITY,			\
+				&i2c_rcar_driver_api							\
+				);												\
+	static void i2c_rcar_##n##_init(const struct device * dev)	\
+	{															\
+		IRQ_CONNECT(DT_INST_IRQN(n),							\
+				0,												\
+				i2c_rcar_isr,									\
+				DEVICE_DT_INST_GET(n), 0);						\
+																\
+		irq_enable(DT_INST_IRQN(n));							\
+		i2c_rcar_pfc_init(DEVICE_DT_INST_GET(n));				\
+	} /* PRQA S 342,881,3412 */
 
 DT_INST_FOREACH_STATUS_OKAY(I2C_RCAR_INIT)
diff --git a/drivers/power_domain/CMakeLists.txt b/drivers/power_domain/CMakeLists.txt
index a2aed23c6a..ca6c435314 100644
--- a/drivers/power_domain/CMakeLists.txt
+++ b/drivers/power_domain/CMakeLists.txt
@@ -1,6 +1,8 @@
 # Copyright (c) 2022, CSIRO
+# Copyright (c) 2022 Renesas Electronics Corporation
 # SPDX-License-Identifier: Apache-2.0
 
 zephyr_library()
 
 zephyr_library_sources_ifdef(CONFIG_POWER_DOMAIN_GPIO power_domain_gpio.c)
+zephyr_library_sources_ifdef(CONFIG_POWER_DOMAIN_SYSC power_domain_sysc.c)
diff --git a/drivers/power_domain/Kconfig b/drivers/power_domain/Kconfig
index b1eebc9e17..514084eb95 100644
--- a/drivers/power_domain/Kconfig
+++ b/drivers/power_domain/Kconfig
@@ -1,4 +1,5 @@
 # Copyright (c) 2022, CSIRO.
+# Copyright (c) 2022 Renesas Electronics Corporation
 # SPDX-License-Identifier: Apache-2.0
 
 menuconfig POWER_DOMAIN
@@ -17,4 +18,8 @@ config POWER_DOMAIN_GPIO
 	depends on GPIO
 	depends on TIMEOUT_64BIT
 
+config POWER_DOMAIN_SYSC
+	bool "SYSC controlled power domain"
+	depends on SOC_SERIES_RCAR_GEN4
+
 endif
diff --git a/drivers/power_domain/power_domain_sysc.c b/drivers/power_domain/power_domain_sysc.c
new file mode 100644
index 0000000000..d22d7f48b9
--- /dev/null
+++ b/drivers/power_domain/power_domain_sysc.c
@@ -0,0 +1,328 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT power_domain_sysc
+
+#include <kernel.h>
+#include <pm/device.h>
+#include <pm/device_runtime.h>
+#include <drivers/syscon.h>
+#include <logging/log.h>
+LOG_MODULE_REGISTER(power_domain_sysc, CONFIG_POWER_DOMAIN_LOG_LEVEL);
+
+struct pd_sysc_config {
+	uint32_t power_domain_number;
+	const struct device *syscon;
+	uint32_t reg_check_interval_us;
+	uint32_t reg_check_timeout_us;
+};
+
+#define		SYSC_PWR_BIT_FROM_DOMAIN(domain)	((domain) % 32u)
+
+#define		SYSC_SYSCSR				(0x000u)
+#define		SYSC_SYSCSR_BUSY_MASK				(0x00000003u)
+#define		SYSC_SYSCSR_BUSY_NO_PROC			(0x00000003u)
+
+#define		SYSC_SYSCPONSR0			(0x800u)
+#define		SYSC_SYSCPONSRn(domain)	(SYSC_SYSCPONSR0 + (0x4u * ((domain)/32u)))
+
+#define		SYSC_SYSCISCR0			(0x810u)
+#define		SYSC_SYSCISCR1			(0x814u)
+#define		SYSC_SYSCISCRn(domain)	(SYSC_SYSCISCR0 + (0x4u * ((domain)/32u)))
+
+#define		SYSC_SYSCIER0			(0x820u)
+#define		SYSC_SYSCIER1			(0x824u)
+#define		SYSC_SYSCIERn(domain)	(SYSC_SYSCIER0 + (0x4u * ((domain)/32u)))
+
+#define		SYSC_SYSCIMR0			(0x830u)
+#define		SYSC_SYSCIMR1			(0x834u)
+#define		SYSC_SYSCIMRn(domain)	(SYSC_SYSCIMR0 + (0x4u * ((domain)/32u)))
+
+#define		SYSC_PDRONCR0			(0x1004u)
+#define		SYSC_PDRONCRn(domain)	(SYSC_PDRONCR0 + ((domain) * 0x40u))
+
+#define		SYSC_PDROFFCR0			(0x1008u)
+#define		SYSC_PDROFFCRn(domain)	(SYSC_PDROFFCR0 + ((domain) * 0x40u))
+
+#define		SYSC_PDR_NUMBER_MAX (63u)	/* Maximum PDR number (PDR:00-63) */
+static int pd_sysc_is_power_on(const struct pd_sysc_config * cfg, uint32_t * is_pwr_on);
+static int pd_sysc_power_control_sub_step1(const struct pd_sysc_config * cfg);
+static int pd_sysc_power_control_step1_wait(const struct pd_sysc_config * cfg);
+static int pd_sysc_power_control_sub_step2(const struct pd_sysc_config * cfg, enum pm_device_action action);
+static int pd_sysc_power_control_step2_wait(const struct pd_sysc_config * cfg);
+static int pd_sysc_power_control_sub_step3(const struct pd_sysc_config * cfg);
+static int pd_sysc_power_control(const struct pd_sysc_config * cfg, enum pm_device_action action);
+static int pd_sysc_pm_action(const struct device * dev, enum pm_device_action action);
+static int pd_sysc_init(const struct device * dev);
+
+
+static int pd_sysc_is_power_on(const struct pd_sysc_config * cfg,
+		uint32_t * is_pwr_on)
+{
+	int rc = -EIO;
+	int err;
+	uint32_t reg;
+
+	err = syscon_read_reg(cfg->syscon, (uint16_t)SYSC_SYSCPONSRn(cfg->power_domain_number),
+			&reg);
+	if (err < 0) {
+		LOG_ERR("failed to syscon_read_reg (err %d)", err);
+	} else {
+		*is_pwr_on = reg & ((uint32_t)1u << SYSC_PWR_BIT_FROM_DOMAIN(cfg->power_domain_number));
+		rc = 0;
+	}
+
+	return rc;
+}
+
+static int pd_sysc_power_control_sub_step1(const struct pd_sysc_config * cfg)
+{
+	int rc;
+	uint32_t reg;
+
+	/* Set SYSCIERn and SYSCIMRm. (*1) */
+	rc = syscon_read_reg(cfg->syscon, (uint16_t)SYSC_SYSCIERn(cfg->power_domain_number),
+			&reg);
+	if (0 > rc) {
+		LOG_ERR("failed to syscon_read_reg (rc %d)", rc);
+		rc = -EIO;
+	} else {
+		reg |= ((uint32_t)1u << SYSC_PWR_BIT_FROM_DOMAIN(cfg->power_domain_number));
+		rc = syscon_write_reg(cfg->syscon, (uint16_t)SYSC_SYSCIERn(cfg->power_domain_number),
+				reg);
+		if (0 > rc) {
+			LOG_ERR("failed to syscon_write_reg (rc %d)", rc);
+			rc = -EIO;
+		} else {
+			rc = syscon_read_reg(cfg->syscon, (uint16_t)SYSC_SYSCIMRn(cfg->power_domain_number),
+					&reg);
+			if (0 > rc) {
+				LOG_ERR("failed to syscon_read_reg (rc %d)", rc);
+				rc = -EIO;
+			} else {
+				reg &= (~((uint32_t)1u << SYSC_PWR_BIT_FROM_DOMAIN(cfg->power_domain_number)));
+				rc = syscon_write_reg(cfg->syscon, (uint16_t)SYSC_SYSCIMRn(cfg->power_domain_number),
+						reg);
+				if (0 > rc) {
+					LOG_ERR("failed to syscon_write_reg (rc %d)", rc);
+					rc = -EIO;
+				}
+			}
+		}
+	}
+	return rc;
+}
+
+static int pd_sysc_power_control_step1_wait(const struct pd_sysc_config * cfg)
+{
+	int rc;
+	uint32_t reg;
+	uint32_t time_count_us;
+	uint32_t brk = 0u;
+
+	/* SYSCSR[0] or SYSCSR[1] = 1? (*2) */
+	/* For power resume : SYSCSR[1] */
+	/* For power shut off : SYSCSR[0] */
+	time_count_us = 0u;
+	do {
+		rc = syscon_read_reg(cfg->syscon, SYSC_SYSCSR, &reg);
+		if (rc < 0) {
+			LOG_ERR("failed to syscon_read_reg (rc %d)", rc);
+			rc = -EIO;
+			brk = 1u;
+		} else if ((reg & SYSC_SYSCSR_BUSY_MASK) == SYSC_SYSCSR_BUSY_NO_PROC) {
+			brk = 1u;
+		} else {
+			(void)k_sleep(K_USEC((uint64_t)(cfg->reg_check_interval_us)));
+			time_count_us += cfg->reg_check_interval_us;
+			if (cfg->reg_check_timeout_us <= time_count_us) {
+				LOG_ERR("timeout to wait SYSCSRn");
+				rc = -ETIME;
+				brk = 1u;
+			}
+		}
+	} while (brk != 1u);
+
+	return rc;
+}
+
+static int pd_sysc_power_control_sub_step2(const struct pd_sysc_config * cfg,
+		enum pm_device_action action)
+{
+	int rc;
+
+	/* Set PDRONCRn or PDROFFCRn to 1. (*3) */
+	if (PM_DEVICE_ACTION_RESUME == action) {
+		rc = syscon_write_reg(cfg->syscon,
+				(uint16_t)SYSC_PDRONCRn(cfg->power_domain_number), 0x1u);
+	} else {
+		rc = syscon_write_reg(cfg->syscon,
+				(uint16_t)SYSC_PDROFFCRn(cfg->power_domain_number), 0x1u);
+	}
+	if (0 > rc) {
+		LOG_ERR("failed to syscon_write_reg (rc %d)", rc);
+		rc = -EIO;
+	}
+
+	return rc;
+}
+
+static int pd_sysc_power_control_step2_wait(const struct pd_sysc_config * cfg)
+{
+	int rc;
+	uint32_t reg;
+	uint32_t time_count_us;
+	uint32_t brk = 0u;
+
+	/* SYSCISCRm = 1? (*4) */
+	time_count_us = 0u;
+	do {
+		rc = syscon_read_reg(cfg->syscon,
+				(uint16_t)SYSC_SYSCISCRn(cfg->power_domain_number), &reg);
+		if (0 > rc) {
+			LOG_ERR("failed to syscon_read_reg (rc %d)", rc);
+			rc = -EIO;
+			brk = 1u;
+		} else if ((reg & ((uint32_t)1u << SYSC_PWR_BIT_FROM_DOMAIN(cfg->power_domain_number))) != 0u) {
+			brk = 1u;
+		} else {
+			(void)k_sleep(K_USEC((uint64_t)(cfg->reg_check_interval_us)));
+			time_count_us += cfg->reg_check_interval_us;
+			if (cfg->reg_check_timeout_us <= time_count_us) {
+				LOG_ERR("timeout to wait SYSCISCRm");
+				rc = -ETIME;
+				brk = 1u;
+			}
+		}
+	} while (brk != 1u);
+
+	return rc;
+}
+
+static int pd_sysc_power_control_sub_step3(const struct pd_sysc_config * cfg)
+{
+	int rc;
+
+	/* Clear bit in SYSCISCRm */
+	rc = syscon_write_reg(cfg->syscon,
+			(uint16_t)SYSC_SYSCISCRn(cfg->power_domain_number),
+			((uint32_t)1u << SYSC_PWR_BIT_FROM_DOMAIN(cfg->power_domain_number)));
+	if (0 > rc) {
+		LOG_ERR("failed to syscon_write_reg (rc %d)", rc);
+		rc = -EIO;
+	}
+
+	return rc;
+}
+
+static int pd_sysc_power_control(const struct pd_sysc_config * cfg,
+		enum pm_device_action action)
+{
+	int rc;
+	uint32_t is_pwr_on;
+
+	/* Check the need for power control */
+	rc = pd_sysc_is_power_on(cfg, &is_pwr_on);
+	if (0 > rc) {
+		LOG_ERR("failed to pd_sysc_is_power_on (rc %d)", rc);
+	} else {
+		if (PM_DEVICE_ACTION_RESUME == action) {
+			if (0u != is_pwr_on) {
+				/* already power on */
+				rc = 1;
+			}
+		} else {
+			if (0u == is_pwr_on) {
+				/* already power off */
+				rc = 1;
+			}
+		}
+	}
+	/* power control step1 */
+	if (0 == rc) {
+		rc = pd_sysc_power_control_sub_step1(cfg);
+		if (0 == rc) {
+			rc = pd_sysc_power_control_step1_wait(cfg);
+		}
+	}
+	/* power control step2 */
+	if (0 == rc) {
+		rc = pd_sysc_power_control_sub_step2(cfg, action);
+		if (0 == rc) {
+			rc = pd_sysc_power_control_step2_wait(cfg);
+		}
+	}
+	/* power control step3 */
+	if (0 == rc) {
+		rc = pd_sysc_power_control_sub_step3(cfg);
+	}
+	/* already power on or already power off */
+	if (0 < rc) {
+		rc = 0;
+	}
+	return rc;
+}
+
+static int pd_sysc_pm_action(const struct device * dev, /* PRQA S 3219 */
+				enum pm_device_action action)
+{
+	const struct pd_sysc_config * cfg = dev->config; /* PRQA S 317 */
+	int rc = -EINVAL;
+
+	/* PDR number check */
+	if (cfg->power_domain_number > SYSC_PDR_NUMBER_MAX)
+	{
+		LOG_ERR("pdr number is out of range (power_domain_number %d)",
+											cfg->power_domain_number);
+	} else {
+		switch (action) {
+		case PM_DEVICE_ACTION_RESUME:
+			/* Power on using syscon */
+			rc = pd_sysc_power_control(cfg, action);
+
+			LOG_DBG("%s is now ON", dev->name);
+			break;
+		case PM_DEVICE_ACTION_SUSPEND:
+			/* Power off using syscon */
+			rc = pd_sysc_power_control(cfg, action);
+
+			LOG_DBG("%s is now OFF and powered", dev->name);
+			break;
+		default:
+			LOG_ERR("action is out of range (action %d)", action);
+			rc = -ENOTSUP;
+			break;
+		}
+	}
+	return rc;
+}
+
+static int pd_sysc_init(const struct device * dev) /* PRQA S 3219 */
+{
+	const struct pd_sysc_config * cfg = dev->config;  /* PRQA S 317 */
+	int rc = 0;
+
+	if (!device_is_ready(cfg->syscon)) {
+		LOG_ERR("syscon device not ready");
+		rc = -EINVAL;
+	}
+
+	return rc;
+}
+
+#define POWER_DOMAIN_DEVICE(id)						   \
+	static const struct pd_sysc_config pd_sysc_##id##_cfg = {	   \
+		.power_domain_number = DT_INST_PROP(id, power_domain_number),	   \
+		.syscon = DEVICE_DT_GET(DT_INST_PHANDLE(id, syscon)),	\
+		.reg_check_interval_us = DT_INST_PROP(id, reg_check_interval_us),	   \
+		.reg_check_timeout_us = DT_INST_PROP(id, reg_check_timeout_us),	   \
+	};								   \
+	PM_DEVICE_DT_INST_DEFINE(id, pd_sysc_pm_action);		   \
+	DEVICE_DT_INST_DEFINE(id, pd_sysc_init, PM_DEVICE_DT_INST_GET(id), \
+				NULL, &pd_sysc_##id##_cfg,   \
+				POST_KERNEL, 75, NULL); /* PRQA S 342,881,3412 */
+
+DT_INST_FOREACH_STATUS_OKAY(POWER_DOMAIN_DEVICE)
diff --git a/drivers/serial/CMakeLists.txt b/drivers/serial/CMakeLists.txt
index f06224b2e4..90dcffdc9c 100644
--- a/drivers/serial/CMakeLists.txt
+++ b/drivers/serial/CMakeLists.txt
@@ -41,7 +41,11 @@ zephyr_library_sources_ifdef(CONFIG_UART_XMC4XXX uart_xmc4xxx.c)
 zephyr_library_sources_ifdef(CONFIG_UART_NPCX uart_npcx.c)
 zephyr_library_sources_ifdef(CONFIG_UART_APBUART uart_apbuart.c)
 zephyr_library_sources_ifdef(CONFIG_USB_CDC_ACM ${ZEPHYR_BASE}/misc/empty_file.c)
+if(CONFIG_SOC_SERIES_RCAR_GEN4)
+zephyr_library_sources_ifdef(CONFIG_UART_RCAR uart_rcar_V4H.c)
+else()
 zephyr_library_sources_ifdef(CONFIG_UART_RCAR uart_rcar.c)
+endif()
 zephyr_library_sources_ifdef(CONFIG_UART_XEC uart_mchp_xec.c)
 zephyr_library_sources_ifdef(CONFIG_UART_NEORV32 uart_neorv32.c)
 zephyr_library_sources_ifdef(CONFIG_USART_GD32 usart_gd32.c)
diff --git a/drivers/serial/uart_rcar_V4H.c b/drivers/serial/uart_rcar_V4H.c
new file mode 100644
index 0000000000..69acc8856b
--- /dev/null
+++ b/drivers/serial/uart_rcar_V4H.c
@@ -0,0 +1,775 @@
+/*
+ * Copyright (c) 2021 IoT.bzh
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT renesas_rcar_scif
+
+#include <errno.h>
+#include <zephyr/device.h>
+#include <zephyr/devicetree.h>
+#include <zephyr/drivers/uart.h>
+#include <zephyr/drivers/clock_control.h>
+#include <zephyr/drivers/clock_control/rcar_clock_control.h>
+#include <zephyr/spinlock.h>
+
+struct uart_rcar_cfg {
+	uint32_t reg_addr;
+	const struct device *clock_dev;
+	struct rcar_cpg_clk mod_clk;
+	struct rcar_cpg_clk bus_clk;
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	void (*irq_config_func)(const struct device * dev);
+#endif
+};
+
+struct uart_rcar_data {
+	struct uart_config current_config;
+	uint32_t clk_rate;
+	struct k_spinlock lock;
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	uart_irq_callback_user_data_t callback;
+	void *cb_data;
+#endif
+};
+
+/* Registers */
+#define SCSMR           0x00u    /* Serial Mode Register */
+#define SCBRR           0x04u    /* Bit Rate Register */
+#define SCSCR           0x08u    /* Serial Control Register */
+#define SCFTDR          0x0cu    /* Transmit FIFO Data Register */
+#define SCFSR           0x10u    /* Serial Status Register */
+#define SCFRDR          0x14u    /* Receive FIFO Data Register */
+#define SCFCR           0x18u    /* FIFO Control Register */
+#define SCFDR           0x1cu    /* FIFO Data Count Register */
+#define SCSPTR          0x20u    /* Serial Port Register */
+#define SCLSR           0x24u    /* Line Status Register */
+#define DL              0x30u    /* Frequency Division Register */
+#define CKS             0x34u    /* Clock Select Register */
+
+/* SCSMR (Serial Mode Register) */
+#define SCSMR_C_A       BIT(7u)  /* Communication Mode */
+#define SCSMR_CHR       BIT(6u)  /* 7-bit Character Length */
+#define SCSMR_PE        BIT(5u)  /* Parity Enable */
+#define SCSMR_O_E       BIT(4u)  /* Odd Parity */
+#define SCSMR_STOP      BIT(3u)  /* Stop Bit Length */
+#define SCSMR_CKS1      BIT(1u)  /* Clock Select 1 */
+#define SCSMR_CKS0      BIT(0u)  /* Clock Select 0 */
+
+/* SCSCR (Serial Control Register) */
+#define SCSCR_TEIE      BIT(11u) /* Transmit End Interrupt Enable */
+#define SCSCR_TIE       BIT(7u)  /* Transmit Interrupt Enable */
+#define SCSCR_RIE       BIT(6u)  /* Receive Interrupt Enable */
+#define SCSCR_TE        BIT(5u)  /* Transmit Enable */
+#define SCSCR_RE        BIT(4u)  /* Receive Enable */
+#define SCSCR_REIE      BIT(3u)  /* Receive Error Interrupt Enable */
+#define SCSCR_TOIE      BIT(2u)  /* Timeout Interrupt Enable */
+#define SCSCR_CKE1      BIT(1u)  /* Clock Enable 1 */
+#define SCSCR_CKE0      BIT(0u)  /* Clock Enable 0 */
+
+/* SCFCR (FIFO Control Register) */
+#define SCFCR_RTRG1     BIT(7u)  /* Receive FIFO Data Count Trigger 1 */
+#define SCFCR_RTRG0     BIT(6u)  /* Receive FIFO Data Count Trigger 0 */
+#define SCFCR_TTRG1     BIT(5u)  /* Transmit FIFO Data Count Trigger 1 */
+#define SCFCR_TTRG0     BIT(4u)  /* Transmit FIFO Data Count Trigger 0 */
+#define SCFCR_MCE       BIT(3u)  /* Modem Control Enable */
+#define SCFCR_TFRST     BIT(2u)  /* Transmit FIFO Data Register Reset */
+#define SCFCR_RFRST     BIT(1u)  /* Receive FIFO Data Register Reset */
+#define SCFCR_LOOP      BIT(0u)  /* Loopback Test */
+
+/* SCFSR (Serial Status Register) */
+#define SCFSR_PER3      BIT(15u) /* Parity Error Count 3 */
+#define SCFSR_PER2      BIT(14u) /* Parity Error Count 2 */
+#define SCFSR_PER1      BIT(13u) /* Parity Error Count 1 */
+#define SCFSR_PER0      BIT(12u) /* Parity Error Count 0 */
+#define SCFSR_FER3      BIT(11u) /* Framing Error Count 3 */
+#define SCFSR_FER2      BIT(10u) /* Framing Error Count 2 */
+#define SCFSR_FER_1     BIT(9u)  /* Framing Error Count 1 */
+#define SCFSR_FER0      BIT(8u)  /* Framing Error Count 0 */
+#define SCFSR_ER        BIT(7u)  /* Receive Error */
+#define SCFSR_TEND      BIT(6u)  /* Transmission ended */
+#define SCFSR_TDFE      BIT(5u)  /* Transmit FIFO Data Empty */
+#define SCFSR_BRK       BIT(4u)  /* Break Detect */
+#define SCFSR_FER       BIT(3u)  /* Framing Error */
+#define SCFSR_PER       BIT(2u)  /* Parity Error */
+#define SCFSR_RDF       BIT(1u)  /* Receive FIFO Data Full */
+#define SCFSR_DR        BIT(0u)  /* Receive Data Ready */
+
+/* SCLSR (Line Status Register) on (H)SCIF */
+#define SCLSR_TO        BIT(2u)  /* Timeout */
+#define SCLSR_ORER      BIT(0u)  /* Overrun Error */
+
+/* PFC (Pin Function Controller) */
+#define RCAR_PFC_GPSR1  0xE6050840u       /* R/W 32 GPIO/Peripheral_Function Select register PortGroup 1 */
+#define RCAR_PFC_GPSR1_SCIF_ENABLE  0x0001F000u  /* bit16:HRX0, bit15:HSCK0, bit14:HRTS0#, bit13:HCTS0#, bit12:HTX0 */
+#define RCAR_PFC_IP1SR1 0xE6050864u       /* R/W 32 Peripheral Function Select register 1 PortGroup 1 */
+#define RCAR_PFC_IP1SR1_SCIF_ENABLE  0x11110000u /* [31:16]: 0x1111 (select SCK0, RTS0#, CTS0#, TX0) */
+#define RCAR_PFC_IP1SR1_SCIF_CLEAR_MASK  0x0000FFFFu /* [31:16]:clear */
+#define RCAR_PFC_IP2SR1 0xE6050868u       /* R/W 32 Peripheral Function Select register 2 PortGroup 1 */
+#define RCAR_PFC_IP2SR1_SCIF_ENABLE  0x00000001u /* [3:0]: 0x1 (select RX0) */
+#define RCAR_PFC_IP2SR1_SCIF_CLEAR_MASK  0xFFFFFFF0u /* [3:0]: clear */
+#define RCAR_PFC_PMMR(addr)  ((addr) & 0xFFFFF800u) /* R/W 32 LSI Multiplexed Pin Setting Mask Register */
+
+/* baudrate range */
+#define BAUDRATE_MIN (9600u)   /* baudrate minimum */
+#define BAUDRATE_MAX (230400u) /* baudrate maximum */
+
+static void uart_rcar_write_8(const struct uart_rcar_cfg * config,
+				uint32_t offs, uint8_t value);
+static uint16_t uart_rcar_read_16(const struct uart_rcar_cfg * config,
+				uint32_t offs);
+static void uart_rcar_write_16(const struct uart_rcar_cfg * config,
+				uint32_t offs, uint16_t value);
+static void uart_rcar_set_baudrate(const struct device * dev,
+				uint32_t baud_rate);
+static int uart_rcar_poll_in(const struct device * dev, unsigned char * p_char);
+static void uart_rcar_poll_out(const struct device * dev, unsigned char out_char);
+static int uart_rcar_configure(const struct device * dev, const struct uart_config * cfg);
+#ifdef CONFIG_UART_USE_RUNTIME_CONFIGURE
+static int uart_rcar_config_get(const struct device * dev, struct uart_config * cfg);
+#endif
+static int uart_rcar_init(const struct device * dev);
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+static bool uart_rcar_irq_is_enabled(const struct device * dev, uint32_t irq);
+#endif
+static int uart_rcar_fifo_fill(const struct device * dev, const uint8_t * tx_data, int len);
+static int uart_rcar_fifo_read(const struct device * dev, uint8_t * rx_data, const int size);
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+static void uart_rcar_irq_tx_enable(const struct device * dev);
+static void uart_rcar_irq_tx_disable(const struct device * dev);
+static int uart_rcar_irq_tx_ready(const struct device * dev);
+static void uart_rcar_irq_rx_enable(const struct device * dev);
+static void uart_rcar_irq_rx_disable(const struct device * dev);
+static int uart_rcar_irq_rx_ready(const struct device * dev);
+static void uart_rcar_irq_err_enable(const struct device * dev);
+static void uart_rcar_irq_err_disable(const struct device * dev);
+static int uart_rcar_irq_is_pending(const struct device * dev);
+static int uart_rcar_irq_update(const struct device * dev);
+static void uart_rcar_irq_callback_set(const struct device * dev,
+						uart_irq_callback_user_data_t cb,
+						void * cb_data);
+#endif
+static void uart_rcar_pfc_init(void);
+
+
+static void uart_rcar_write_8(const struct uart_rcar_cfg * config,
+					uint32_t offs, uint8_t value)
+{
+	sys_write8(value, config->reg_addr + offs);
+}
+
+static uint16_t uart_rcar_read_16(const struct uart_rcar_cfg * config, uint32_t offs)
+{
+	return sys_read16(config->reg_addr + offs);
+}
+
+static void uart_rcar_write_16(const struct uart_rcar_cfg * config,
+					uint32_t offs, uint16_t value)
+{
+	sys_write16(value, config->reg_addr + offs);
+}
+
+static void uart_rcar_set_baudrate(const struct device * dev, uint32_t baud_rate)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;       /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;                /* PRQA S 317 */
+	uint8_t reg_val;
+	uint32_t interval;
+
+	reg_val = (uint8_t)(((pdata->clk_rate + (16u * baud_rate)) / (32u * baud_rate)) - 1u);
+	uart_rcar_write_8(pconfig, SCBRR, reg_val);
+
+	/* 1-bit interval elapsed */
+	interval = (1000000u / baud_rate) + 1u;
+	k_busy_wait(interval);
+}
+
+static int uart_rcar_poll_in(const struct device * dev, unsigned char * p_char)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;       /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;                /* PRQA S 317 */
+	uint16_t reg_val;
+	int ret = 0;
+
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+
+	/* Argument NULL check */
+	if (NULL == p_char)
+	{
+		ret = -EINVAL;
+	}
+
+	if (0 == ret)
+	{
+		/* Receive FIFO empty */
+		if (0u == ((uart_rcar_read_16(pconfig, (uint32_t)SCFSR)) & SCFSR_RDF)) {
+			ret = -1;
+		} else {
+
+			*p_char = (unsigned char)uart_rcar_read_16(pconfig, (uint32_t)SCFRDR);
+
+			reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCFSR);
+			reg_val &= (uint16_t)(~SCFSR_RDF);
+			uart_rcar_write_16(pconfig, SCFSR, reg_val);
+		}
+	}
+	k_spin_unlock(&pdata->lock, key_struct);
+
+	return ret;
+}
+
+static void uart_rcar_poll_out(const struct device * dev, unsigned char out_char)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;       /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;                /* PRQA S 317 */
+	uint16_t reg_val;
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+
+	/* Wait for empty space in transmit FIFO */
+	while (0u == (uart_rcar_read_16(pconfig, (uint32_t)SCFSR) & SCFSR_TDFE)) {
+	}
+
+	uart_rcar_write_8(pconfig, SCFTDR, out_char);
+
+	reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCFSR);
+	reg_val &= (uint16_t)(~(SCFSR_TDFE | SCFSR_TEND));
+	uart_rcar_write_16(pconfig, SCFSR, reg_val);
+
+	k_spin_unlock(&pdata->lock, key_struct);
+}
+
+static int uart_rcar_configure(const struct device * dev, const struct uart_config * cfg)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;       /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;                /* PRQA S 317 */
+	int ret = 0;
+
+	uint16_t reg_val;
+	k_spinlock_key_t key_struct;
+
+	/* Argument NULL check */
+	if (NULL == cfg) {
+		ret = -EINVAL;
+	}
+
+	/* baudrate range check */
+	if (0 == ret) {
+		if ((BAUDRATE_MIN > cfg->baudrate) || (BAUDRATE_MAX < cfg->baudrate))
+		{
+			ret = -ENOTSUP;
+		}
+	}
+
+	/* parity range check */
+	if (0 == ret) {
+		if (!(((uint8_t)UART_CFG_PARITY_NONE == cfg->parity) ||
+		   ((uint8_t)UART_CFG_PARITY_EVEN == cfg->parity) ||
+		   ((uint8_t)UART_CFG_PARITY_ODD == cfg->parity)))
+		{
+			ret = -ENOTSUP;
+		}
+	}
+
+	/* stop_bits range check */
+	if (0 == ret) {
+		if (!(((uint8_t)UART_CFG_STOP_BITS_1 == cfg->stop_bits) ||
+		   ((uint8_t)UART_CFG_STOP_BITS_2 == cfg->stop_bits)))
+		{
+			ret = -ENOTSUP;
+		}
+	}
+
+	/* data_bits range check */
+	if (0 == ret) {
+		if (!(((uint8_t)UART_CFG_DATA_BITS_7 == cfg->data_bits) ||
+		   ((uint8_t)UART_CFG_DATA_BITS_8 == cfg->data_bits)))
+		{
+			ret = -ENOTSUP;
+		}
+	}
+
+	/* flow_ctrl range check */
+	if (0 == ret) {
+		if (((uint8_t)UART_CFG_FLOW_CTRL_NONE != cfg->flow_ctrl)) {
+			ret = -ENOTSUP;
+		}
+	}
+
+	if (0 == ret)
+	{
+		key_struct = k_spin_lock(&pdata->lock);
+
+		/* Disable Transmit and Receive */
+		reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSCR);
+		reg_val &= (uint16_t)(~(SCSCR_TE | SCSCR_RE));
+		uart_rcar_write_16(pconfig, SCSCR, reg_val);
+
+		/* Emptying Transmit and Receive FIFO */
+		reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCFCR);
+		reg_val |= (uint16_t)(SCFCR_TFRST | SCFCR_RFRST);
+		uart_rcar_write_16(pconfig, SCFCR, reg_val);
+
+		/* Resetting Errors Registers */
+		reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCFSR);
+		reg_val &= (uint16_t)(~(SCFSR_ER | SCFSR_DR | SCFSR_BRK | SCFSR_RDF));
+		uart_rcar_write_16(pconfig, SCFSR, reg_val);
+
+		reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCLSR);
+		reg_val &= (uint16_t)(~(SCLSR_TO | SCLSR_ORER));
+		uart_rcar_write_16(pconfig, SCLSR, reg_val);
+
+		/* Select internal clock */
+		reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSCR);
+		reg_val &= (uint16_t)(~(SCSCR_CKE1 | SCSCR_CKE0));
+		uart_rcar_write_16(pconfig, SCSCR, reg_val);
+
+		/* Serial Configuration (8N1) & Clock divider selection */
+		reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSMR);
+		reg_val &= (uint16_t)(~(SCSMR_C_A | SCSMR_CKS1 | SCSMR_CKS0));
+
+		/* set parity */
+		if ((uint8_t)UART_CFG_PARITY_NONE == cfg->parity) {
+			/* set Parity Disable */
+			reg_val &= (uint16_t)(~(SCSMR_PE));
+		} else {
+			/* set Parity Enable */
+			reg_val |= (uint16_t)(SCSMR_PE);
+			if ((uint8_t)UART_CFG_PARITY_EVEN == cfg->parity) {
+				/* set EVEN Parity */
+				reg_val &= (uint16_t)(~(SCSMR_O_E));
+			} else { /* UART_CFG_PARITY_ODD */
+				/* set ODD Parity */
+				reg_val |= (uint16_t)(SCSMR_O_E);
+			}
+		}
+
+		/* set Stop bit length */
+		if ((uint8_t)UART_CFG_STOP_BITS_1 == cfg->stop_bits) {
+			/* set 1 stop bit */
+			reg_val &= (uint16_t)(~(SCSMR_STOP));
+		} else { /* UART_CFG_STOP_BITS_2 */
+			/* set 2 stop bits */
+			reg_val |= (uint16_t)(SCSMR_STOP);
+		}
+
+		/* set Character Length */
+		if ((uint8_t)UART_CFG_DATA_BITS_8 == cfg->data_bits) {
+			/* set 8 bits */
+			reg_val &= (uint16_t)(~(SCSMR_CHR));
+		} else { /* UART_CFG_DATA_BITS_7 */
+			/* set 7 bits */
+			reg_val |= (uint16_t)(SCSMR_CHR);
+		}
+
+		uart_rcar_write_16(pconfig, SCSMR, reg_val);
+
+		/* Set baudrate */
+		uart_rcar_set_baudrate(dev, cfg->baudrate);
+
+		/* FIFOs data count trigger configuration */
+		reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCFCR);
+		reg_val &= (uint16_t)(~(SCFCR_RTRG1 | SCFCR_RTRG0 | SCFCR_TTRG1 | SCFCR_TTRG0 |
+				SCFCR_MCE | SCFCR_TFRST | SCFCR_RFRST));
+		uart_rcar_write_16(pconfig, SCFCR, reg_val);
+
+		/* Enable Transmit & Receive + disable Interrupts */
+		reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSCR);
+		reg_val |= (uint16_t)(SCSCR_TE | SCSCR_RE);
+		reg_val &= (uint16_t)(~(SCSCR_TIE | SCSCR_RIE | SCSCR_TEIE | SCSCR_REIE |
+				SCSCR_TOIE));
+		uart_rcar_write_16(pconfig, SCSCR, reg_val);
+
+		pdata->current_config = *cfg;
+
+		k_spin_unlock(&pdata->lock, key_struct);
+	}
+	return ret;
+}
+
+#ifdef CONFIG_UART_USE_RUNTIME_CONFIGURE
+static int uart_rcar_config_get(const struct device * dev,
+				struct uart_config * cfg)
+{
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+	int ret = 0;
+
+	/* Argument NULL check */
+	if (NULL == cfg) {
+		ret = -EINVAL;
+	}
+	else {
+		*cfg = pdata->current_config;
+	}
+
+	return ret;
+}
+#endif /* CONFIG_UART_USE_RUNTIME_CONFIGURE */
+
+static int uart_rcar_init(const struct device * dev)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+	int ret;
+
+	/* Initial PFC */
+	uart_rcar_pfc_init();
+
+	ret = clock_control_on(pconfig->clock_dev,
+					(clock_control_subsys_t *)&pconfig->mod_clk);    /* PRQA S 310 */
+
+	if (0 == ret) {
+		ret = clock_control_get_rate(pconfig->clock_dev,
+						(clock_control_subsys_t *)&pconfig->bus_clk,   /* PRQA S 310 */
+						&pdata->clk_rate);
+	}
+
+	if (0 == ret) {
+		ret = uart_rcar_configure(dev, &pdata->current_config);
+	}
+
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (0 == ret) {
+		pconfig->irq_config_func(dev);
+	}
+#endif
+
+	return ret;
+}
+
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+
+static bool uart_rcar_irq_is_enabled(const struct device * dev, uint32_t irq)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+
+	return !!(uart_rcar_read_16(pconfig, (uint32_t)SCSCR) & irq);
+}
+
+static int uart_rcar_fifo_fill(const struct device * dev,
+					const uint8_t * tx_data,
+					int len)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+	int num_tx = 0;
+	uint16_t reg_val;
+	int ret = 0;
+
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+
+	/* Argument NULL check */
+	if (NULL == tx_data)
+	{
+		ret = -EINVAL;
+	}
+
+	if (0 == ret) {
+		while (((len - num_tx) > 0) &&
+			   (0u != (uart_rcar_read_16(pconfig, (uint32_t)SCFSR) & SCFSR_TDFE))) {
+			/* Send current byte */
+			uart_rcar_write_8(pconfig, SCFTDR, tx_data[num_tx]);
+
+			reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCFSR);
+			reg_val &= (uint16_t)(~(SCFSR_TDFE | SCFSR_TEND));
+			uart_rcar_write_16(pconfig, SCFSR, reg_val);
+
+			num_tx++;
+		}
+		ret = num_tx;
+	}
+
+	k_spin_unlock(&pdata->lock, key_struct);
+
+	return ret;
+}
+
+static int uart_rcar_fifo_read(const struct device * dev, uint8_t * rx_data,
+					const int size)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+	int num_rx = 0;
+	uint16_t reg_val;
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+	int ret = 0;
+
+	/* Argument NULL check */
+	if (NULL == rx_data)
+	{
+		ret = -EINVAL;
+	}
+
+	if (0 == ret) {
+		while (((size - num_rx) > 0) &&
+			   (0u != (uart_rcar_read_16(pconfig, (uint32_t)SCFSR) & SCFSR_RDF))) {
+			/* Receive current byte */
+			rx_data[num_rx++] = (uint8_t)uart_rcar_read_16(pconfig, (uint32_t)SCFRDR);
+
+			reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCFSR);
+			reg_val &= (uint16_t)(~(SCFSR_RDF));
+			uart_rcar_write_16(pconfig, SCFSR, reg_val);
+		}
+		ret = num_rx;
+	}
+
+	k_spin_unlock(&pdata->lock, key_struct);
+
+	return ret;
+}
+
+static void uart_rcar_irq_tx_enable(const struct device * dev)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+
+	uint16_t reg_val;
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+
+	reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSCR);
+	reg_val |= (uint16_t)(SCSCR_TIE);
+	uart_rcar_write_16(pconfig, SCSCR, reg_val);
+
+	k_spin_unlock(&pdata->lock, key_struct);
+}
+
+static void uart_rcar_irq_tx_disable(const struct device * dev)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+
+	uint16_t reg_val;
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+
+	reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSCR);
+	reg_val &= (uint16_t)(~(SCSCR_TIE));
+	uart_rcar_write_16(pconfig, SCSCR, reg_val);
+
+	k_spin_unlock(&pdata->lock, key_struct);
+}
+
+static int uart_rcar_irq_tx_ready(const struct device * dev)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+
+	return !!(uart_rcar_read_16(pconfig, (uint32_t)SCFSR) & SCFSR_TDFE);
+}
+
+static void uart_rcar_irq_rx_enable(const struct device * dev)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+
+	uint16_t reg_val;
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+
+	reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSCR);
+	reg_val |= (uint16_t)(SCSCR_RIE);
+	uart_rcar_write_16(pconfig, SCSCR, reg_val);
+
+	k_spin_unlock(&pdata->lock, key_struct);
+}
+
+static void uart_rcar_irq_rx_disable(const struct device * dev)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+
+	uint16_t reg_val;
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+
+	reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSCR);
+	reg_val &= (uint16_t)(~(SCSCR_RIE));
+	uart_rcar_write_16(pconfig, SCSCR, reg_val);
+
+	k_spin_unlock(&pdata->lock, key_struct);
+}
+
+static int uart_rcar_irq_rx_ready(const struct device * dev)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+
+	return !!(uart_rcar_read_16(pconfig, (uint32_t)SCFSR) & SCFSR_RDF);
+}
+
+static void uart_rcar_irq_err_enable(const struct device * dev)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+
+	uint16_t reg_val;
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+
+	reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSCR);
+	reg_val |= (uint16_t)(SCSCR_REIE);
+	uart_rcar_write_16(pconfig, SCSCR, reg_val);
+
+	k_spin_unlock(&pdata->lock, key_struct);
+}
+
+static void uart_rcar_irq_err_disable(const struct device * dev)
+{
+	const struct uart_rcar_cfg * pconfig = dev->config;   /* PRQA S 317 */
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+
+	uint16_t reg_val;
+	k_spinlock_key_t key_struct = k_spin_lock(&pdata->lock);
+
+	reg_val = uart_rcar_read_16(pconfig, (uint32_t)SCSCR);
+	reg_val &= (uint16_t)(~(SCSCR_REIE));
+	uart_rcar_write_16(pconfig, SCSCR, reg_val);
+
+	k_spin_unlock(&pdata->lock, key_struct);
+}
+
+static int uart_rcar_irq_is_pending(const struct device * dev)
+{
+	return ((uart_rcar_irq_rx_ready(dev) && uart_rcar_irq_is_enabled(dev, (uint32_t)SCSCR_RIE)) ||
+			(uart_rcar_irq_tx_ready(dev) && uart_rcar_irq_is_enabled(dev, (uint32_t)SCSCR_TIE)));
+}
+
+static int uart_rcar_irq_update(const struct device * dev)
+{
+	return 1;
+}
+
+static void uart_rcar_irq_callback_set(const struct device * dev,
+					uart_irq_callback_user_data_t cb,
+					void * cb_data)
+{
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+
+	pdata->callback = cb;
+	pdata->cb_data = cb_data;
+}
+
+/**
+ * @brief Interrupt service routine.
+ *
+ * This simply calls the callback function, if one exists.
+ *
+ * @param arg Argument to ISR.
+ */
+void uart_rcar_isr(const struct device * dev)
+{
+	struct uart_rcar_data * pdata = dev->data;            /* PRQA S 317 */
+
+	if (NULL != pdata->callback) {
+		pdata->callback(dev, pdata->cb_data);
+	}
+}
+
+#endif /* CONFIG_UART_INTERRUPT_DRIVEN */
+
+static void uart_rcar_pfc_init(void)
+{
+	uint32_t drv_data;
+
+	/* GPSR1:Set 0xf to [16:12] */
+	drv_data = sys_read32(RCAR_PFC_GPSR1);
+	drv_data = drv_data | RCAR_PFC_GPSR1_SCIF_ENABLE;
+	sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_GPSR1));
+	sys_write32(drv_data, RCAR_PFC_GPSR1);
+
+	/* IP1SR1:Set 0x1111 to [31:16] */
+	drv_data = sys_read32(RCAR_PFC_IP1SR1);
+	drv_data = (drv_data & RCAR_PFC_IP1SR1_SCIF_CLEAR_MASK) | RCAR_PFC_IP1SR1_SCIF_ENABLE;
+	sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_IP1SR1));
+	sys_write32(drv_data, RCAR_PFC_IP1SR1);
+
+	/* IP2SR1:Set 0x1 to [3:0] */
+	drv_data = sys_read32(RCAR_PFC_IP2SR1);
+	drv_data = (drv_data & RCAR_PFC_IP2SR1_SCIF_CLEAR_MASK) | RCAR_PFC_IP2SR1_SCIF_ENABLE;
+	sys_write32(~drv_data, RCAR_PFC_PMMR(RCAR_PFC_IP2SR1));
+	sys_write32(drv_data, RCAR_PFC_IP2SR1);
+}
+
+static const struct uart_driver_api uart_rcar_driver_api = {
+	.poll_in = &uart_rcar_poll_in,                      /* PRQA S 1053 */
+	.poll_out = &uart_rcar_poll_out,
+#ifdef CONFIG_UART_USE_RUNTIME_CONFIGURE
+	.configure = &uart_rcar_configure,
+	.config_get = &uart_rcar_config_get,
+#endif
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	.fifo_fill = &uart_rcar_fifo_fill,
+	.fifo_read = &uart_rcar_fifo_read,
+	.irq_tx_enable = &uart_rcar_irq_tx_enable,
+	.irq_tx_disable = &uart_rcar_irq_tx_disable,
+	.irq_tx_ready = &uart_rcar_irq_tx_ready,
+	.irq_rx_enable = &uart_rcar_irq_rx_enable,
+	.irq_rx_disable = &uart_rcar_irq_rx_disable,
+	.irq_rx_ready = &uart_rcar_irq_rx_ready,
+	.irq_err_enable = &uart_rcar_irq_err_enable,
+	.irq_err_disable = &uart_rcar_irq_err_disable,
+	.irq_is_pending = &uart_rcar_irq_is_pending,
+	.irq_update = &uart_rcar_irq_update,
+	.irq_callback_set = &uart_rcar_irq_callback_set,
+#endif  /* CONFIG_UART_INTERRUPT_DRIVEN */
+};
+
+/* Device Instantiation */
+#define UART_RCAR_DECLARE_CFG(n, IRQ_FUNC_INIT)				\
+	static const struct uart_rcar_cfg uart_rcar_cfg_##n = {	\
+		.reg_addr = DT_INST_REG_ADDR(n),					\
+		.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),	\
+		.mod_clk.module =									\
+			DT_INST_CLOCKS_CELL_BY_IDX(n, 0, module),		\
+		.mod_clk.domain =									\
+			DT_INST_CLOCKS_CELL_BY_IDX(n, 0, domain),		\
+		.bus_clk.module =									\
+			DT_INST_CLOCKS_CELL_BY_IDX(n, 1, module),		\
+		.bus_clk.domain =									\
+			DT_INST_CLOCKS_CELL_BY_IDX(n, 1, domain),		\
+		IRQ_FUNC_INIT										\
+	}                                                           /* PRQA S 342 */
+
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+#define UART_RCAR_CONFIG_FUNC(n)								\
+	static void irq_config_func_##n(const struct device * dev)	\
+	{						/* PRQA S 342 */					\
+		IRQ_CONNECT(DT_INST_IRQN(n),							\
+				DT_INST_IRQ(n, priority),						\
+				uart_rcar_isr,									\
+				DEVICE_DT_INST_GET(n), 0);						\
+																\
+		irq_enable(DT_INST_IRQN(n));							\
+	}                                                           /* PRQA S 342 */
+#define UART_RCAR_IRQ_CFG_FUNC_INIT(n) \
+	.irq_config_func = irq_config_func_##n                      /* PRQA S 342 */
+#define UART_RCAR_INIT_CFG(n) \
+	UART_RCAR_DECLARE_CFG(n, UART_RCAR_IRQ_CFG_FUNC_INIT(n))
+#else
+#define UART_RCAR_CONFIG_FUNC(n)
+#define UART_RCAR_IRQ_CFG_FUNC_INIT
+#define UART_RCAR_INIT_CFG(n) \
+	UART_RCAR_DECLARE_CFG(n, UART_RCAR_IRQ_CFG_FUNC_INIT)
+#endif
+
+#define UART_RCAR_INIT(n)										\
+	static struct uart_rcar_data uart_rcar_data_##n = {			\
+		.current_config = {										\
+			.baudrate = DT_INST_PROP(n, current_speed),			\
+			.parity = UART_CFG_PARITY_NONE,						\
+			.stop_bits = UART_CFG_STOP_BITS_1,					\
+			.data_bits = UART_CFG_DATA_BITS_8,					\
+			.flow_ctrl = UART_CFG_FLOW_CTRL_NONE,				\
+		},														\
+	};															\
+																\
+	static const struct uart_rcar_cfg uart_rcar_cfg_##n;		\
+																\
+	DEVICE_DT_INST_DEFINE(n,									\
+				uart_rcar_init,									\
+				NULL,											\
+				&uart_rcar_data_##n,							\
+				&uart_rcar_cfg_##n,								\
+				PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,		\
+				&uart_rcar_driver_api);							\
+																\
+	UART_RCAR_CONFIG_FUNC(n)									\
+																\
+	UART_RCAR_INIT_CFG(n);                                      /* PRQA S 342 */
+
+DT_INST_FOREACH_STATUS_OKAY(UART_RCAR_INIT)
diff --git a/drivers/timer/Kconfig.rcar_cmt b/drivers/timer/Kconfig.rcar_cmt
index 999aa3f7d2..2da8ae66c5 100644
--- a/drivers/timer/Kconfig.rcar_cmt
+++ b/drivers/timer/Kconfig.rcar_cmt
@@ -1,12 +1,13 @@
 # Copyright (c) 2014-2015 Wind River Systems, Inc.
 # Copyright (c) 2016 Cadence Design Systems, Inc.
 # Copyright (c) 2019 Intel Corp.
+# Copyright (c) 2022 Renesas Electronics Corporation
 # SPDX-License-Identifier: Apache-2.0
 
 config RCAR_CMT_TIMER
 	bool "Renesas RCar cmt timer"
 	default y
-	depends on SOC_SERIES_RCAR_GEN3
+	depends on SOC_SERIES_RCAR_GEN3 || SOC_SERIES_RCAR_GEN4
 	help
 	  This module implements a kernel device driver for the Renesas RCAR
 	  platform provides the standard "system clock driver" interfaces.
diff --git a/drivers/timer/rcar_cmt_timer.c b/drivers/timer/rcar_cmt_timer.c
index eb20390dad..92f2cb223a 100644
--- a/drivers/timer/rcar_cmt_timer.c
+++ b/drivers/timer/rcar_cmt_timer.c
@@ -19,7 +19,7 @@
 #define CLOCK_SUBSYS           DT_INST_CLOCKS_CELL(0, module)
 
 #define CYCLES_PER_SEC         TIMER_CLOCK_FREQUENCY
-#define CYCLES_PER_TICK        (CYCLES_PER_SEC / CONFIG_SYS_CLOCK_TICKS_PER_SEC)
+#define CYCLES_PER_TICK        (CYCLES_PER_SEC / (CONFIG_SYS_CLOCK_TICKS_PER_SEC / 2))
 
 static struct rcar_cpg_clk mod_clk = {
 	.module = DT_INST_CLOCKS_CELL(0, module),
@@ -37,7 +37,7 @@ BUILD_ASSERT(CYCLES_PER_TICK > 1,
 #define CMCNT1_OFFSET                   0x114   /* counter 1 */
 #define CMCSR1_OFFSET                   0x110   /* control/status register 1 */
 
-#define CMCLKE                          0xB00   /* CLK enable register */
+#define CMCLKE_OFFSET                   0xB00   /* CLK enable register */
 #define CLKEN0                          BIT(5)  /* Enable Clock for channel 0 */
 #define CLKEN1                          BIT(6)  /* Enable Clock for channel 1 */
 
@@ -102,7 +102,9 @@ static int sys_clock_driver_init(const struct device *dev)
 	}
 
 	/* Supply clock for both channels */
-	sys_write32(CLKEN0 | CLKEN1, TIMER_BASE_ADDR + CMCLKE);
+	reg_val = sys_read32(TIMER_BASE_ADDR + CMCLKE_OFFSET);
+	reg_val |= (CLKEN0 | CLKEN1);
+	sys_write32(reg_val, TIMER_BASE_ADDR + CMCLKE_OFFSET);
 
 	/* Stop both channels */
 	reg_val = sys_read32(TIMER_BASE_ADDR + CMSTR0_OFFSET);
diff --git a/dts/arm/renesas/gen4/r8a779g.dtsi b/dts/arm/renesas/gen4/r8a779g.dtsi
new file mode 100644
index 0000000000..0ff6a480b6
--- /dev/null
+++ b/dts/arm/renesas/gen4/r8a779g.dtsi
@@ -0,0 +1,7 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include "rcar_gen4_cr52.dtsi"
diff --git a/dts/arm/renesas/gen4/rcar_gen4_cr52.dtsi b/dts/arm/renesas/gen4/rcar_gen4_cr52.dtsi
new file mode 100644
index 0000000000..78c07e9369
--- /dev/null
+++ b/dts/arm/renesas/gen4/rcar_gen4_cr52.dtsi
@@ -0,0 +1,356 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <mem.h>
+#include <arm64/armv8-r.dtsi>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/renesas_rcar_cpg.h>
+#include <dt-bindings/i2c/i2c.h>
+
+/ {
+	aliases {
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c4 = &i2c4;
+		i2c5 = &i2c5;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-r52";
+			reg = <0>;
+		};
+	};
+
+	soc {
+		sram0: memory@e2100000 {
+			compatible = "mmio-sram";
+			reg = <0xe2100000 0x1B00000>;
+		};
+
+		gic: interrupt-controller@f0000000 {
+			compatible = "arm,gic";
+			reg = <0xf0000000 0x100000>,
+			      <0xf0100000 0x100000>;
+			interrupt-controller;
+			#interrupt-cells = <4>;
+			label = "GIC";
+			status = "okay";
+		};
+
+		cpg: clock-controller@e6150000 {
+			compatible = "renesas,rcar-cpg-mssr";
+			reg = <0xe6150000 0x4000>;
+			#clock-cells = <2>;
+			label = "cpg";
+		};
+
+		scif0: serial@e6e60000 {
+			compatible = "renesas,rcar-scif";
+			reg = <0xe6e60000 0x64>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 251 IRQ_TYPE_LEVEL
+					IRQ_DEFAULT_PRIORITY>;
+			clocks = <&cpg CPG_MOD 702>,
+			<&cpg CPG_CORE CPG_CORE_CLK_S0D12>;
+			current-speed = <115200>;
+			status = "disabled";
+			label = "scif0";
+		};
+
+		cmt0: timer@e60f0500 {
+			compatible = "renesas,rcar-cmt";
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 260 IRQ_TYPE_LEVEL
+					IRQ_DEFAULT_PRIORITY>,
+				     <GIC_SPI 261 IRQ_TYPE_LEVEL
+					IRQ_DEFAULT_PRIORITY>;
+			interrupt-names = "irq_0", "irq_1";
+			reg = <0xe60f0500 0x1004>;
+			clocks = <&cpg CPG_MOD 910>;
+			status = "disabled";
+			label = "cmt0";
+		};
+
+		sysc: syscon@e6180000 {
+			compatible = "syscon";
+			status = "okay";
+			reg = <0xe6180000 0x2000>;
+			label = "SYSC";
+		};
+
+		i2c0: i2c@e6500000 {
+			compatible = "renesas,rcar-i2c";
+			clock-frequency = <I2C_BITRATE_STANDARD>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe6500000 0x40>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 610 IRQ_TYPE_LEVEL
+					IRQ_DEFAULT_PRIORITY>;
+			clocks = <&cpg CPG_MOD 518>;
+			status = "disabled";
+			label = "i2c0";
+			status = "okay";
+		};
+
+		i2c1: i2c@e6508000 {
+			compatible = "renesas,rcar-i2c";
+			clock-frequency = <I2C_BITRATE_STANDARD>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe6508000 0x40>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 611 IRQ_TYPE_LEVEL
+					IRQ_DEFAULT_PRIORITY>;
+			clocks = <&cpg CPG_MOD 519>;
+			status = "disabled";
+			label = "i2c1";
+			status = "okay";
+		};
+
+		i2c4: i2c@e66d8000 {
+			compatible = "renesas,rcar-i2c";
+			clock-frequency = <I2C_BITRATE_STANDARD>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe66d8000 0x40>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 614 IRQ_TYPE_LEVEL
+					IRQ_DEFAULT_PRIORITY>;
+			clocks = <&cpg CPG_MOD 522>;
+			status = "disabled";
+			label = "i2c4";
+			status = "okay";
+		};
+
+		i2c5: i2c@e66e0000 {
+			compatible = "renesas,rcar-i2c";
+			clock-frequency = <I2C_BITRATE_STANDARD>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe66e0000 0x40>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 615 IRQ_TYPE_LEVEL
+					IRQ_DEFAULT_PRIORITY>;
+			clocks = <&cpg CPG_MOD 523>;
+			status = "disabled";
+			label = "i2c5";
+			status = "okay";
+		};
+
+		eth0: ethernet@e6800000 {
+			compatible = "renesas,rcar-eth";
+			reg = <0xe6800000 0x1000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 335 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>,
+						 <GIC_SPI 353 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>,
+						 <GIC_SPI 357 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;
+			clocks = <&cpg CPG_MOD 211>;
+			status = "disabled";
+			label = "eth0";
+			status = "okay";
+		};
+
+		phy0: phy_rcar {
+			compatible = "ethernet-phy-rcar";
+			status = "okay";
+			base_reg = <0xe6800000>;
+			channel = <0>;
+			address = <0>;
+		};
+
+	};
+	power_domain {
+		sysc_a33dga: sysc_a33dga {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a33dga";
+			power-domain-number = <24>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a23dgb: sysc_a23dgb {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a23dgb";
+			power-domain-number = <25>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a1dsp0: sysc_a1dsp0 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a1dsp0";
+			power-domain-number = <33>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a2imp01: sysc_a2imp01 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a2imp01";
+			power-domain-number = <34>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a2psc: sysc_a2psc {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a2psc";
+			power-domain-number = <35>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a2cv0: sysc_a2cv0 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a2cv0";
+			power-domain-number = <36>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a2cv1: sysc_a2cv1 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a2cv1";
+			power-domain-number = <37>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a1cnn0: sysc_a1cnn0 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a1cnn0";
+			power-domain-number = <41>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a2cn0: sysc_a2cn0 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a2cn0";
+			power-domain-number = <42>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a3ir: sysc_a3ir {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a3ir";
+			power-domain-number = <43>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a1dsp1: sysc_a1dsp1 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a1dsp1";
+			power-domain-number = <45>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a2imp23: sysc_a2imp23 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a2imp23";
+			power-domain-number = <46>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a2dma: sysc_a2dma {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a2dma";
+			power-domain-number = <47>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a2cv2: sysc_a2cv2 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a2cv2";
+			power-domain-number = <48>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a2cv3: sysc_a2cv3 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a2cv3";
+			power-domain-number = <49>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a1dsp2: sysc_a1dsp2 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a1dsp2";
+			power-domain-number = <53>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a1dsp3: sysc_a1dsp3 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a1dsp3";
+			power-domain-number = <54>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a3vip0: sysc_a3vip0 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a3vip0";
+			power-domain-number = <56>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a3vip1: sysc_a3vip1 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a3vip1";
+			power-domain-number = <57>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a3vip2: sysc_a3vip2 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a3vip2";
+			power-domain-number = <58>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a3isp0: sysc_a3isp0 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a3isp0";
+			power-domain-number = <60>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a3isp1: sysc_a3isp1 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a3isp1";
+			power-domain-number = <61>;
+			syscon = <&sysc>;
+		};
+
+		sysc_a3dul: sysc_a3dul {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "a3dul";
+			power-domain-number = <62>;
+			syscon = <&sysc>;
+		};
+	};
+};
diff --git a/dts/bindings/ethernet/ethernet-phy-rcar.yaml b/dts/bindings/ethernet/ethernet-phy-rcar.yaml
new file mode 100644
index 0000000000..6dd99bd2bc
--- /dev/null
+++ b/dts/bindings/ethernet/ethernet-phy-rcar.yaml
@@ -0,0 +1,22 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+description: Renesas R-CAR PHY controller
+
+compatible: "ethernet-phy-rcar"
+
+include: phy.yaml
+
+properties:
+    base_reg:
+      type: int
+      required: true
+      description: Base address of EthernetAVB
+    channel:
+      type: int
+      required: true
+      description: Channel number of EthernetAVB (Valid value is from 0 to 2)
+    address:
+      type: int
+      required: true
+      description: PHY address (Valid value for PHYAD[4:0] is from 0 to 31)
diff --git a/dts/bindings/ethernet/renesas,rcar-eth.yaml b/dts/bindings/ethernet/renesas,rcar-eth.yaml
new file mode 100644
index 0000000000..0fbab91b3f
--- /dev/null
+++ b/dts/bindings/ethernet/renesas,rcar-eth.yaml
@@ -0,0 +1,16 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+description: Renesas R-Car ETH controller
+
+compatible: "renesas,rcar-eth"
+
+include: base.yaml
+
+properties:
+    reg:
+      required: true
+    interrupts:
+      required: true
+    clocks:
+      required: true
diff --git a/dts/bindings/power-domain/power-domain-sysc.yaml b/dts/bindings/power-domain/power-domain-sysc.yaml
new file mode 100644
index 0000000000..282d4ea508
--- /dev/null
+++ b/dts/bindings/power-domain/power-domain-sysc.yaml
@@ -0,0 +1,33 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+description: R-Car Gen4 SYSC controlled power domain
+
+compatible: "power-domain-sysc"
+
+include: power-domain.yaml
+
+properties:
+  power-domain-number:
+    type: int
+    required: true
+    default: 0
+    description: Power Domain Register Number (PDR)
+
+  syscon:
+    type: phandle
+    required: true
+    description: |
+      phandle to syscon node.
+
+  reg-check-interval-us:
+    type: int
+    required: false
+    default: 1000
+    description: Register check interval during power control
+
+  reg-check-timeout-us:
+    type: int
+    required: false
+    default: 100000
+    description: Register check timeout during power control
\ No newline at end of file
diff --git a/include/zephyr/arch/arm/aarch32/cortex_a_r/mpu.h b/include/zephyr/arch/arm/aarch32/cortex_a_r/mpu.h
index e660247e4a..f969246bb9 100644
--- a/include/zephyr/arch/arm/aarch32/cortex_a_r/mpu.h
+++ b/include/zephyr/arch/arm/aarch32/cortex_a_r/mpu.h
@@ -1,11 +1,16 @@
 /* SPDX-License-Identifier: Apache-2.0
  *
  * Copyright (c) 2019 Lexmark International, Inc.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  */
 #ifndef ARCH_ARM_CORTEX_R_MPU_H
 #define ARCH_ARM_CORTEX_R_MPU_H 1
 
+#if defined(CONFIG_AARCH32_ARMV8_R)
+#define MPU_RBAR_ADDR_Msk               (~0x3f)
+#else
 #define MPU_RBAR_ADDR_Msk               (~0x1f)
+#endif
 #define MPU_RASR_ENABLE_Msk             (1)
 
 #define MPU_RASR_SIZE_Pos               1U
@@ -32,7 +37,7 @@
 #define MPU_RASR_B_Pos                  0
 #define MPU_RASR_B_Msk                  (1UL << MPU_RASR_B_Pos)
 
-#if defined(CONFIG_CPU_CORTEX_R4) || defined(CONFIG_CPU_CORTEX_R5)
+#if defined(CONFIG_CPU_CORTEX_R4) || defined(CONFIG_CPU_CORTEX_R5) || defined(CONFIG_CPU_CORTEX_R52)
 #define ARM_MPU_REGION_SIZE_32B         ((uint8_t)0x04U)
 #define ARM_MPU_REGION_SIZE_64B         ((uint8_t)0x05U)
 #define ARM_MPU_REGION_SIZE_128B        ((uint8_t)0x06U)
diff --git a/include/zephyr/arch/arm/aarch32/cortex_a_r/scripts/linker.ld b/include/zephyr/arch/arm/aarch32/cortex_a_r/scripts/linker.ld
index 6be9667943..7014d595d7 100644
--- a/include/zephyr/arch/arm/aarch32/cortex_a_r/scripts/linker.ld
+++ b/include/zephyr/arch/arm/aarch32/cortex_a_r/scripts/linker.ld
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013-2014 Wind River Systems, Inc.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -224,6 +225,10 @@ SECTIONS
     __rodata_region_end = .;
     __rom_region_end = .;
     MPU_ALIGN(__rodata_region_end - __rom_region_start);
+#if defined (CONFIG_SOC_SERIES_RCAR_GEN4)
+    __mpu_ram_start = .;
+    __text_rodata_region_size = (__rodata_region_end - __rom_region_start);
+#endif
     _image_rom_end_order = (LOG2CEIL(__rom_region_end) - 1) << 1;
 
     GROUP_END(ROMABLE_REGION)
@@ -341,6 +346,25 @@ SECTIONS
     __kernel_ram_end = RAM_ADDR + RAM_SIZE;
     __kernel_ram_size = __kernel_ram_end - __kernel_ram_start;
 
+#if defined (CONFIG_SOC_SERIES_RCAR_GEN4)
+#if defined (CONFIG_ETH_RCAR)
+    SECTION_DATA_PROLOGUE(eth_rcar,(NOLOAD), ALIGN(32))
+    {
+        . = ALIGN(128);
+        __eth_nc_start = .;
+        *(.eth_non_cache)
+        . = ALIGN(128);
+        __eth_nc_end = .;
+    } GROUP_DATA_LINK_IN(RAMABLE_REGION, RAMABLE_REGION)
+    __eth_nc_size = (__eth_nc_end - __eth_nc_start);
+    __data_bss_region_size1 = (__eth_nc_start - __mpu_ram_start);
+    __data_bss_region_size2 = (__kernel_ram_end - __eth_nc_end);
+#else
+    __data_bss_region_size = (__kernel_ram_end - __mpu_ram_start);
+#endif
+#endif
+
+
     GROUP_END(RAMABLE_REGION)
 
 #if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_ocm), okay)
diff --git a/include/zephyr/arch/arm/aarch32/mpu/arm_mpu.h b/include/zephyr/arch/arm/aarch32/mpu/arm_mpu.h
index d8826111c4..cdad112e7e 100644
--- a/include/zephyr/arch/arm/aarch32/mpu/arm_mpu.h
+++ b/include/zephyr/arch/arm/aarch32/mpu/arm_mpu.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2017 Linaro Limited.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -42,6 +43,10 @@ struct arm_mpu_config {
 	uint32_t num_regions;
 	/* Regions */
 	const struct arm_mpu_region *mpu_regions;
+#if defined(CONFIG_AARCH32_ARMV8_R)
+	uint32_t mair0;
+	uint32_t mair1;
+#endif
 };
 
 #if defined(CONFIG_CPU_AARCH32_CORTEX_R)
diff --git a/include/zephyr/arch/arm/aarch32/mpu/arm_mpu_v7m.h b/include/zephyr/arch/arm/aarch32/mpu/arm_mpu_v7m.h
index 67d90edb15..8c4956b5b5 100644
--- a/include/zephyr/arch/arm/aarch32/mpu/arm_mpu_v7m.h
+++ b/include/zephyr/arch/arm/aarch32/mpu/arm_mpu_v7m.h
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2018 Linaro Limited.
  * Copyright (c) 2018 Nordic Semiconductor ASA.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -79,8 +80,13 @@
 #define SUB_REGION_7_DISABLED	((0x80 << MPU_RASR_SRD_Pos) & MPU_RASR_SRD_Msk)
 
 
+#ifdef CONFIG_SOC_SERIES_RCAR_GEN4
+#define REGION_SIZE(size) (((ARM_MPU_REGION_SIZE_ ## size) \
+	<< MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)
+#else
 #define REGION_SIZE(size) ((ARM_MPU_REGION_SIZE_ ## size \
 	<< MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)
+#endif
 
 #define REGION_32B      REGION_SIZE(32B)
 #define REGION_64B      REGION_SIZE(64B)
diff --git a/include/zephyr/drivers/clock_control.h b/include/zephyr/drivers/clock_control.h
index df357de22b..26a585b3ce 100644
--- a/include/zephyr/drivers/clock_control.h
+++ b/include/zephyr/drivers/clock_control.h
@@ -122,7 +122,7 @@ struct clock_control_driver_api {
 static inline int clock_control_on(const struct device *dev,
 				   clock_control_subsys_t sys)
 {
-	if (!device_is_ready(dev)) {
+	if (!device_is_ready(dev) || sys == NULL) {
 		return -ENODEV;
 	}
 
@@ -145,7 +145,7 @@ static inline int clock_control_on(const struct device *dev,
 static inline int clock_control_off(const struct device *dev,
 				    clock_control_subsys_t sys)
 {
-	if (!device_is_ready(dev)) {
+	if (!device_is_ready(dev) || sys == NULL) {
 		return -ENODEV;
 	}
 
@@ -202,6 +202,10 @@ static inline int clock_control_async_on(const struct device *dev,
 static inline enum clock_control_status clock_control_get_status(const struct device *dev,
 								 clock_control_subsys_t sys)
 {
+	if (!device_is_ready(dev) || sys == NULL) {
+		return CLOCK_CONTROL_STATUS_UNAVAILABLE;
+	}
+
 	const struct clock_control_driver_api *api =
 		(const struct clock_control_driver_api *)dev->api;
 
@@ -209,10 +213,6 @@ static inline enum clock_control_status clock_control_get_status(const struct de
 		return CLOCK_CONTROL_STATUS_UNKNOWN;
 	}
 
-	if (!device_is_ready(dev)) {
-		return CLOCK_CONTROL_STATUS_UNAVAILABLE;
-	}
-
 	return api->get_status(dev, sys);
 }
 
@@ -227,7 +227,7 @@ static inline int clock_control_get_rate(const struct device *dev,
 					 clock_control_subsys_t sys,
 					 uint32_t *rate)
 {
-	if (!device_is_ready(dev)) {
+	if (!device_is_ready(dev) || sys == NULL || rate == NULL) {
 		return -ENODEV;
 	}
 
@@ -261,7 +261,7 @@ static inline int clock_control_set_rate(const struct device *dev,
 		clock_control_subsys_t sys,
 		clock_control_subsys_rate_t rate)
 {
-	if (!device_is_ready(dev)) {
+	if (!device_is_ready(dev) || sys == NULL) {
 		return -ENODEV;
 	}
 
diff --git a/include/zephyr/drivers/clock_control/rcar_clock_control.h b/include/zephyr/drivers/clock_control/rcar_clock_control.h
index 28f7e8abc1..1c5b808909 100644
--- a/include/zephyr/drivers/clock_control/rcar_clock_control.h
+++ b/include/zephyr/drivers/clock_control/rcar_clock_control.h
@@ -3,6 +3,7 @@
  * Copyright (c) 2016 BayLibre, SAS
  * Copyright (c) 2017 Linaro Limited.
  * Copyright (c) 2017 RnDity Sp. z o.o.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -16,6 +17,511 @@ struct rcar_cpg_clk {
 	uint32_t domain;
 	uint32_t module;
 	uint32_t rate;
+#ifdef CONFIG_SOC_SERIES_RCAR_GEN4
+	uint32_t reset_state;
+#endif
 };
 
+#ifdef CONFIG_SOC_SERIES_RCAR_GEN4
+#define CPG_MSTP0_IMPPSC                27u      /* MSTPCR0, MSTPSR0, Bit27 */
+#define CPG_MSTP0_IMPDMAC0              26u      /* MSTPCR0, MSTPSR0, Bit26 */
+#define CPG_MSTP0_IMP1                  25u      /* MSTPCR0, MSTPSR0, Bit25 */
+#define CPG_MSTP0_IMP0                  24u      /* MSTPCR0, MSTPSR0, Bit24 */
+#define CPG_MSTP0_SPMC                  23u      /* MSTPCR0, MSTPSR0, Bit23 */
+#define CPG_MSTP0_IMPCNN                22u      /* MSTPCR0, MSTPSR0, Bit22 */
+#define CPG_MSTP0_ISP1                  17u      /* MSTPCR0, MSTPSR0, Bit17 */
+#define CPG_MSTP0_ISP0                  16u      /* MSTPCR0, MSTPSR0, Bit16 */
+#define CPG_MSTP0_UMFL0                 9u       /* MSTPCR0, MSTPSR0, Bit9 */
+#define CPG_MSTP0_SMPS0                 7u       /* MSTPCR0, MSTPSR0, Bit7 */
+#define CPG_MSTP0_SMPO0                 5u       /* MSTPCR0, MSTPSR0, Bit5 */
+#define CPG_MSTP0_RZX                   0u       /* MSTPCR0, MSTPSR0, Bit0 */
+
+#define CPG_MSTP1_ADVFSC                123u     /* MSTPCR1, MSTPSR1, Bit23 */
+#define CPG_MSTP1_ADG                   122u     /* MSTPCR1, MSTPSR1, Bit22 */
+#define CPG_MSTP1_SPMI                  120u     /* MSTPCR1, MSTPSR1, Bit20 */
+#define CPG_MSTP1_IMPSLV                118u     /* MSTPCR1, MSTPSR1, Bit18 */
+#define CPG_MSTP1_IMPDTA                116u     /* MSTPCR1, MSTPSR1, Bit16 */
+#define CPG_MSTP1_IMPDMAC1              105u     /* MSTPCR1, MSTPSR1, Bit5 */
+#define CPG_MSTP1_IMP3                  104u     /* MSTPCR1, MSTPSR1, Bit4 */
+#define CPG_MSTP1_IMP2                  103u     /* MSTPCR1, MSTPSR1, Bit3 */
+
+#define CPG_MSTP2_AVB2                  213u     /* MSTPCR2, MSTPSR2, Bit13 */
+#define CPG_MSTP2_AVB1                  212u     /* MSTPCR2, MSTPSR2, Bit12 */
+#define CPG_MSTP2_AVB0                  211u     /* MSTPCR2, MSTPSR2, Bit11 */
+
+#define CPG_MSTP3_CSITOP0               331u     /* MSTPCR3, MSTPSR3, Bit31 */
+#define CPG_MSTP3_CSDBGPAP              330u     /* MSTPCR3, MSTPSR3, Bit30 */
+#define CPG_MSTP3_CR0                   329u     /* MSTPCR3, MSTPSR3, Bit29 */
+#define CPG_MSTP3_CCANFD                328u     /* MSTPCR3, MSTPSR3, Bit28 */
+
+#define CPG_MSTP4_DSITXLINK1            416u     /* MSTPCR4, MSTPSR4, Bit16 */
+#define CPG_MSTP4_DSITXLINK0            415u     /* MSTPCR4, MSTPSR4, Bit15 */
+#define CPG_MSTP4_DOC2CH                414u     /* MSTPCR4, MSTPSR4, Bit14 */
+#define CPG_MSTP4_DIS0                  411u     /* MSTPCR4, MSTPSR4, Bit11 */
+#define CPG_MSTP4_DDR3_2                410u     /* MSTPCR4, MSTPSR4, Bit10 ddr3:ddr2 */
+#define CPG_MSTP4_DDR1_0                409u     /* MSTPCR4, MSTPSR4, Bit9 ddr1:ddr0 */
+#define CPG_MSTP4_CSITOP1               400u     /* MSTPCR4, MSTPSR4, Bit0 */
+
+#define CPG_MSTP5_INTAP                 531u     /* MSTPCR5, MSTPSR5, Bit31 */
+#define CPG_MSTP5_IMS1                  530u     /* MSTPCR5, MSTPSR5, Bit30 */
+#define CPG_MSTP5_IMS0                  529u     /* MSTPCR5, MSTPSR5, Bit29 */
+#define CPG_MSTP5_IMR2                  527u     /* MSTPCR5, MSTPSR5, Bit27 */
+#define CPG_MSTP5_IMR1                  526u     /* MSTPCR5, MSTPSR5, Bit26 */
+#define CPG_MSTP5_IMR0                  525u     /* MSTPCR5, MSTPSR5, Bit25 */
+#define CPG_MSTP5_I2C5                  523u     /* MSTPCR5, MSTPSR5, Bit23 */
+#define CPG_MSTP5_I2C4                  522u     /* MSTPCR5, MSTPSR5, Bit22 */
+#define CPG_MSTP5_I2C3                  521u     /* MSTPCR5, MSTPSR5, Bit21 */
+#define CPG_MSTP5_I2C2                  520u     /* MSTPCR5, MSTPSR5, Bit20 */
+#define CPG_MSTP5_I2C1                  519u     /* MSTPCR5, MSTPSR5, Bit19 */
+#define CPG_MSTP5_I2C0                  518u     /* MSTPCR5, MSTPSR5, Bit18 */
+#define CPG_MSTP5_HSCIF3                517u     /* MSTPCR5, MSTPSR5, Bit17 */
+#define CPG_MSTP5_HSCIF2                516u     /* MSTPCR5, MSTPSR5, Bit16 */
+#define CPG_MSTP5_HSCIF1                515u     /* MSTPCR5, MSTPSR5, Bit15 */
+#define CPG_MSTP5_HSCIF0                514u     /* MSTPCR5, MSTPSR5, Bit14 */
+#define CPG_MSTP5_FRAY00                513u     /* MSTPCR5, MSTPSR5, Bit13 */
+#define CPG_MSTP5_FCPVD1                509u     /* MSTPCR5, MSTPSR5, Bit9 */
+#define CPG_MSTP5_FCPVD0                508u     /* MSTPCR5, MSTPSR5, Bit8 */
+#define CPG_MSTP5_FCPCS                 507u     /* MSTPCR5, MSTPSR5, Bit7 */
+
+#define CPG_MSTP6_RTDM1                 631u     /* MSTPCR6, MSTPSR6, Bit31 */
+#define CPG_MSTP6_RTDM0                 630u     /* MSTPCR6, MSTPSR6, Bit30 */
+#define CPG_MSTP6_RPC                   629u     /* MSTPCR6, MSTPSR6, Bit29 */
+#define CPG_MSTP6_PWM                   628u     /* MSTPCR6, MSTPSR6, Bit28 */
+#define CPG_MSTP6_PCIE1                 625u     /* MSTPCR6, MSTPSR6, Bit25 */
+#define CPG_MSTP6_PCIE0                 624u     /* MSTPCR6, MSTPSR6, Bit24 */
+#define CPG_MSTP6_MSI5                  623u     /* MSTPCR6, MSTPSR6, Bit23 */
+#define CPG_MSTP6_MSI4                  622u     /* MSTPCR6, MSTPSR6, Bit22 */
+#define CPG_MSTP6_MSI3                  621u     /* MSTPCR6, MSTPSR6, Bit21 */
+#define CPG_MSTP6_MSI2                  620u     /* MSTPCR6, MSTPSR6, Bit20 */
+#define CPG_MSTP6_MSI1                  619u     /* MSTPCR6, MSTPSR6, Bit19 */
+#define CPG_MSTP6_MSI0                  618u     /* MSTPCR6, MSTPSR6, Bit18 */
+#define CPG_MSTP6_IVCP1E                616u     /* MSTPCR6, MSTPSR6, Bit16 */
+#define CPG_MSTP6_ISPCS1                613u     /* MSTPCR6, MSTPSR6, Bit13 */
+#define CPG_MSTP6_ISPCS0                612u     /* MSTPCR6, MSTPSR6, Bit12 */
+#define CPG_MSTP6_IRQC                  611u     /* MSTPCR6, MSTPSR6, Bit11 */
+#define CPG_MSTP6_INTTP                 608u     /* MSTPCR6, MSTPSR6, Bit8 */
+#define CPG_MSTP6_IPC                   600u     /* MSTPCR6, MSTPSR6, Bit0 */
+
+#define CPG_MSTP7_VIN01                 731u     /* MSTPCR7, MSTPSR7, Bit31 */
+#define CPG_MSTP7_VIN00                 730u     /* MSTPCR7, MSTPSR7, Bit30 */
+#define CPG_MSTP7_VCPL4                 729u     /* MSTPCR7, MSTPSR7, Bit29 */
+#define CPG_MSTP7_TPU0                  718u     /* MSTPCR7, MSTPSR7, Bit18 */
+#define CPG_MSTP7_TMU4                  717u     /* MSTPCR7, MSTPSR7, Bit17 */
+#define CPG_MSTP7_TMU3                  716u     /* MSTPCR7, MSTPSR7, Bit16 */
+#define CPG_MSTP7_TMU2                  715u     /* MSTPCR7, MSTPSR7, Bit15 */
+#define CPG_MSTP7_TMU1                  714u     /* MSTPCR7, MSTPSR7, Bit14 */
+#define CPG_MSTP7_TMU0                  713u     /* MSTPCR7, MSTPSR7, Bit13 */
+#define CPG_MSTP7_SYDM2                 710u     /* MSTPCR7, MSTPSR7, Bit10 */
+#define CPG_MSTP7_SYDM1                 709u     /* MSTPCR7, MSTPSR7, Bit9 */
+#define CPG_MSTP7_SDHI0                 707u     /* MSTPCR7, MSTPSR7, Bit7 */
+#define CPG_MSTP7_SCIF4                 706u     /* MSTPCR7, MSTPSR7, Bit6 */
+#define CPG_MSTP7_SCIF3                 705u     /* MSTPCR7, MSTPSR7, Bit5 */
+#define CPG_MSTP7_SCIF2                 704u     /* MSTPCR7, MSTPSR7, Bit4 */
+#define CPG_MSTP7_SCIF1                 703u     /* MSTPCR7, MSTPSR7, Bit3 */
+#define CPG_MSTP7_SCIF0                 702u     /* MSTPCR7, MSTPSR7, Bit2 */
+#define CPG_MSTP7_RTDM3                 701u     /* MSTPCR7, MSTPSR7, Bit1 */
+#define CPG_MSTP7_RTDM2                 700u     /* MSTPCR7, MSTPSR7, Bit0 */
+
+#define CPG_MSTP8_VSPD1                 831u     /* MSTPCR8, MSTPSR8, Bit31 */
+#define CPG_MSTP8_VSPD0                 830u     /* MSTPCR8, MSTPSR8, Bit30 */
+#define CPG_MSTP8_VIN17                 813u     /* MSTPCR8, MSTPSR8, Bit13 */
+#define CPG_MSTP8_VIN16                 812u     /* MSTPCR8, MSTPSR8, Bit12 */
+#define CPG_MSTP8_VIN15                 811u     /* MSTPCR8, MSTPSR8, Bit11 */
+#define CPG_MSTP8_VIN14                 810u     /* MSTPCR8, MSTPSR8, Bit10 */
+#define CPG_MSTP8_VIN13                 809u     /* MSTPCR8, MSTPSR8, Bit9 */
+#define CPG_MSTP8_VIN12                 808u     /* MSTPCR8, MSTPSR8, Bit8 */
+#define CPG_MSTP8_VIN11                 807u     /* MSTPCR8, MSTPSR8, Bit7 */
+#define CPG_MSTP8_VIN10                 806u     /* MSTPCR8, MSTPSR8, Bit6 */
+#define CPG_MSTP8_VIN07                 805u     /* MSTPCR8, MSTPSR8, Bit5 */
+#define CPG_MSTP8_VIN06                 804u     /* MSTPCR8, MSTPSR8, Bit4 */
+#define CPG_MSTP8_VIN05                 803u     /* MSTPCR8, MSTPSR8, Bit3 */
+#define CPG_MSTP8_VIN04                 802u     /* MSTPCR8, MSTPSR8, Bit2 */
+#define CPG_MSTP8_VIN03                 801u     /* MSTPCR8, MSTPSR8, Bit1 */
+#define CPG_MSTP8_VIN02                 800u     /* MSTPCR8, MSTPSR8, Bit0 */
+
+#define CPG_MSTP9_UCMT                  920u     /* MSTPCR9, MSTPSR9, Bit20 */
+#define CPG_MSTP9_TSC4_1                919u     /* MSTPCR9, MSTPSR9, Bit19 tsc4:tsc3:tsc2:tsc1 */
+#define CPG_MSTP9_PFC3                  918u     /* MSTPCR9, MSTPSR9, Bit18 */
+#define CPG_MSTP9_PFC2                  917u     /* MSTPCR9, MSTPSR9, Bit17 */
+#define CPG_MSTP9_PFC1                  916u     /* MSTPCR9, MSTPSR9, Bit16 */
+#define CPG_MSTP9_PFC0                  915u     /* MSTPCR9, MSTPSR9, Bit15 */
+#define CPG_MSTP9_CMT3                  913u     /* MSTPCR9, MSTPSR9, Bit13 */
+#define CPG_MSTP9_CMT2                  912u     /* MSTPCR9, MSTPSR9, Bit12 */
+#define CPG_MSTP9_CMT1                  911u     /* MSTPCR9, MSTPSR9, Bit11 */
+#define CPG_MSTP9_CMT0                  910u     /* MSTPCR9, MSTPSR9, Bit10 */
+#define CPG_MSTP9_WDT1_0                907u     /* MSTPCR9, MSTPSR9, Bit7 wdt1:wdt0 */
+#define CPG_MSTP9_WCRC3                 906u     /* MSTPCR9, MSTPSR9, Bit6 */
+#define CPG_MSTP9_WCRC2                 905u     /* MSTPCR9, MSTPSR9, Bit5 */
+#define CPG_MSTP9_WCRC1                 904u     /* MSTPCR9, MSTPSR9, Bit4 */
+#define CPG_MSTP9_WCRC0                 903u     /* MSTPCR9, MSTPSR9, Bit3 */
+
+#define CPG_MSTP10_VSPX1                1029u    /* MSTPCR10, MSTPSR10, Bit29 */
+#define CPG_MSTP10_VSPX0                1028u    /* MSTPCR10, MSTPSR10, Bit28 */
+
+#define CPG_MSTP11_AULK4P               1107u    /* MSTPCR11, MSTPSR11, Bit7 */
+#define CPG_MSTP11_AULK2P               1106u    /* MSTPCR11, MSTPSR11, Bit6 */
+#define CPG_MSTP11_FCPVX1               1101u    /* MSTPCR11, MSTPSR11, Bit1 */
+#define CPG_MSTP11_FCPVX0               1100u    /* MSTPCR11, MSTPSR11, Bit0 */
+
+#define CPG_MSTP12_KCRC4                1231u    /* MSTPCR12, MSTPSR12, Bit31 */
+#define CPG_MSTP12_FSO                  1230u    /* MSTPCR12, MSTPSR12, Bit30 */
+#define CPG_MSTP12_CRC3                 1228u    /* MSTPCR12, MSTPSR12, Bit28 */
+#define CPG_MSTP12_CRC2                 1227u    /* MSTPCR12, MSTPSR12, Bit27 */
+#define CPG_MSTP12_CRC1                 1226u    /* MSTPCR12, MSTPSR12, Bit26 */
+#define CPG_MSTP12_CRC0                 1225u    /* MSTPCR12, MSTPSR12, Bit25 */
+#define CPG_MSTP12_ADVFSC               1223u    /* MSTPCR12, MSTPSR12, Bit23 */
+
+#define CPG_MSTP13_MTI                  1304u    /* MSTPCR13, MSTPSR13, Bit4 */
+#define CPG_MSTP13_KCRC7                1302u    /* MSTPCR13, MSTPSR13, Bit2 */
+#define CPG_MSTP13_KCRC6                1301u    /* MSTPCR13, MSTPSR13, Bit1 */
+#define CPG_MSTP13_KCRC5                1300u    /* MSTPCR13, MSTPSR13, Bit0 */
+
+#define CPG_MSTP27_CSBRG_IR_A2          2729u    /* MSTPCR27, MSTPSR27, Bit29 */
+#define CPG_MSTP27_CSBRG_IR_A3          2728u    /* MSTPCR27, MSTPSR27, Bit28 */
+#define CPG_MSTP27_TSN                  2723u    /* MSTPCR27, MSTPSR27, Bit23 */
+#define CPG_MSTP27_IMPSDMAC1            2713u    /* MSTPCR27, MSTPSR27, Bit13 */
+#define CPG_MSTP27_IMPSDMAC0            2712u    /* MSTPCR27, MSTPSR27, Bit12 */
+#define CPG_MSTP27_CVE3                 2709u    /* MSTPCR27, MSTPSR27, Bit9 */
+#define CPG_MSTP27_CVE2                 2708u    /* MSTPCR27, MSTPSR27, Bit8 */
+#define CPG_MSTP27_CVE1                 2707u    /* MSTPCR27, MSTPSR27, Bit7 */
+#define CPG_MSTP27_CVE0                 2706u    /* MSTPCR27, MSTPSR27, Bit6 */
+
+#define CPG_MSTP28_VDSP1_CSB            2830u    /* MSTPCR28, MSTPSR28, Bit30 */
+#define CPG_MSTP28_VDSP0_CSB            2821u    /* MSTPCR28, MSTPSR28, Bit21 */
+#define CPG_MSTP28_DSC                  2819u    /* MSTPCR28, MSTPSR28, Bit19 */
+#define CPG_MSTP28_FCPRC                2817u    /* MSTPCR28, MSTPSR28, Bit17 */
+#define CPG_MSTP28_PAPSDMA              2807u    /* MSTPCR28, MSTPSR28, Bit7 */
+#define CPG_MSTP28_PAPTOP               2806u    /* MSTPCR28, MSTPSR28, Bit6 */
+#define CPG_MSTP28_PAPBUS               2805u    /* MSTPCR28, MSTPSR28, Bit5 */
+#define CPG_MSTP28_VDSP3_BUS            2804u    /* MSTPCR28, MSTPSR28, Bit4 */
+#define CPG_MSTP28_VDSP2_BUS            2803u    /* MSTPCR28, MSTPSR28, Bit3 */
+#define CPG_MSTP28_VDSP1_BUS            2802u    /* MSTPCR28, MSTPSR28, Bit2 */
+#define CPG_MSTP28_VDSP0_BUS            2801u    /* MSTPCR28, MSTPSR28, Bit1 */
+
+#define CPG_MSTP29_SSI                  2927u    /* MSTPCR29, MSTPSR29, Bit27 */
+#define CPG_MSTP29_SSIU                 2926u    /* MSTPCR29, MSTPSR29, Bit26 */
+#define CPG_MSTP29_VDSP3_CSB            2916u    /* MSTPCR29, MSTPSR29, Bit16 */
+#define CPG_MSTP29_VDSP2_CSB            2907u    /* MSTPCR29, MSTPSR29, Bit7 */
+
+#define CPG_SR0_IMPPSC                  27u      /* SRCR0, SRSTCLR0, Bit27 */
+#define CPG_SR0_IMPDMAC0                26u      /* SRCR0, SRSTCLR0, Bit26 */
+#define CPG_SR0_IMP1                    25u      /* SRCR0, SRSTCLR0, Bit25 */
+#define CPG_SR0_IMP0                    24u      /* SRCR0, SRSTCLR0, Bit24 */
+#define CPG_SR0_SPMC                    23u      /* SRCR0, SRSTCLR0, Bit23 */
+#define CPG_SR0_IMPCNN                  22u      /* SRCR0, SRSTCLR0, Bit22 */
+#define CPG_SR0_ISP1                    17u      /* SRCR0, SRSTCLR0, Bit17 */
+#define CPG_SR0_ISP0                    16u      /* SRCR0, SRSTCLR0, Bit16 */
+#define CPG_SR0_ANRT1                   15u      /* SRCR0, SRSTCLR0, Bit15 */
+#define CPG_SR0_UMFL0                   9u       /* SRCR0, SRSTCLR0, Bit9 */
+#define CPG_SR0_SMPS0                   7u       /* SRCR0, SRSTCLR0, Bit7 */
+#define CPG_SR0_SMPO0                   5u       /* SRCR0, SRSTCLR0, Bit5 */
+#define CPG_SR0_RGX                     0u       /* SRCR0, SRSTCLR0, Bit0 */
+
+#define CPG_SR1_ANVI1                   131u     /* SRCR1, SRSTCLR1, Bit31 */
+#define CPG_SR1_ANVI0                   130u     /* SRCR1, SRSTCLR1, Bit30 */
+#define CPG_SR1_ANVC1                   129u     /* SRCR1, SRSTCLR1, Bit29 */
+#define CPG_SR1_ANVC0                   128u     /* SRCR1, SRSTCLR1, Bit28 */
+#define CPG_SR1_ANSP0                   126u     /* SRCR1, SRSTCLR1, Bit26 */
+#define CPG_SR1_ANRT                    125u     /* SRCR1, SRSTCLR1, Bit25 */
+#define CPG_SR1_ANPV0                   124u     /* SRCR1, SRSTCLR1, Bit24 */
+#define CPG_SR1_ADVFSC                  123u     /* SRCR1, SRSTCLR1, Bit23 */
+#define CPG_SR1_ADG                     122u     /* SRCR1, SRSTCLR1, Bit22 */
+#define CPG_SR1_SPMI                    120u     /* SRCR1, SRSTCLR1, Bit20 */
+#define CPG_SR1_IMPSLV                  118u     /* SRCR1, SRSTCLR1, Bit18 */
+#define CPG_SR1_IMPDTA                  116u     /* SRCR1, SRSTCLR1, Bit16 */
+#define CPG_SR1_AXIMP0_AXRS             113u     /* SRCR1, SRSTCLR1, Bit13 aximp0:axrs */
+#define CPG_SR1_AXIMP0                  112u     /* SRCR1, SRSTCLR1, Bit12 */
+#define CPG_SR1_ANIMP1                  111u     /* SRCR1, SRSTCLR1, Bit11 */
+#define CPG_SR1_ANIMP0                  110u     /* SRCR1, SRSTCLR1, Bit10 */
+#define CPG_SR1_IMPDMAC1                105u     /* SRCR1, SRSTCLR1, Bit5 */
+#define CPG_SR1_IMP3                    104u     /* SRCR1, SRSTCLR1, Bit4 */
+#define CPG_SR1_IMP2                    103u     /* SRCR1, SRSTCLR1, Bit3 */
+
+#define CPG_SR2_AXSM_AXRS               231u     /* SRCR2, SRSTCLR2, Bit31 axsm:axrs */
+#define CPG_SR2_AXSD0_1                 230u     /* SRCR2, SRSTCLR2, Bit30 axsd0 */
+#define CPG_SR2_AXSD0_2                 229u     /* SRCR2, SRSTCLR2, Bit29 axsd0 */
+#define CPG_SR2_AXSC                    228u     /* SRCR2, SRSTCLR2, Bit28 */
+#define CPG_SR2_AXRS_AXSC               227u     /* SRCR2, SRSTCLR2, Bit27 axrs:axsc */
+#define CPG_SR2_AXRT_AXRS               225u     /* SRCR2, SRSTCLR2, Bit25 axrt:axrs */
+#define CPG_SR2_AXRT                    224u     /* SRCR2, SRSTCLR2, Bit24 */
+#define CPG_SR2_AXRD_1                  223u     /* SRCR2, SRSTCLR2, Bit23 axrd */
+#define CPG_SR2_AXRD_2                  222u     /* SRCR2, SRSTCLR2, Bit22 axrd */
+#define CPG_SR2_AXRC_1                  221u     /* SRCR2, SRSTCLR2, Bit21 axrc */
+#define CPG_SR2_AXRC_2                  220u     /* SRCR2, SRSTCLR2, Bit20 axrc */
+#define CPG_SR2_AXRS_AXPV               219u     /* SRCR2, SRSTCLR2, Bit19 axrs:axpv */
+#define CPG_SR2_AXPV                    218u     /* SRCR2, SRSTCLR2, Bit18 */
+#define CPG_SR2_ANMM_AXMM               217u     /* SRCR2, SRSTCLR2, Bit17 anmm:axmm */
+#define CPG_SR2_AVB2                    213u     /* SRCR2, SRSTCLR2, Bit13 */
+#define CPG_SR2_AVB1                    212u     /* SRCR2, SRSTCLR2, Bit12 */
+#define CPG_SR2_AVB0                    211u     /* SRCR2, SRSTCLR2, Bit11 */
+#define CPG_SR2_ARMREG                  210u     /* SRCR2, SRSTCLR2, Bit10 */
+#define CPG_SR2_ARMM                    209u     /* SRCR2, SRSTCLR2, Bit9 */
+#define CPG_SR2_APSP3_1                 208u     /* SRCR2, SRSTCLR2, Bit8 apsp3 */
+#define CPG_SR2_APSP3_2                 207u     /* SRCR2, SRSTCLR2, Bit7 apsp3 */
+#define CPG_SR2_APSP4_1                 206u     /* SRCR2, SRSTCLR2, Bit6 apsp4 */
+#define CPG_SR2_APSP4_2                 205u     /* SRCR2, SRSTCLR2, Bit5 apsp4 */
+#define CPG_SR2_APRT0_1                 204u     /* SRCR2, SRSTCLR2, Bit4 aprt0 */
+#define CPG_SR2_APRT0_2                 203u     /* SRCR2, SRSTCLR2, Bit3 aprt0 */
+#define CPG_SR2_ANVIP2                  202u     /* SRCR2, SRSTCLR2, Bit2 */
+#define CPG_SR2_ANVIP1                  201u     /* SRCR2, SRSTCLR2, Bit1 */
+#define CPG_SR2_ANVIP0                  200u     /* SRCR2, SRSTCLR2, Bit0 */
+
+#define CPG_SR3_CSITOP0                 331u     /* SRCR3, SRSTCLR3, Bit31 */
+#define CPG_SR3_CSDBGPAP                330u     /* SRCR3, SRSTCLR3, Bit30 */
+#define CPG_SR3_CR0                     329u     /* SRCR3, SRSTCLR3, Bit29 */
+#define CPG_SR3_CANFD                   328u     /* SRCR3, SRSTCLR3, Bit28 */
+#define CPG_SR3_AXVIP1_1                326u     /* SRCR3, SRSTCLR3, Bit26 axvip1 */
+#define CPG_SR3_AXVIP1_2                325u     /* SRCR3, SRSTCLR3, Bit25 axvip1 */
+#define CPG_SR3_AXVIP0_AXRS             323u     /* SRCR3, SRSTCLR3, Bit23 axvip0:axrs */
+#define CPG_SR3_AXVIP0                  322u     /* SRCR3, SRSTCLR3, Bit22 */
+#define CPG_SR3_AXVIFF                  321u     /* SRCR3, SRSTCLR3, Bit21 */
+#define CPG_SR3_AXVI1                   318u     /* SRCR3, SRSTCLR3, Bit18 */
+#define CPG_SR3_AXVI1_AXRS              317u     /* SRCR3, SRSTCLR3, Bit17 axvi1:axrs */
+#define CPG_SR3_AXVI                    316u     /* SRCR3, SRSTCLR3, Bit16 */
+#define CPG_SR3_AXVC_AXRS               312u     /* SRCR3, SRSTCLR3, Bit12 axvc:axrs */
+#define CPG_SR3_AXVC                    311u     /* SRCR3, SRSTCLR3, Bit11 */
+#define CPG_SR3_AXTBH                   309u     /* SRCR3, SRSTCLR3, Bit9 */
+#define CPG_SR3_AXSTM                   308u     /* SRCR3, SRSTCLR3, Bit8 */
+#define CPG_SR3_AXSTM_AXRS              307u     /* SRCR3, SRSTCLR3, Bit7 axstm:axrs */
+#define CPG_SR3_AXRS_AXSP0              304u     /* SRCR3, SRSTCLR3, Bit4 axrs:axsp0 */
+#define CPG_SR3_AXSP0                   303u     /* SRCR3, SRSTCLR3, Bit3 */
+#define CPG_SR3_AXSN                    302u     /* SRCR3, SRSTCLR3, Bit2 */
+#define CPG_SR3_AXRS_AXSN               301u     /* SRCR3, SRSTCLR3, Bit1 axrs:axsn */
+#define CPG_SR3_AXSM                    300u     /* SRCR3, SRSTCLR3, Bit0 */
+
+#define CPG_SR4_DSITXLINK1              416u     /* SRCR4, SRSTCLR4, Bit16 */
+#define CPG_SR4_DSITXLINK0              415u     /* SRCR4, SRSTCLR4, Bit15 */
+#define CPG_SR4_DOC2CH                  414u     /* SRCR4, SRSTCLR4, Bit14 */
+#define CPG_SR4_DIS0                    411u     /* SRCR4, SRSTCLR4, Bit11 */
+#define CPG_SR4_DDR3_2                  410u     /* SRCR4, SRSTCLR4, Bit10 ddr3:ddr2 */
+#define CPG_SR4_DDR1_0                  409u     /* SRCR4, SRSTCLR4, Bit9 ddr1:ddr0 */
+#define CPG_SR4_CSITOP1                 400u     /* SRCR4, SRSTCLR4, Bit0 */
+
+#define CPG_SR5_INTAP                   531u     /* SRCR5, SRSTCLR5, Bit31 */
+#define CPG_SR5_IMS1                    530u     /* SRCR5, SRSTCLR5, Bit30 */
+#define CPG_SR5_IMS0                    529u     /* SRCR5, SRSTCLR5, Bit29 */
+#define CPG_SR5_IMR2                    527u     /* SRCR5, SRSTCLR5, Bit27 */
+#define CPG_SR5_IMR1                    526u     /* SRCR5, SRSTCLR5, Bit26 */
+#define CPG_SR5_IMR0                    525u     /* SRCR5, SRSTCLR5, Bit25 */
+#define CPG_SR5_I2C5                    523u     /* SRCR5, SRSTCLR5, Bit23 */
+#define CPG_SR5_I2C4                    522u     /* SRCR5, SRSTCLR5, Bit22 */
+#define CPG_SR5_I2C3                    521u     /* SRCR5, SRSTCLR5, Bit21 */
+#define CPG_SR5_I2C2                    520u     /* SRCR5, SRSTCLR5, Bit20 */
+#define CPG_SR5_I2C1                    519u     /* SRCR5, SRSTCLR5, Bit19 */
+#define CPG_SR5_I2C0                    518u     /* SRCR5, SRSTCLR5, Bit18 */
+#define CPG_SR5_HSCIF3                  517u     /* SRCR5, SRSTCLR5, Bit17 */
+#define CPG_SR5_HSCIF2                  516u     /* SRCR5, SRSTCLR5, Bit16 */
+#define CPG_SR5_HSCIF1                  515u     /* SRCR5, SRSTCLR5, Bit15 */
+#define CPG_SR5_HSCIF0                  514u     /* SRCR5, SRSTCLR5, Bit14 */
+#define CPG_SR5_FRAY00                  513u     /* SRCR5, SRSTCLR5, Bit13 */
+#define CPG_SR5_FCPVD1                  509u     /* SRCR5, SRSTCLR5, Bit9 */
+#define CPG_SR5_FCPVD0                  508u     /* SRCR5, SRSTCLR5, Bit8 */
+#define CPG_SR5_FCPCS                   507u     /* SRCR5, SRSTCLR5, Bit7 */
+
+#define CPG_SR6_RTDM1                   631u     /* SRCR6, SRSTCLR6, Bit31 */
+#define CPG_SR6_RTDM0                   630u     /* SRCR6, SRSTCLR6, Bit30 */
+#define CPG_SR6_RPC                     629u     /* SRCR6, SRSTCLR6, Bit29 */
+#define CPG_SR6_PWM                     628u     /* SRCR6, SRSTCLR6, Bit28 */
+#define CPG_SR6_PCIE1                   625u     /* SRCR6, SRSTCLR6, Bit25 */
+#define CPG_SR6_PCIE0                   624u     /* SRCR6, SRSTCLR6, Bit24 */
+#define CPG_SR6_MSI5                    623u     /* SRCR6, SRSTCLR6, Bit23 */
+#define CPG_SR6_MSI4                    622u     /* SRCR6, SRSTCLR6, Bit22 */
+#define CPG_SR6_MSI3                    621u     /* SRCR6, SRSTCLR6, Bit21 */
+#define CPG_SR6_MSI2                    620u     /* SRCR6, SRSTCLR6, Bit20 */
+#define CPG_SR6_MSI1                    619u     /* SRCR6, SRSTCLR6, Bit19 */
+#define CPG_SR6_MSI0                    618u     /* SRCR6, SRSTCLR6, Bit18 */
+#define CPG_SR6_IVCP1E                  616u     /* SRCR6, SRSTCLR6, Bit16 */
+#define CPG_SR6_ISPCS1                  613u     /* SRCR6, SRSTCLR6, Bit13 */
+#define CPG_SR6_ISPCS0                  612u     /* SRCR6, SRSTCLR6, Bit12 */
+#define CPG_SR6_IRQC                    611u     /* SRCR6, SRSTCLR6, Bit11 */
+#define CPG_SR6_INTTP                   608u     /* SRCR6, SRSTCLR6, Bit8 */
+#define CPG_SR6_IPC                     600u     /* SRCR6, SRSTCLR6, Bit0 */
+
+#define CPG_SR7_VIN01                   731u     /* SRCR7, SRSTCLR7, Bit31 */
+#define CPG_SR7_VIN00                   730u     /* SRCR7, SRSTCLR7, Bit30 */
+#define CPG_SR7_VCPL4                   729u     /* SRCR7, SRSTCLR7, Bit29 */
+#define CPG_SR7_TPU0                    718u     /* SRCR7, SRSTCLR7, Bit18 */
+#define CPG_SR7_TMU4                    717u     /* SRCR7, SRSTCLR7, Bit17 */
+#define CPG_SR7_TMU3                    716u     /* SRCR7, SRSTCLR7, Bit16 */
+#define CPG_SR7_TMU2                    715u     /* SRCR7, SRSTCLR7, Bit15 */
+#define CPG_SR7_TMU1                    714u     /* SRCR7, SRSTCLR7, Bit14 */
+#define CPG_SR7_TMU0                    713u     /* SRCR7, SRSTCLR7, Bit13 */
+#define CPG_SR7_SYDM2                   710u     /* SRCR7, SRSTCLR7, Bit10 */
+#define CPG_SR7_SYDM1                   709u     /* SRCR7, SRSTCLR7, Bit9 */
+#define CPG_SR7_SDHI0                   707u     /* SRCR7, SRSTCLR7, Bit7 */
+#define CPG_SR7_SCIF4                   706u     /* SRCR7, SRSTCLR7, Bit6 */
+#define CPG_SR7_SCIF3                   705u     /* SRCR7, SRSTCLR7, Bit5 */
+#define CPG_SR7_SCIF2                   704u     /* SRCR7, SRSTCLR7, Bit4 */
+#define CPG_SR7_SCIF1                   703u     /* SRCR7, SRSTCLR7, Bit3 */
+#define CPG_SR7_SCIF0                   702u     /* SRCR7, SRSTCLR7, Bit2 */
+#define CPG_SR7_RTDM3                   701u     /* SRCR7, SRSTCLR7, Bit1 */
+#define CPG_SR7_RTDM2                   700u     /* SRCR7, SRSTCLR7, Bit0 */
+
+#define CPG_SR8_VSPD1                   831u     /* SRCR8, SRSTCLR8, Bit31 */
+#define CPG_SR8_VSPD0                   830u     /* SRCR8, SRSTCLR8, Bit30 */
+#define CPG_SR8_VIN17                   813u     /* SRCR8, SRSTCLR8, Bit13 */
+#define CPG_SR8_VIN16                   812u     /* SRCR8, SRSTCLR8, Bit12 */
+#define CPG_SR8_VIN15                   811u     /* SRCR8, SRSTCLR8, Bit11 */
+#define CPG_SR8_VIN14                   810u     /* SRCR8, SRSTCLR8, Bit10 */
+#define CPG_SR8_VIN13                   809u     /* SRCR8, SRSTCLR8, Bit9 */
+#define CPG_SR8_VIN12                   808u     /* SRCR8, SRSTCLR8, Bit8 */
+#define CPG_SR8_VIN11                   807u     /* SRCR8, SRSTCLR8, Bit7 */
+#define CPG_SR8_VIN10                   806u     /* SRCR8, SRSTCLR8, Bit6 */
+#define CPG_SR8_VIN07                   805u     /* SRCR8, SRSTCLR8, Bit5 */
+#define CPG_SR8_VIN06                   804u     /* SRCR8, SRSTCLR8, Bit4 */
+#define CPG_SR8_VIN05                   803u     /* SRCR8, SRSTCLR8, Bit3 */
+#define CPG_SR8_VIN04                   802u     /* SRCR8, SRSTCLR8, Bit2 */
+#define CPG_SR8_VIN03                   801u     /* SRCR8, SRSTCLR8, Bit1 */
+#define CPG_SR8_VIN02                   800u     /* SRCR8, SRSTCLR8, Bit0 */
+
+#define CPG_SR9_UCMT                    920u     /* SRCR9, SRSTCLR9, Bit20 */
+#define CPG_SR9_TSC4_1                  919u     /* SRCR9, SRSTCLR9, Bit19 sc4:tsc3:tsc2:tsc1 */
+#define CPG_SR9_PFC3                    918u     /* SRCR9, SRSTCLR9, Bit18 */
+#define CPG_SR9_PFC2                    917u     /* SRCR9, SRSTCLR9, Bit17 */
+#define CPG_SR9_PFC1                    916u     /* SRCR9, SRSTCLR9, Bit16 */
+#define CPG_SR9_PFC0                    915u     /* SRCR9, SRSTCLR9, Bit15 */
+#define CPG_SR9_CMT3                    913u     /* SRCR9, SRSTCLR9, Bit13 */
+#define CPG_SR9_CMT2                    912u     /* SRCR9, SRSTCLR9, Bit12 */
+#define CPG_SR9_CMT1                    911u     /* SRCR9, SRSTCLR9, Bit11 */
+#define CPG_SR9_CMT0                    910u     /* SRCR9, SRSTCLR9, Bit10 */
+#define CPG_SR9_WDT1_0                  907u     /* SRCR9, SRSTCLR9, Bit7 wdt1:wdt0 */
+#define CPG_SR9_WCRC3                   906u     /* SRCR9, SRSTCLR9, Bit6 */
+#define CPG_SR9_WCRC2                   905u     /* SRCR9, SRSTCLR9, Bit5 */
+#define CPG_SR9_WCRC1                   904u     /* SRCR9, SRSTCLR9, Bit4 */
+#define CPG_SR9_WCRC0                   903u     /* SRCR9, SRSTCLR9, Bit3 */
+
+#define CPG_SR10_VSPX1                  1029u    /* SRCR10, SRSTCLR10, Bit29 */
+#define CPG_SR10_VSPX0                  1028u    /* SRCR10, SRSTCLR10, Bit28 */
+#define CPG_SR10_RGXC                   1024u    /* SRCR10, SRSTCLR10, Bit24 */
+#define CPG_SR10_RGXB                   1023u    /* SRCR10, SRSTCLR10, Bit23 */
+
+#define CPG_SR11_SWDT1_0                1128u    /* SRCR11, SRSTCLR11, Bit28 swdt1:swdt0 */
+#define CPG_SR11_RGXPVC                 1126u    /* SRCR11, SRSTCLR11, Bit26 */
+#define CPG_SR11_RGXPVDE                1125u    /* SRCR11, SRSTCLR11, Bit25 */
+#define CPG_SR11_PCIE1                  1122u    /* SRCR11, SRSTCLR11, Bit22 */
+#define CPG_SR11_PCIE0                  1121u    /* SRCR11, SRSTCLR11, Bit21 */
+#define CPG_SR11_INTAP                  1119u    /* SRCR11, SRSTCLR11, Bit19 */
+#define CPG_SR11_FRAY01                 1118u    /* SRCR11, SRSTCLR11, Bit18 */
+#define CPG_SR11_AXVI                   1108u    /* SRCR11, SRSTCLR11, Bit8 */
+#define CPG_SR11_AULK4P                 1107u    /* SRCR11, SRSTCLR11, Bit7 */
+#define CPG_SR11_AULK2P                 1106u    /* SRCR11, SRSTCLR11, Bit6 */
+#define CPG_SR11_FCPVX1                 1101u    /* SRCR11, SRSTCLR11, Bit1 */
+#define CPG_SR11_FCPVX0                 1100u    /* SRCR11, SRSTCLR11, Bit0 */
+
+#define CPG_SR12_FSO                    1230u    /* SRCR12, SRSTCLR12, Bit30 */
+#define CPG_SR12_SCMT                   1222u    /* SRCR12, SRSTCLR12, Bit22 */
+#define CPG_SR12_PFC3_1                 1221u    /* SRCR12, SRSTCLR12, Bit21 pfc3 */
+#define CPG_SR12_PFC3_2                 1220u    /* SRCR12, SRSTCLR12, Bit20 pfc3 */
+#define CPG_SR12_PFC3_3                 1219u    /* SRCR12, SRSTCLR12, Bit19 pfc3 */
+#define CPG_SR12_PFC2_1                 1218u    /* SRCR12, SRSTCLR12, Bit18 pfc2 */
+#define CPG_SR12_PFC2_2                 1217u    /* SRCR12, SRSTCLR12, Bit17 pfc2 */
+#define CPG_SR12_PFC2_3                 1216u    /* SRCR12, SRSTCLR12, Bit16 pfc2 */
+#define CPG_SR12_PFC1_1                 1215u    /* SRCR12, SRSTCLR12, Bit15 pfc1 */
+#define CPG_SR12_PFC1_2                 1214u    /* SRCR12, SRSTCLR12, Bit14 pfc1 */
+#define CPG_SR12_PFC1_3                 1213u    /* SRCR12, SRSTCLR12, Bit13 pfc1 */
+#define CPG_SR12_PFC0_1                 1212u    /* SRCR12, SRSTCLR12, Bit12 pfc0 */
+#define CPG_SR12_PFC0_2                 1211u    /* SRCR12, SRSTCLR12, Bit11 pfc0 */
+#define CPG_SR12_PFC0_3                 1210u    /* SRCR12, SRSTCLR12, Bit10 pfc0 */
+#define CPG_SR12_WWDT9                  1209u    /* SRCR12, SRSTCLR12, Bit9 */
+#define CPG_SR12_WWDT8                  1208u    /* SRCR12, SRSTCLR12, Bit8 */
+#define CPG_SR12_WWDT7                  1207u    /* SRCR12, SRSTCLR12, Bit7 */
+#define CPG_SR12_WWDT6                  1206u    /* SRCR12, SRSTCLR12, Bit6 */
+#define CPG_SR12_WWDT5                  1205u    /* SRCR12, SRSTCLR12, Bit5 */
+#define CPG_SR12_WWDT4                  1204u    /* SRCR12, SRSTCLR12, Bit4 */
+#define CPG_SR12_WWDT3                  1203u    /* SRCR12, SRSTCLR12, Bit3 */
+#define CPG_SR12_WWDT2                  1202u    /* SRCR12, SRSTCLR12, Bit2 */
+#define CPG_SR12_WWDT1                  1201u    /* SRCR12, SRSTCLR12, Bit1 */
+#define CPG_SR12_WWDT0                  1200u    /* SRCR12, SRSTCLR12, Bit0 */
+
+#define CPG_SR13_WWDT9                  1327u    /* SRCR13, SRSTCLR13, Bit27 */
+#define CPG_SR13_WWDT8                  1326u    /* SRCR13, SRSTCLR13, Bit26 */
+#define CPG_SR13_WWDT7                  1325u    /* SRCR13, SRSTCLR13, Bit25 */
+#define CPG_SR13_WWDT6                  1324u    /* SRCR13, SRSTCLR13, Bit24 */
+#define CPG_SR13_WWDT5                  1323u    /* SRCR13, SRSTCLR13, Bit23 */
+#define CPG_SR13_WWDT4                  1322u    /* SRCR13, SRSTCLR13, Bit22 */
+#define CPG_SR13_WWDT3                  1321u    /* SRCR13, SRSTCLR13, Bit21 */
+#define CPG_SR13_WWDT2                  1320u    /* SRCR13, SRSTCLR13, Bit20 */
+#define CPG_SR13_WWDT1                  1319u    /* SRCR13, SRSTCLR13, Bit19 */
+#define CPG_SR13_WWDT0                  1318u    /* SRCR13, SRSTCLR13, Bit18 */
+#define CPG_SR13_DBE                    1311u    /* SRCR13, SRSTCLR13, Bit11 */
+#define CPG_SR13_MTI                    1304u    /* SRCR13, SRSTCLR13, Bit4 */
+
+#define CPG_SR14_CKMMM                  1412u    /* SRCR14, SRSTCLR14, Bit12 */
+#define CPG_SR14_CKMIR                  1411u    /* SRCR14, SRSTCLR14, Bit11 */
+#define CPG_SR14_CKMVIP                 1410u    /* SRCR14, SRSTCLR14, Bit10 */
+#define CPG_SR14_CKMVC                  1409u    /* SRCR14, SRSTCLR14, Bit9 */
+#define CPG_SR14_CKMVIO                 1408u    /* SRCR14, SRSTCLR14, Bit8 */
+#define CPG_SR14_CKMPE0                 1406u    /* SRCR14, SRSTCLR14, Bit6 */
+#define CPG_SR14_CKMRT                  1405u    /* SRCR14, SRSTCLR14, Bit5 */
+#define CPG_SR14_CKM3DG                 1404u    /* SRCR14, SRSTCLR14, Bit4 */
+
+#define CPG_SR15_APVI4_1                1523u    /* SRCR15, SRSTCLR15, Bit23 apvi4 */
+#define CPG_SR15_APVI4_2                1522u    /* SRCR15, SRSTCLR15, Bit22 apvi4 */
+#define CPG_SR15_APVC1_1                1521u    /* SRCR15, SRSTCLR15, Bit21 apvc1 */
+#define CPG_SR15_APVC1_2                1520u    /* SRCR15, SRSTCLR15, Bit20 apvc1 */
+#define CPG_SR15_CKMDSP_CKMIR           1519u    /* SRCR15, SRSTCLR15, Bit19 ckmdsp ckmir */
+#define CPG_SR15_CKMCNR_CKMIR           1518u    /* SRCR15, SRSTCLR15, Bit18 ckmcnr ckmir */
+#define CPG_SR15_CKM                    1517u    /* SRCR15, SRSTCLR15, Bit17 */
+#define CPG_SR15_CKMHSC                 1516u    /* SRCR15, SRSTCLR15, Bit16 */
+#define CPG_SR15_CKMCR52                1515u    /* SRCR15, SRSTCLR15, Bit15 */
+#define CPG_SR15_ANHC                   1503u    /* SRCR15, SRSTCLR15, Bit3 */
+#define CPG_SR15_AXHC_AXRS              1502u    /* SRCR15, SRSTCLR15, Bit2 axhc:axrs */
+#define CPG_SR15_AXHC                   1501u    /* SRCR15, SRSTCLR15, Bit1 */
+
+#define CPG_SR27_CSBRG_IR_A2            2729u    /* SRCR27, SRSTCLR27, Bit29 */
+#define CPG_SR27_CSBRG_IR_A3            2728u    /* SRCR27, SRSTCLR27, Bit28 */
+#define CPG_SR27_TSN                    2723u    /* SRCR27, SRSTCLR27, Bit23 */
+#define CPG_SR27_IMPSDMAC1              2713u    /* SRCR27, SRSTCLR27, Bit13 */
+#define CPG_SR27_IMPSDMAC0              2712u    /* SRCR27, SRSTCLR27, Bit12 */
+#define CPG_SR27_CVE3                   2709u    /* SRCR27, SRSTCLR27, Bit9 */
+#define CPG_SR27_CVE2                   2708u    /* SRCR27, SRSTCLR27, Bit8 */
+#define CPG_SR27_CVE1                   2707u    /* SRCR27, SRSTCLR27, Bit7 */
+#define CPG_SR27_CVE0                   2706u    /* SRCR27, SRSTCLR27, Bit6 */
+
+#define CPG_SR28_VDSP1_REG              2831u    /* SRCR28, SRSTCLR28, Bit31 */
+#define CPG_SR28_VDSP1_CSB              2830u    /* SRCR28, SRSTCLR28, Bit30 */
+#define CPG_SR28_VDSP0_SYSPO            2828u    /* SRCR28, SRSTCLR28, Bit28 */
+#define CPG_SR28_VDSP0_APBDBG           2827u    /* SRCR28, SRSTCLR28, Bit27 */
+#define CPG_SR28_VDSP0_OCEM             2826u    /* SRCR28, SRSTCLR28, Bit26 */
+#define CPG_SR28_VDSP0_CORE             2825u    /* SRCR28, SRSTCLR28, Bit25 */
+#define CPG_SR28_VDSP0_SYS              2824u    /* SRCR28, SRSTCLR28, Bit24 */
+#define CPG_SR28_VDSP0_GLOBAL           2823u    /* SRCR28, SRSTCLR28, Bit23 */
+#define CPG_SR28_VDSP0_REG              2822u    /* SRCR28, SRSTCLR28, Bit22 */
+#define CPG_SR28_VDSP0_CSB              2821u    /* SRCR28, SRSTCLR28, Bit21 */
+#define CPG_SR28_DSC                    2819u    /* SRCR28, SRSTCLR28, Bit19 */
+#define CPG_SR28_FCPRC                  2817u    /* SRCR28, SRSTCLR28, Bit17 */
+#define CPG_SR28_PAPSDMA                2807u    /* SRCR28, SRSTCLR28, Bit7 */
+#define CPG_SR28_PAPTOP                 2806u    /* SRCR28, SRSTCLR28, Bit6 */
+#define CPG_SR28_PAPBUS                 2805u    /* SRCR28, SRSTCLR28, Bit5 */
+#define CPG_SR28_VDSP3_BUS              2804u    /* SRCR28, SRSTCLR28, Bit4 */
+#define CPG_SR28_VDSP2_BUS              2803u    /* SRCR28, SRSTCLR28, Bit3 */
+#define CPG_SR28_VDSP1_BUS              2802u    /* SRCR28, SRSTCLR28, Bit2 */
+#define CPG_SR28_VDSP0_BUS              2801u    /* SRCR28, SRSTCLR28, Bit1 */
+
+#define CPG_SR29_SSI                    2927u    /* SRCR29, SRSTCLR29, Bit27 */
+#define CPG_SR29_SSIU                   2926u    /* SRCR29, SRSTCLR29, Bit26 */
+#define CPG_SR29_VDSP3_SYSPO            2923u    /* SRCR29, SRSTCLR29, Bit23 */
+#define CPG_SR29_VDSP3_APBDBG           2922u    /* SRCR29, SRSTCLR29, Bit22 */
+#define CPG_SR29_VDSP3_OCEM             2921u    /* SRCR29, SRSTCLR29, Bit21 */
+#define CPG_SR29_VDSP3_CORE             2920u    /* SRCR29, SRSTCLR29, Bit20 */
+#define CPG_SR29_VDSP3_SYS              2919u    /* SRCR29, SRSTCLR29, Bit19 */
+#define CPG_SR29_VDSP3_GLOBAL           2918u    /* SRCR29, SRSTCLR29, Bit18 */
+#define CPG_SR29_VDSP3_REG              2917u    /* SRCR29, SRSTCLR29, Bit17 */
+#define CPG_SR29_VDSP3_CSB              2916u    /* SRCR29, SRSTCLR29, Bit16 */
+#define CPG_SR29_VDSP2_SYSPO            2914u    /* SRCR29, SRSTCLR29, Bit14 */
+#define CPG_SR29_VDSP2_APBDBG           2913u    /* SRCR29, SRSTCLR29, Bit13 */
+#define CPG_SR29_VDSP2_OCEM             2912u    /* SRCR29, SRSTCLR29, Bit12 */
+#define CPG_SR29_VDSP2_CORE             2911u    /* SRCR29, SRSTCLR29, Bit11 */
+#define CPG_SR29_VDSP2_SYS              2910u    /* SRCR29, SRSTCLR29, Bit10 */
+#define CPG_SR29_VDSP2_GLOBAL           2909u    /* SRCR29, SRSTCLR29, Bit9 */
+#define CPG_SR29_VDSP2_REG              2908u    /* SRCR29, SRSTCLR29, Bit8 */
+#define CPG_SR29_VDSP2_CSB              2907u    /* SRCR29, SRSTCLR29, Bit7 */
+#define CPG_SR29_VDSP1_SYSPO            2905u    /* SRCR29, SRSTCLR29, Bit5 */
+#define CPG_SR29_VDSP1_APBDBG           2904u    /* SRCR29, SRSTCLR29, Bit4 */
+#define CPG_SR29_VDSP1_OCEM             2903u    /* SRCR29, SRSTCLR29, Bit3 */
+#define CPG_SR29_VDSP1_CORE             2902u    /* SRCR29, SRSTCLR29, Bit2 */
+#define CPG_SR29_VDSP1_SYS              2901u    /* SRCR29, SRSTCLR29, Bit1 */
+#define CPG_SR29_VDSP1_GLOBAL           2900u    /* SRCR29, SRSTCLR29, Bit0 */
+#endif /* CONFIG_SOC_SERIES_RCAR_GEN4 */
+
 #endif /* ZEPHYR_INCLUDE_DRIVERS_CLOCK_CONTROL_RCAR_CLOCK_CONTROL_H_ */
diff --git a/include/zephyr/drivers/i2c.h b/include/zephyr/drivers/i2c.h
index e3866010ef..79eac5217b 100644
--- a/include/zephyr/drivers/i2c.h
+++ b/include/zephyr/drivers/i2c.h
@@ -509,12 +509,17 @@ static inline void i2c_xfer_stats(const struct device *dev, struct i2c_msg *msgs
  *
  * @retval 0 If successful.
  * @retval -EIO General input / output error, failed to configure device.
+ * @retval -ENODEV If argument pointer is null.
  */
 __syscall int i2c_configure(const struct device *dev, uint32_t dev_config);
 
 static inline int z_impl_i2c_configure(const struct device *dev,
 				       uint32_t dev_config)
 {
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct i2c_driver_api *api =
 		(const struct i2c_driver_api *)dev->api;
 
@@ -540,11 +545,16 @@ static inline int z_impl_i2c_configure(const struct device *dev,
  * @retval -EIO General input / output error.
  * @retval -ERANGE Configured I2C frequency is invalid.
  * @retval -ENOSYS If get config is not implemented
+ * @retval -ENODEV If argument pointer is null.
  */
 __syscall int i2c_get_config(const struct device *dev, uint32_t *dev_config);
 
 static inline int z_impl_i2c_get_config(const struct device *dev, uint32_t *dev_config)
 {
+	if (!device_is_ready(dev) || dev_config == NULL) {
+		return -ENODEV;
+	}
+
 	const struct i2c_driver_api *api = (const struct i2c_driver_api *)dev->api;
 
 	if (api->get_config == NULL) {
@@ -580,6 +590,7 @@ static inline int z_impl_i2c_get_config(const struct device *dev, uint32_t *dev_
  *
  * @retval 0 If successful.
  * @retval -EIO General input / output error.
+ * @retval -ENODEV If argument pointer is null.
  */
 __syscall int i2c_transfer(const struct device *dev,
 			   struct i2c_msg *msgs, uint8_t num_msgs,
@@ -589,6 +600,10 @@ static inline int z_impl_i2c_transfer(const struct device *dev,
 				      struct i2c_msg *msgs, uint8_t num_msgs,
 				      uint16_t addr)
 {
+	if (!device_is_ready(dev) || msgs == NULL) {
+		return -ENODEV;
+	}
+
 	const struct i2c_driver_api *api =
 		(const struct i2c_driver_api *)dev->api;
 
@@ -629,11 +644,16 @@ static inline int i2c_transfer_dt(const struct i2c_dt_spec *spec,
  * @retval -EBUSY If bus is not clear after recovery attempt.
  * @retval -EIO General input / output error.
  * @retval -ENOSYS If bus recovery is not implemented
+ * @retval -ENODEV If argument pointer is null.
  */
 __syscall int i2c_recover_bus(const struct device *dev);
 
 static inline int z_impl_i2c_recover_bus(const struct device *dev)
 {
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct i2c_driver_api *api =
 		(const struct i2c_driver_api *)dev->api;
 
@@ -773,12 +793,17 @@ static inline int z_impl_i2c_slave_driver_unregister(const struct device *dev)
  *
  * @retval 0 If successful.
  * @retval -EIO General input / output error.
+ * @retval -ENODEV If argument pointer is null.
  */
 static inline int i2c_write(const struct device *dev, const uint8_t *buf,
 			    uint32_t num_bytes, uint16_t addr)
 {
 	struct i2c_msg msg;
 
+	if (!device_is_ready(dev) || buf == NULL) {
+		return -ENODEV;
+	}
+
 	msg.buf = (uint8_t *)buf;
 	msg.len = num_bytes;
 	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
@@ -818,12 +843,17 @@ static inline int i2c_write_dt(const struct i2c_dt_spec *spec,
  *
  * @retval 0 If successful.
  * @retval -EIO General input / output error.
+ * @retval -ENODEV If argument pointer is null.
  */
 static inline int i2c_read(const struct device *dev, uint8_t *buf,
 			   uint32_t num_bytes, uint16_t addr)
 {
 	struct i2c_msg msg;
 
+	if (!device_is_ready(dev) || buf == NULL) {
+		return -ENODEV;
+	}
+
 	msg.buf = buf;
 	msg.len = num_bytes;
 	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
@@ -874,6 +904,10 @@ static inline int i2c_write_read(const struct device *dev, uint16_t addr,
 {
 	struct i2c_msg msg[2];
 
+	if (!device_is_ready(dev) || write_buf == NULL || read_buf == NULL) {
+		return -ENODEV;
+	}
+
 	msg[0].buf = (uint8_t *)write_buf;
 	msg[0].len = num_write;
 	msg[0].flags = I2C_MSG_WRITE;
@@ -928,6 +962,7 @@ static inline int i2c_write_read_dt(const struct i2c_dt_spec *spec,
  *
  * @retval 0 If successful.
  * @retval -EIO General input / output error.
+ * @retval -ENODEV If argument pointer is null.
  */
 static inline int i2c_burst_read(const struct device *dev,
 				 uint16_t dev_addr,
@@ -983,6 +1018,7 @@ static inline int i2c_burst_read_dt(const struct i2c_dt_spec *spec,
  *
  * @retval 0 If successful.
  * @retval -EIO General input / output error.
+ * @retval -ENODEV If argument pointer is null.
  */
 static inline int i2c_burst_write(const struct device *dev,
 				  uint16_t dev_addr,
@@ -992,6 +1028,10 @@ static inline int i2c_burst_write(const struct device *dev,
 {
 	struct i2c_msg msg[2];
 
+	if (!device_is_ready(dev) || buf == NULL) {
+		return -ENODEV;
+	}
+
 	msg[0].buf = &start_addr;
 	msg[0].len = 1U;
 	msg[0].flags = I2C_MSG_WRITE;
@@ -1040,6 +1080,7 @@ static inline int i2c_burst_write_dt(const struct i2c_dt_spec *spec,
  *
  * @retval 0 If successful.
  * @retval -EIO General input / output error.
+ * @retval -ENODEV If argument pointer is null.
  */
 static inline int i2c_reg_read_byte(const struct device *dev,
 				    uint16_t dev_addr,
@@ -1086,6 +1127,7 @@ static inline int i2c_reg_read_byte_dt(const struct i2c_dt_spec *spec,
  *
  * @retval 0 If successful.
  * @retval -EIO General input / output error.
+ * @retval -ENODEV If argument pointer is null.
  */
 static inline int i2c_reg_write_byte(const struct device *dev,
 				     uint16_t dev_addr,
diff --git a/include/zephyr/drivers/uart.h b/include/zephyr/drivers/uart.h
index 231f49cd3c..c494fd9c49 100644
--- a/include/zephyr/drivers/uart.h
+++ b/include/zephyr/drivers/uart.h
@@ -509,12 +509,18 @@ static inline int z_impl_uart_err_check(const struct device *dev)
  *            input buffer was empty).
  * @retval -ENOSYS If the operation is not implemented.
  * @retval -EBUSY If async reception was enabled using @ref uart_rx_enable
+ * @retval -ENODEV If dev is null.
+ * @retval -EINVAL If p_char is null.
  */
 __syscall int uart_poll_in(const struct device *dev, unsigned char *p_char);
 
 static inline int z_impl_uart_poll_in(const struct device *dev,
 				      unsigned char *p_char)
 {
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -585,6 +591,10 @@ __syscall void uart_poll_out(const struct device *dev,
 static inline void z_impl_uart_poll_out(const struct device *dev,
 					unsigned char out_char)
 {
+	if (!device_is_ready(dev)) {
+		return;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -637,6 +647,8 @@ static inline void z_impl_uart_poll_out_u16(const struct device *dev,
  * @retval -errno Negative errno code in case of failure.
  * @retval -ENOSYS If configuration is not supported by device
  *                  or driver does not support setting configuration in runtime.
+ * @retval -ENODEV If dev is null.
+ * @retval -EINVAL If cfg is null.
  */
 __syscall int uart_configure(const struct device *dev,
 			     const struct uart_config *cfg);
@@ -644,6 +656,10 @@ __syscall int uart_configure(const struct device *dev,
 static inline int z_impl_uart_configure(const struct device *dev,
 					const struct uart_config *cfg)
 {
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct uart_driver_api *api =
 				(const struct uart_driver_api *)dev->api;
 
@@ -665,6 +681,8 @@ static inline int z_impl_uart_configure(const struct device *dev,
  * @retval 0 If successful.
  * @retval -errno Negative errno code in case of failure.
  * @retval -ENOSYS If driver does not support getting current configuration.
+ * @retval -ENODEV If dev is null.
+ * @retval -EINVAL If cfg is null.
  */
 __syscall int uart_config_get(const struct device *dev,
 			      struct uart_config *cfg);
@@ -672,6 +690,10 @@ __syscall int uart_config_get(const struct device *dev,
 static inline int z_impl_uart_config_get(const struct device *dev,
 					 struct uart_config *cfg)
 {
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct uart_driver_api *api =
 				(const struct uart_driver_api *)dev->api;
 
@@ -706,12 +728,18 @@ static inline int z_impl_uart_config_get(const struct device *dev,
  * @return Number of bytes sent.
  * @retval -ENOSYS  if this function is not supported
  * @retval -ENOTSUP If API is not enabled.
+ * @retval -ENODEV  If dev is null.
+ * @retval -EINVAL  If tx_data is null.
  */
 static inline int uart_fifo_fill(const struct device *dev,
 				 const uint8_t *tx_data,
 				 int size)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -792,11 +820,17 @@ static inline int uart_fifo_fill_u16(const struct device *dev,
  * @return Number of bytes read.
  * @retval -ENOSYS If this function is not implemented.
  * @retval -ENOTSUP If API is not enabled.
+ * @retval -ENODEV If dev is null.
+ * @retval -EINVAL If rx_data is null.
  */
 static inline int uart_fifo_read(const struct device *dev, uint8_t *rx_data,
 				 const int size)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -868,6 +902,10 @@ __syscall void uart_irq_tx_enable(const struct device *dev);
 static inline void z_impl_uart_irq_tx_enable(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -889,6 +927,10 @@ __syscall void uart_irq_tx_disable(const struct device *dev);
 static inline void z_impl_uart_irq_tx_disable(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -917,10 +959,15 @@ static inline void z_impl_uart_irq_tx_disable(const struct device *dev)
  * @retval 0 If device is not ready to write a new byte.
  * @retval -ENOSYS If this function is not implemented.
  * @retval -ENOTSUP If API is not enabled.
+ * @retval -ENODEV If dev is null.
  */
 static inline int uart_irq_tx_ready(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -945,6 +992,10 @@ __syscall void uart_irq_rx_enable(const struct device *dev);
 static inline void z_impl_uart_irq_rx_enable(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -966,6 +1017,10 @@ __syscall void uart_irq_rx_disable(const struct device *dev);
 static inline void z_impl_uart_irq_rx_disable(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -1031,10 +1086,15 @@ static inline int uart_irq_tx_complete(const struct device *dev)
  * @retval 0 If a received char is not ready.
  * @retval -ENOSYS If this function is not implemented.
  * @retval -ENOTSUP If API is not enabled.
+ * @retval -ENODEV If dev is null.
  */
 static inline int uart_irq_rx_ready(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -1057,6 +1117,10 @@ __syscall void uart_irq_err_enable(const struct device *dev);
 static inline void z_impl_uart_irq_err_enable(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -1078,6 +1142,10 @@ __syscall void uart_irq_err_disable(const struct device *dev);
 static inline void z_impl_uart_irq_err_disable(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -1098,12 +1166,17 @@ static inline void z_impl_uart_irq_err_disable(const struct device *dev)
  * @retval 0 If an IRQ is not pending.
  * @retval -ENOSYS If this function is not implemented.
  * @retval -ENOTSUP If API is not enabled.
+ * @retval -ENODEV If dev is null.
  */
 __syscall int uart_irq_is_pending(const struct device *dev);
 
 static inline int z_impl_uart_irq_is_pending(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -1141,12 +1214,17 @@ static inline int z_impl_uart_irq_is_pending(const struct device *dev)
  * @retval 1 On success.
  * @retval -ENOSYS If this function is not implemented.
  * @retval -ENOTSUP If API is not enabled.
+ * @retval -ENODEV If dev is null.
  */
 __syscall int uart_irq_update(const struct device *dev);
 
 static inline int z_impl_uart_irq_update(const struct device *dev)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
@@ -1176,6 +1254,10 @@ static inline void uart_irq_callback_user_data_set(const struct device *dev,
 						   void *user_data)
 {
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	if (!device_is_ready(dev)) {
+		return;
+	}
+
 	const struct uart_driver_api *api =
 		(const struct uart_driver_api *)dev->api;
 
diff --git a/include/zephyr/dt-bindings/clock/renesas_rcar_cpg.h b/include/zephyr/dt-bindings/clock/renesas_rcar_cpg.h
index f6dcf039ce..240ef19e34 100644
--- a/include/zephyr/dt-bindings/clock/renesas_rcar_cpg.h
+++ b/include/zephyr/dt-bindings/clock/renesas_rcar_cpg.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2021 IoT.bzh
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -7,10 +8,48 @@
 #ifndef ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_RENESAS_RCAR_CPG_MSSR_H_
 #define ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_RENESAS_RCAR_CPG_MSSR_H_
 
-#define CPG_CORE                        0       /* Core Clock */
-#define CPG_MOD                         1       /* Module Clock */
+#define CPG_CORE                        0UL       /* Core Clock */
+#define CPG_MOD                         1UL       /* Module Clock */
+#define CPG_RESET                       2UL       /* Software Reset */
+#define CPG_DIVISION_RATIO              3UL       /* Division Ratio */
 
-#define CPG_CORE_CLK_CANFD              0       /* CANFD clock */
-#define CPG_CORE_CLK_S3D4               1       /* S3D4 Clock */
+#ifdef CONFIG_SOC_SERIES_RCAR_GEN4
+/**
+ * @enum    r_cpg_ClockName_t
+ * @brief   List of clock name
+ */
+typedef enum {
+	R_CPG_ZS_CLOCK,                 /* ZS Clock     */
+	R_CPG_ZT_CLOCK,                 /* ZT Clock     */
+	R_CPG_ZTR_CLOCK,                /* ZTR Clock    */
+	R_CPG_Z0_CLOCK,                 /* Z0 Clock     */
+	R_CPG_ZB3_ZB3D2_ZB3D4_CLOCK,    /* ZB3,ZB3D2,ZB3D4 Clock    */
+	R_CPG_ZG_CLOCK,                 /* ZG Clock     */
+	R_CPG_SDSRC_CLOCK,              /* SDSRC Clock  */
+	R_CPG_SD0H_CLOCK,               /* SD0H Clock   */
+	R_CPG_SD0_CLOCK,                /* SD0 Clock    */
+	R_CPG_RPC_CLOCK,                /* RPC Clock    */
+	R_CPG_RPCD2_CLOCK,              /* RPCD2 Clock  */
+	R_CPG_MSO_CLOCK,                /* MSO Clock    */
+	R_CPG_CANFD_CLOCK,              /* CANFD Clock  */
+	R_CPG_CSI_CLOCK,                /* CSI Clock    */
+	R_CPG_POST2_CLOCK,              /* POST2 Clock  */
+	R_CPG_POST3_CLOCK,              /* POST3 Clock  */
+	R_CPG_POST4_CLOCK,              /* POST4 Clock  */
+	R_CPG_POST_CLOCK,               /* POST Clock   */
+	R_CPG_DSIEXT_CLOCK,             /* DSIEXT Clock */
+	R_CPG_ZR0_CLOCK,                /* ZR0 Clock    */
+	R_CPG_ZR1_CLOCK,                /* ZR1 Clock    */
+	R_CPG_ZR2_CLOCK,                /* ZR2 Clock    */
+	R_CPG_CLOCK_LAST
+} r_cpg_ClockName_t;
+
+#define CPG_CORE_CLK_S0D12              2UL       /* S0D12 Clock */
+
+#else /* CONFIG_SOC_SERIES_RCAR_GEN3 */
+#define CPG_CORE_CLK_CANFD              0UL       /* CANFD clock */
+#define CPG_CORE_CLK_S3D4               1UL       /* S3D4 Clock */
+#define CPG_CORE_CLK_S0D12              2UL       /* S0D12 Clock */
+#endif
 
 #endif /* ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_RENESAS_RCAR_CPG_MSSR_H_ */
diff --git a/include/zephyr/pm/device.h b/include/zephyr/pm/device.h
index 0aaed82096..cdb14d95f0 100644
--- a/include/zephyr/pm/device.h
+++ b/include/zephyr/pm/device.h
@@ -326,6 +326,7 @@ const char *pm_device_state_str(enum pm_device_state state);
  *
  * @retval 0 If successful.
  * @retval -ENOSYS If device does not implement power management.
+ * @retval -ENODEV If dev or state is null.
  */
 int pm_device_state_get(const struct device *dev,
 			enum pm_device_state *state);
diff --git a/include/zephyr/pm/device_runtime.h b/include/zephyr/pm/device_runtime.h
index 4d8be4163a..49b906ea40 100644
--- a/include/zephyr/pm/device_runtime.h
+++ b/include/zephyr/pm/device_runtime.h
@@ -36,6 +36,7 @@ extern "C" {
  * @retval -EPERM If device has power state locked.
  * @retval -ENOTSUP If the device does not support PM.
  * @retval -ENOSYS If the functionality is not available.
+ * @retval -ENODEV  If dev is null.
  * @retval -errno Other negative errno, result of suspending the device.
  *
  * @see pm_device_init_suspended()
@@ -76,6 +77,7 @@ int pm_device_runtime_disable(const struct device *dev);
  * @retval 0 If it succeeds. In case device runtime PM is not enabled or not
  * available this function will be a no-op and will also return 0.
  * @retval -ENOTSUP If the device does not support PM.
+ * @retval -ENODEV  If dev is null.
  * @retval -errno Other negative errno, result of the PM action callback.
  */
 int pm_device_runtime_get(const struct device *dev);
@@ -96,6 +98,7 @@ int pm_device_runtime_get(const struct device *dev);
  * available this function will be a no-op and will also return 0.
  * @retval -ENOTSUP If the device does not support PM.
  * @retval -EALREADY If device is already suspended (can only happen if get/put
+ * @retval -ENODEV  If dev is null.
  * calls are unbalanced).
  * @retval -errno Other negative errno, result of the action callback.
  *
diff --git a/include/zephyr/posix/sys/socket.h b/include/zephyr/posix/sys/socket.h
index 4a5979857f..4482f8747e 100644
--- a/include/zephyr/posix/sys/socket.h
+++ b/include/zephyr/posix/sys/socket.h
@@ -23,6 +23,11 @@ static inline int socketpair(int family, int type, int proto, int sv[2])
 	return zsock_socketpair(family, type, proto, sv);
 }
 
+static inline int close(int sock)
+{
+	return zsock_close(sock);
+}
+
 #define SHUT_RD ZSOCK_SHUT_RD
 #define SHUT_WR ZSOCK_SHUT_WR
 #define SHUT_RDWR ZSOCK_SHUT_RDWR
diff --git a/include/zephyr/toolchain/gcc.h b/include/zephyr/toolchain/gcc.h
index 86aeed2cd6..3e0896395e 100644
--- a/include/zephyr/toolchain/gcc.h
+++ b/include/zephyr/toolchain/gcc.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2010-2014,2017 Wind River Systems, Inc.
+ * Copyright (c) 2022 Renesas Electronics Corporation
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -392,11 +393,19 @@ do {                                                                    \
 #else /* !CONFIG_ARC */
 
 #define SECTION_VAR(sect, sym)  .section .sect.sym; sym:
+#if defined(__ARMCOMPILER_VERSION)
+#define SECTION_FUNC(sect, sym)						\
+	.section .sect.sym, "ax";					\
+				FUNC_CODE();				\
+				PERFOPT_ALIGN; sym:		\
+							FUNC_INSTR(sym)
+#else
 #define SECTION_FUNC(sect, sym)						\
 	.section .sect.sym, "ax";					\
 				FUNC_CODE()				\
 				PERFOPT_ALIGN; sym :		\
 							FUNC_INSTR(sym)
+#endif
 #define SECTION_SUBSEC_FUNC(sect, subsec, sym)				\
 		.section .sect.subsec, "ax"; PERFOPT_ALIGN; sym :
 
diff --git a/soc/arm/renesas_rcar/gen4/CMakeLists.txt b/soc/arm/renesas_rcar/gen4/CMakeLists.txt
new file mode 100644
index 0000000000..ba6eafc495
--- /dev/null
+++ b/soc/arm/renesas_rcar/gen4/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+zephyr_sources(soc.c)
+
+zephyr_library_sources_ifdef(CONFIG_ARM_MPU arm_mpu_regions.c)
diff --git a/soc/arm/renesas_rcar/gen4/Kconfig.defconfig.series b/soc/arm/renesas_rcar/gen4/Kconfig.defconfig.series
new file mode 100644
index 0000000000..fb07627ebb
--- /dev/null
+++ b/soc/arm/renesas_rcar/gen4/Kconfig.defconfig.series
@@ -0,0 +1,44 @@
+# Renesas R-Car Gen4 SoC line
+
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+if SOC_SERIES_RCAR_GEN4
+
+config SOC_SERIES
+	default "gen4"
+
+config NUM_IRQS
+	default 960
+
+config SYSCON
+	default y
+
+config PM
+	default y
+
+config PM_DEVICE
+	default y
+
+config PM_DEVICE_RUNTIME
+	default y
+
+config PM_DEVICE_POWER_DOMAIN
+	default y
+
+config POWER_DOMAIN
+	default y
+
+config POWER_DOMAIN_SYSC
+	default y
+
+config I2C
+	default y
+
+config I2C_RCAR
+	default y
+
+config ETH_RCAR
+	default n
+
+endif # SOC_SERIES_RCAR_GEN4
diff --git a/soc/arm/renesas_rcar/gen4/Kconfig.series b/soc/arm/renesas_rcar/gen4/Kconfig.series
new file mode 100644
index 0000000000..8c1a7fc01f
--- /dev/null
+++ b/soc/arm/renesas_rcar/gen4/Kconfig.series
@@ -0,0 +1,9 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+config SOC_SERIES_RCAR_GEN4
+	bool "Renesas RCAR Gen4 Cortex R52 Series"
+	select ARM
+	select SOC_FAMILY_RCAR
+	help
+	  Enable support for Renesas RCar Gen4 SoC series
diff --git a/soc/arm/renesas_rcar/gen4/Kconfig.soc b/soc/arm/renesas_rcar/gen4/Kconfig.soc
new file mode 100644
index 0000000000..149672f142
--- /dev/null
+++ b/soc/arm/renesas_rcar/gen4/Kconfig.soc
@@ -0,0 +1,17 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+choice
+	prompt "Renesas RCar SoC Selection"
+	depends on SOC_SERIES_RCAR_GEN4
+
+config SOC_R8A779G
+	bool "R8A779G"
+	select CPU_CORTEX_R52
+	select CPU_HAS_ARM_MPU
+	select GIC_V3
+	select GIC_SINGLE_SECURITY_STATE
+	select PLATFORM_SPECIFIC_INIT
+	select CLOCK_CONTROL_RCAR_CPG_MSSR if CLOCK_CONTROL
+
+endchoice
diff --git a/soc/arm/renesas_rcar/gen4/arm_mpu_regions.c b/soc/arm/renesas_rcar/gen4/arm_mpu_regions.c
new file mode 100644
index 0000000000..b82450cb6d
--- /dev/null
+++ b/soc/arm/renesas_rcar/gen4/arm_mpu_regions.c
@@ -0,0 +1,92 @@
+/* SPDX-License-Identifier: Apache-2.0
+ *
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ */
+
+#include <kernel.h>
+#include <arch/arm/aarch32/mpu/arm_mpu.h>
+
+	/* AttrIndx=000 xx SH=00 AP=11 XN=0 */
+#define ATTR_RO_C_B \
+	{ \
+		.rasr = 0x0006	\
+	}
+	/* AttrIndx=000 xx SH=00 AP=01 XN=1 */
+#define ATTR_RW_C_B \
+	{ \
+		.rasr = 0x0003	\
+	}
+	/* AttrIndx=001 xx SH=00 AP=01 XN=1 */
+#define ATTR_RW_NC \
+	{ \
+		.rasr = 0x0103	\
+	}
+
+	/* AttrIndx=002 xx SH=00 AP=01 XN=1 */
+#define ATTR_RW_DV \
+	{ \
+		.rasr = 0x0203	\
+	}
+
+
+extern uint32_t __mpu_ram_start;
+extern uint32_t __text_rodata_region_size;
+#ifdef CONFIG_ETH_RCAR
+extern uint32_t __data_bss_region_size1;
+extern uint32_t __eth_nc_start;
+extern uint32_t __eth_nc_size;
+extern uint32_t __eth_nc_end;
+extern uint32_t __data_bss_region_size2;
+#else
+extern uint32_t __data_bss_region_size;
+#endif
+static const struct arm_mpu_region mpu_regions[] = {
+	MPU_REGION_ENTRY("VECTOR",                      /* PRQA S 1053 */
+			0x00000000,
+			256*1024,
+			ATTR_RO_C_B),
+
+	MPU_REGION_ENTRY("IO1",
+			0xc0000000,
+			0x22000000,
+			ATTR_RW_DV),
+
+	MPU_REGION_ENTRY("IO2",
+			0xe4300000,
+			0x1bd00000,
+			ATTR_RW_DV),
+
+	MPU_REGION_ENTRY("RTVRAM_EXEC",
+			0xe2100000,
+			((uint32_t)&__text_rodata_region_size),
+			ATTR_RO_C_B),
+
+#ifdef CONFIG_ETH_RCAR
+	MPU_REGION_ENTRY("RTVRAM1",
+			((uint32_t)&__mpu_ram_start),
+			(uint32_t)&__data_bss_region_size1,
+			ATTR_RW_C_B),
+
+	MPU_REGION_ENTRY("ETH_NC",
+			((uint32_t)&__eth_nc_start),
+			(uint32_t)&__eth_nc_size,
+			ATTR_RW_NC),
+
+	MPU_REGION_ENTRY("RTVRAM2",
+			((uint32_t)&__eth_nc_end),
+			(uint32_t)&__data_bss_region_size2,
+			ATTR_RW_C_B),
+#else
+	MPU_REGION_ENTRY("RTVRAM",
+			((uint32_t)&__mpu_ram_start),
+			(uint32_t)&__data_bss_region_size,
+			ATTR_RW_C_B),
+#endif
+};
+
+const struct arm_mpu_config mpu_config = {
+	.num_regions = ARRAY_SIZE(mpu_regions),         /* PRQA S 1053 */
+	.mpu_regions = mpu_regions,
+	.mair0 = 0x000044FF,
+	.mair1 = 0x00000000,
+};
diff --git a/soc/arm/renesas_rcar/gen4/linker.ld b/soc/arm/renesas_rcar/gen4/linker.ld
new file mode 100644
index 0000000000..00a6fc9541
--- /dev/null
+++ b/soc/arm/renesas_rcar/gen4/linker.ld
@@ -0,0 +1,7 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <arch/arm/aarch32/cortex_a_r/scripts/linker.ld>
diff --git a/soc/arm/renesas_rcar/gen4/soc.c b/soc/arm/renesas_rcar/gen4/soc.c
new file mode 100644
index 0000000000..dcaca700ba
--- /dev/null
+++ b/soc/arm/renesas_rcar/gen4/soc.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ */
+
+#include <kernel.h>
+#include <device.h>
+#include <init.h>
+
+static int soc_init(const struct device *arg);
+
+/**
+ *
+ * @brief Perform basic hardware initialization
+ *
+ * @return 0
+ */
+
+static int soc_init(const struct device *arg)
+{
+	ARG_UNUSED(arg);
+
+	/* Install default handler that simply resets the CPU
+	 * if configured in the kernel, NOP otherwise
+	 */
+	NMI_INIT();
+	return 0;
+}
+
+void z_arm_platform_init(void)
+{
+	L1C_DisableCaches();
+	L1C_DisableBTAC();
+
+	/* Invalidate instruction cache and flush branch target cache */
+	__set_ICIALLU(0);
+	__DSB();
+	__ISB();
+
+	L1C_EnableCaches();
+	L1C_EnableBTAC();
+}
+
+SYS_INIT(soc_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
diff --git a/soc/arm/renesas_rcar/gen4/soc.h b/soc/arm/renesas_rcar/gen4/soc.h
new file mode 100644
index 0000000000..001dcbba51
--- /dev/null
+++ b/soc/arm/renesas_rcar/gen4/soc.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ */
+
+#ifndef _SOC__H_
+#define _SOC__H_
+
+/* Define CMSIS configurations */
+#define __CR_REV      1U
+
+/* Do not let CMSIS to handle GIC and Timer */
+#define __GIC_PRESENT 0
+#define __TIM_PRESENT 0
+
+#endif /* _SOC__H_ */
diff --git a/subsys/pm/device.c b/subsys/pm/device.c
index 443c7f8637..93d2eeb0cf 100644
--- a/subsys/pm/device.c
+++ b/subsys/pm/device.c
@@ -214,7 +214,13 @@ void pm_device_children_action_run(const struct device *dev,
 int pm_device_state_get(const struct device *dev,
 			enum pm_device_state *state)
 {
-	struct pm_device *pm = dev->pm;
+	struct pm_device *pm;
+
+	if (!device_is_ready(dev) || state == NULL) {
+		return -ENODEV;
+	}
+
+	pm = dev->pm;
 
 	if (pm == NULL) {
 		return -ENOSYS;
diff --git a/subsys/pm/device_runtime.c b/subsys/pm/device_runtime.c
index 496d9655c7..3843ccce22 100644
--- a/subsys/pm/device_runtime.c
+++ b/subsys/pm/device_runtime.c
@@ -117,7 +117,13 @@ static void runtime_suspend_work(struct k_work *work)
 int pm_device_runtime_get(const struct device *dev)
 {
 	int ret = 0;
-	struct pm_device *pm = dev->pm;
+	struct pm_device *pm;
+
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
+	pm = dev->pm;
 
 	if (pm == NULL) {
 		return -ENOTSUP;
@@ -179,6 +185,10 @@ int pm_device_runtime_put(const struct device *dev)
 {
 	int ret;
 
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
 	if (dev->pm == NULL) {
 		return -ENOTSUP;
 	}
@@ -215,7 +225,13 @@ int pm_device_runtime_put_async(const struct device *dev)
 int pm_device_runtime_enable(const struct device *dev)
 {
 	int ret = 0;
-	struct pm_device *pm = dev->pm;
+	struct pm_device *pm;
+
+	if (!device_is_ready(dev)) {
+		return -ENODEV;
+	}
+
+	pm = dev->pm;
 
 	if (pm == NULL) {
 		return -ENOTSUP;
diff --git a/tests/arch/arm/cache_sample/CMakeLists.txt b/tests/arch/arm/cache_sample/CMakeLists.txt
new file mode 100644
index 0000000000..06c9ca3e8a
--- /dev/null
+++ b/tests/arch/arm/cache_sample/CMakeLists.txt
@@ -0,0 +1,13 @@
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.20.0)
+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
+project(arm_cache_sample)
+
+target_include_directories(app PRIVATE
+  ${ZEPHYR_BASE}/kernel/include
+  ${ZEPHYR_BASE}/arch/${ARCH}/include
+)
+
+FILE(GLOB app_sources src/*.c)
+target_sources(app PRIVATE ${app_sources})
diff --git a/tests/arch/arm/cache_sample/prj.conf b/tests/arch/arm/cache_sample/prj.conf
new file mode 100644
index 0000000000..9467c29268
--- /dev/null
+++ b/tests/arch/arm/cache_sample/prj.conf
@@ -0,0 +1 @@
+CONFIG_ZTEST=y
diff --git a/tests/arch/arm/cache_sample/src/dmac.c b/tests/arch/arm/cache_sample/src/dmac.c
new file mode 100644
index 0000000000..919e8a5e3a
--- /dev/null
+++ b/tests/arch/arm/cache_sample/src/dmac.c
@@ -0,0 +1,57 @@
+
+#include <zephyr/zephyr.h>
+#include <zephyr/sys/sys_io.h>
+
+/* RTDMAC */
+#define RTDMAC0_REG_BASE		(0xFFC10000U)	/* RT-DMAC0 */
+#define RTDMACP0_REG_BASE		(0xFFD60000U)	/* RT-DMAC0 Port Controller */
+
+#define	RTDMAC0_RDMOR			(RTDMACP0_REG_BASE + 0x0060U)	/* DMA operation register for RT-DMAC0 */
+#define	RTDMAC0_RDMCHCLR(ch)	(RTDMAC0_REG_BASE + ((uint32_t)(ch << 12U)) + 0x0100U)	/* DMA channel clear register for RT-DMAC0 Channel n */
+#define	RTDMAC0_RDMSAR(ch)		(RTDMAC0_REG_BASE + ((uint32_t)(ch << 12U)) + 0x0000U)	/* DMA source address register for RT-DMAC0 Channel n */
+#define	RTDMAC0_RDMDAR(ch)		(RTDMAC0_REG_BASE + ((uint32_t)(ch << 12U)) + 0x0004U)	/* DMA destination address register for RT-DMAC0 Channel n */
+#define	RTDMAC0_RDMTCR(ch)		(RTDMAC0_REG_BASE + ((uint32_t)(ch << 12U)) + 0x0008U)	/* DMA transfer count register for RT-DMAC0 Channel n */
+#define	RTDMAC0_RDMCHCR(ch)		(RTDMAC0_REG_BASE + ((uint32_t)(ch << 12U)) + 0x000CU)	/* DMA channel control register for RT-DMAC0 Channel n */
+#define	RTDMAC0_RDMDMRS(ch)		(RTDMAC0_REG_BASE + ((uint32_t)(ch << 12U)) + 0x0040U)	/* DMA extended resource selector for RT-DMAC0 Channel n */
+#define	RTDMAC0_RDMREGIONID(ch)	(RTDMAC0_REG_BASE + ((uint32_t)(ch << 12U)) + 0x0078U)	/* DMA region id register for RT-DMAC0 Channel n */
+
+void dmac_exec(uint32_t src_addr, uint32_t dst_addr, uint32_t transfer_count)
+{
+	/* config set */
+	sys_write32(1U, RTDMAC0_RDMCHCLR(0U));
+	sys_write32(src_addr, RTDMAC0_RDMSAR(0U));
+	sys_write32(dst_addr, RTDMAC0_RDMDAR(0U));
+	sys_write32(transfer_count, RTDMAC0_RDMTCR(0U));
+
+	/* DMA Start */
+	sys_write32(0x00105409U, RTDMAC0_RDMCHCR(0)); /* 64Byte/AutoRequest mode */
+	sys_write16(0x0301U, RTDMAC0_RDMOR); /* Start DMA */
+}
+
+int dmac_wait(void)
+{
+	uint32_t data;
+	uint32_t reg;
+
+	/* DMA transfer complite check */
+	while (1) {
+		data = sys_read32(RTDMAC0_RDMCHCR(0));
+		if ((data & BIT(1)) != 0U) {
+			reg = sys_read32(RTDMAC0_RDMCHCR(0));
+			reg &= ~BIT(1); /* TE Clear */
+			sys_write32(reg, RTDMAC0_RDMCHCR(0));
+			break;
+		}
+
+		if ((data & BIT(31)) != 0U) {
+			reg = sys_read32(RTDMAC0_RDMCHCR(0));
+			reg &= ~BIT(31); /* CAE Clear */
+			sys_write32(reg, RTDMAC0_RDMCHCR(0));
+			return 1;
+		}
+	}
+
+	sys_write16(0x0000U, RTDMAC0_RDMOR); /* 0: Disables DMA transfers on all channels */
+
+	return 0;
+}
diff --git a/tests/arch/arm/cache_sample/src/main.c b/tests/arch/arm/cache_sample/src/main.c
new file mode 100644
index 0000000000..e06d3e1752
--- /dev/null
+++ b/tests/arch/arm/cache_sample/src/main.c
@@ -0,0 +1,165 @@
+
+#include <zephyr/zephyr.h>
+#include <ztest.h>
+#include <zephyr/cache.h>
+#include <stdio.h>
+#include <string.h>
+
+#define CACHE_LINE_SIZE 64U
+#define CACHE_LINE_SIZE_PER_DATA_SIZE (CACHE_LINE_SIZE / sizeof(uint32_t))
+#define DMAC_TRANSFER_UNIT_SIZE 64U
+
+extern void dmac_exec(uint32_t src_addr, uint32_t dst_addr, uint32_t transfer_count);
+extern int dmac_wait(void);
+
+static const uint32_t __attribute__ ((aligned(128))) cache_test_data[256] = {
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000,
+	0x11111111, 0x22222222, 0x33333333, 0x44444444,	0x55555555, 0x66666666, 0x77777777, 0x88888888,
+	0x99999999, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC,	0xDDDDDDDD, 0xEEEEEEEE, 0xFFFFFFFF, 0x00000000
+};
+
+void cache_sample(void)
+{
+	int ret = 0;
+	int cnt;
+	size_t line_size;
+	uint32_t * func = (uint32_t *)cache_sample;
+	uint32_t aligned_func_addr = (uint32_t)func & ~(CACHE_LINE_SIZE - 1U);
+	uint32_t __attribute__ ((aligned(128))) src_data[256] = {0};
+	uint32_t __attribute__ ((aligned(128))) dst_data[256] = {0};
+
+	line_size = cache_data_line_size_get();
+	printf("cache_data_line_size_get return: %d\n", line_size);
+
+	line_size = cache_instr_line_size_get();
+	printf("cache_instr_line_size_get return: %d\n", line_size);
+	printf("\n");
+
+	printf("Dump test data [Address:0x%08X] [Size:%dbyte]", (uint32_t)cache_test_data, sizeof(cache_test_data));
+	for (int cnt = 0; cnt < (sizeof(cache_test_data) / sizeof(uint32_t)); cnt++) {
+		if (0 == (cnt % 8)) {
+			printf("\n0x%08X | ", (uint32_t)&cache_test_data[cnt]);
+		}
+		printf("0x%08X ", cache_test_data[cnt]);
+	}
+	printf("\n\n");
+
+	/* memcpy */
+	printf("Execute memcpy[Size:%dbyte] from test data[Address:0x%08X] to source data[Address:0x%08X].\n",
+		sizeof(cache_test_data), (uint32_t)cache_test_data, (uint32_t)src_data);
+	memcpy((void *)src_data, (void *)cache_test_data, sizeof(cache_test_data));
+	printf("\n");
+
+	/* d-cache flush */
+	printf("Execute d-cache flush all.\n");
+	ret = cache_data_all(K_CACHE_WB);
+	printf("cache_data_all(K_CACHE_WB) return: %d\n", ret);
+	printf("\n");
+
+	/* DMA transfer */
+	printf("Execute DMA transfer[Size:%dbyte] from source data[Address:0x%08X] to destination data[Address:0x%08X].\n",
+		sizeof(src_data), (uint32_t)src_data, (uint32_t)dst_data);
+	dmac_exec((uint32_t)&src_data[0], (uint32_t)&dst_data[0], (sizeof(src_data) / DMAC_TRANSFER_UNIT_SIZE));
+	ret = dmac_wait();
+	if (0 != ret) {
+		printf("DMA error detected!!\n");
+	}
+	printf("\n");
+
+	/* d-cache invalidate range*/
+	printf("Execute d-cache invalidate range.\n");
+	printf("Invalidate 128 bytes.\n");
+	ret = cache_data_range((void *)&dst_data[0], (CACHE_LINE_SIZE * 2U), K_CACHE_INVD);
+	printf("cache_data_range(0x%08X, %d, K_CACHE_INVD) return: %d\n",
+		(uint32_t)&dst_data[0], (CACHE_LINE_SIZE * 2U), ret);
+	printf("\n");
+
+	printf("Dump destination data [Address:0x%08X] [Size:%dbyte]", (uint32_t)dst_data, sizeof(dst_data));
+	for (cnt = 0; cnt < (sizeof(dst_data) / sizeof(uint32_t)); cnt++) {
+		if (0 == (cnt % 8)) {
+			printf("\n0x%08X | ", (uint32_t)&dst_data[cnt]);
+		}
+		printf("0x%08X ", dst_data[cnt]);
+	}
+	printf("\n\n");
+
+	for (cnt = 0; cnt < (CACHE_LINE_SIZE_PER_DATA_SIZE * 2U); cnt++) {
+		if (dst_data[cnt] != cache_test_data[cnt]) {
+			printf("Comparison result of source data and destination data: NG\n");
+		}
+	}
+
+	/* d-cache invalidate all */
+	printf("Execute d-cache invalidate all.\n");
+	ret = cache_data_all(K_CACHE_INVD);
+	printf("cache_data_all(K_CACHE_INVD) return: %d\n", ret);
+	printf("\n");
+
+	printf("Dump destination data [Address:0x%08X] [Size:%dbyte]", (uint32_t)dst_data, sizeof(dst_data));
+	for (cnt = 0; cnt < (sizeof(dst_data) / sizeof(uint32_t)); cnt++) {
+		if (0 == (cnt % 8)) {
+			printf("\n0x%08X | ", (uint32_t)&dst_data[cnt]);
+		}
+		printf("0x%08X ", dst_data[cnt]);
+	}
+	printf("\n\n");
+
+	for (cnt = 0; cnt < (sizeof(dst_data) / sizeof(uint32_t)); cnt++) {
+		if (dst_data[cnt] != cache_test_data[cnt]) {
+			printf("Comparison result of source data and destination data: NG\n");
+		}
+	}
+
+	/* i-cache invalidate range */
+	printf("Execute i-cache invalidate range.\n");
+	printf("Invalidate 64 bytes from aligned adrress.\n");
+	printf("Invalidate adrress: 0x%08X\n", aligned_func_addr);
+	ret = cache_instr_range((void *)aligned_func_addr, CACHE_LINE_SIZE, K_CACHE_INVD);
+	printf("Only the return value of the API is confirmed because the i-cache memory cannot be confirmed in the log.\n");
+	printf("cache_instr_range(0x%08X, %d, K_CACHE_INVD) return: %d\n", aligned_func_addr, CACHE_LINE_SIZE, ret);
+	printf("\n");
+
+	/* i-cache invalidate all */
+	printf("Execute i-cache invalidate all.\n");
+	ret = cache_instr_all(K_CACHE_INVD);
+	printf("Only the return value of the API is confirmed because the i-cache memory cannot be confirmed in the log.\n");
+	printf("cache_instr_all(K_CACHE_INVD) return: %d\n", ret);
+	printf("\n");
+}
+
+void test_main(void)
+{
+	ztest_test_suite(arm_cache,
+			 ztest_user_unit_test(cache_sample)
+			 );
+	ztest_run_test_suite(arm_cache);
+}
diff --git a/tests/arch/arm/cache_sample/testcase.yaml b/tests/arch/arm/cache_sample/testcase.yaml
new file mode 100644
index 0000000000..312cdeb5b2
--- /dev/null
+++ b/tests/arch/arm/cache_sample/testcase.yaml
@@ -0,0 +1,5 @@
+tests:
+  arch.arm.cache.syscalls:
+    arch_allow: arm
+    filter: CONFIG_CPU_AARCH32_CORTEX_R and CONFIG_ARCH_HAS_USERSPACE
+    tags: arm userspace
diff --git a/tests/drivers/clock_control/cpg_sample/CMakeLists.txt b/tests/drivers/clock_control/cpg_sample/CMakeLists.txt
new file mode 100644
index 0000000000..291b08d300
--- /dev/null
+++ b/tests/drivers/clock_control/cpg_sample/CMakeLists.txt
@@ -0,0 +1,10 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.20.0)
+
+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
+project(cpg_sample)
+
+FILE(GLOB app_sources src/*.c)
+target_sources(app PRIVATE ${app_sources})
diff --git a/tests/drivers/clock_control/cpg_sample/prj.conf b/tests/drivers/clock_control/cpg_sample/prj.conf
new file mode 100644
index 0000000000..9467c29268
--- /dev/null
+++ b/tests/drivers/clock_control/cpg_sample/prj.conf
@@ -0,0 +1 @@
+CONFIG_ZTEST=y
diff --git a/tests/drivers/clock_control/cpg_sample/src/main.c b/tests/drivers/clock_control/cpg_sample/src/main.c
new file mode 100644
index 0000000000..c231ae4f4d
--- /dev/null
+++ b/tests/drivers/clock_control/cpg_sample/src/main.c
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/zephyr.h>
+#include <ztest.h>
+
+extern void test_clock_control(void);
+
+void test_main(void)
+{
+	ztest_test_suite(cpg_test,
+			ztest_unit_test(test_clock_control));
+	ztest_run_test_suite(cpg_test);
+}
diff --git a/tests/drivers/clock_control/cpg_sample/src/test_clock_control.c b/tests/drivers/clock_control/cpg_sample/src/test_clock_control.c
new file mode 100644
index 0000000000..cf6934050f
--- /dev/null
+++ b/tests/drivers/clock_control/cpg_sample/src/test_clock_control.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/zephyr.h>
+#include <zephyr/drivers/clock_control.h>
+#include <zephyr/drivers/clock_control/rcar_clock_control.h>
+
+void test_clock_control(void)
+{
+	const struct device *dev = DEVICE_DT_GET(DT_NODELABEL(cpg));
+	int ret = 0;
+	struct rcar_cpg_clk setup1 = {
+		.domain = CPG_MOD,
+		.module = 0,
+		.rate = 0,
+		.reset_state = 0,
+	};
+	clock_control_subsys_t sub_system1 = (clock_control_subsys_t)&setup1;
+
+	struct rcar_cpg_clk setup2 = {
+		.domain = CPG_RESET,
+		.module = 0,
+		.rate = 0,
+		.reset_state = 0,
+	};
+	clock_control_subsys_t sub_system2 = (clock_control_subsys_t)&setup2;
+
+	struct rcar_cpg_clk setup3 = {
+		.domain = CPG_CORE,
+		.module = 0,
+		.rate = 0,
+		.reset_state = 0,
+	};
+	clock_control_subsys_t sub_system3 = (clock_control_subsys_t)&setup3;
+
+	int get_ratio = 0;
+	int set_ratio = 0;
+	struct rcar_cpg_clk setup4 = {
+		.domain = CPG_DIVISION_RATIO,
+		.module = 0,
+		.rate = 0,
+		.reset_state = 0,
+	};
+	clock_control_subsys_t sub_system4 = (clock_control_subsys_t)&setup4;
+
+	/**************************************************************************/
+	/* Confirmation of Module Stop */
+	/**************************************************************************/
+	printk("Confirmation of Module Stop\n");
+	setup1.module = CPG_MSTP7_SCIF1; /* MSTPCR7, MSTPSR7, Bit3 */
+	/* get module status */
+	ret = clock_control_get_status(dev, sub_system1);
+	printk("module:%d, get_module_status:0x%x\n", setup1.module, ret);
+
+	/* set module disable. In other words, enable Module Stop. */
+	ret = clock_control_off(dev, sub_system1);
+	printk("module:%d, set module disable\n", setup1.module);
+
+	/* get module status */
+	ret = clock_control_get_status(dev, sub_system1);
+	printk("module:%d, get_module_status:0x%x\n", setup1.module, ret);
+
+	/* set module enable. In other words, disable Module Stop. */
+	ret = clock_control_on(dev, sub_system1);
+	printk("module:%d, set module enable\n", setup1.module);
+
+	/* get module status */
+	ret = clock_control_get_status(dev, sub_system1);
+	printk("module:%d, get_module_status:0x%x\n", setup1.module, ret);
+
+	/**************************************************************************/
+	/* Confirmation of Software Reset */
+	/**************************************************************************/
+	printk("\nConfirmation of Software Reset\n");
+	setup2.module = CPG_SR7_SCIF1; /* SRCR7, SRSTCLR7, Bit3 */
+	/* get reset module status */
+	ret = clock_control_get_status(dev, sub_system2);
+	printk("module:%d, get_reset_status:0x%x\n", setup2.module, ret);
+
+	/* set reset module */
+	setup2.reset_state = 1;
+	ret = clock_control_off(dev, sub_system2);
+	printk("module:%d, set reset state:1\n", setup2.module);
+
+	/* get reset module status */
+	ret = clock_control_get_status(dev, sub_system2);
+	printk("module:%d, get_reset_status:0x%x\n", setup2.module, ret);
+
+	/* Wait at least 1ms */
+	k_sleep(K_MSEC(1));
+
+	/* clear reset module */
+	setup2.reset_state = 0;
+	ret = clock_control_off(dev, sub_system2);
+	printk("module:%d, set reset state:0\n", setup2.module);
+
+	/* get reset module status */
+	ret = clock_control_get_status(dev, sub_system2);
+	printk("module:%d, get_reset_status:0x%x\n", setup2.module, ret);
+
+	/**************************************************************************/
+	/* Confirmation of Clock Stop */
+	/**************************************************************************/
+	printk("\nConfirmation of Clock Stop\n");
+	setup3.module = R_CPG_CANFD_CLOCK;
+	/* get clock status */
+	ret = clock_control_get_status(dev, sub_system3);
+	printk("module:%d, get clock status:0x%x\n", setup3.module, ret);
+
+	/* set clock disable */
+	ret = clock_control_off(dev, sub_system3);
+	printk("module:%d, set clock disable\n", setup3.module);
+
+	/* get clock status */
+	ret = clock_control_get_status(dev, sub_system3);
+	printk("module:%d, get clock status:0x%x\n", setup3.module, ret);
+
+	/* set clock enable */
+	ret = clock_control_on(dev, sub_system3);
+	printk("module:%d, set clock enable\n", setup3.module);
+
+	/* get clock status */
+	ret = clock_control_get_status(dev, sub_system3);
+	printk("module:%d, get clock status:0x%x\n", setup3.module, ret);
+
+	/**************************************************************************/
+	/* Confirmation of Division Ratio */
+	/**************************************************************************/
+	printk("\nConfirmation of Division Ratio\n");
+	setup4.module = R_CPG_ZR2_CLOCK;
+	/* get division ratio */
+	ret = clock_control_get_rate(dev, sub_system4, &get_ratio);
+	printk("get_division_ratio:0x%x\n", get_ratio);
+
+	/* set division ratio */
+	set_ratio = 1;
+	ret = clock_control_set_rate(dev, sub_system4, (clock_control_subsys_rate_t)set_ratio);
+	printk("set_division_ratio:0x%x\n", set_ratio);
+
+	/* get division ratio */
+	ret = clock_control_get_rate(dev, sub_system4, &get_ratio);
+	printk("get_division_ratio:0x%x\n", get_ratio);
+}
+
diff --git a/tests/drivers/clock_control/cpg_sample/testcase.yaml b/tests/drivers/clock_control/cpg_sample/testcase.yaml
new file mode 100644
index 0000000000..4160b8f1d4
--- /dev/null
+++ b/tests/drivers/clock_control/cpg_sample/testcase.yaml
@@ -0,0 +1,3 @@
+tests:
+  drivers.clock.clock_control_nrf5:
+    tags: drivers cpg
diff --git a/tests/drivers/ethernet/eth_sample/CMakeLists.txt b/tests/drivers/ethernet/eth_sample/CMakeLists.txt
new file mode 100644
index 0000000000..9069e7bab5
--- /dev/null
+++ b/tests/drivers/ethernet/eth_sample/CMakeLists.txt
@@ -0,0 +1,10 @@
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.20.0)
+
+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
+project(eth_sample)
+
+FILE(GLOB app_sources src/*.c)
+target_sources(app PRIVATE ${app_sources})
diff --git a/tests/drivers/ethernet/eth_sample/Kconfig b/tests/drivers/ethernet/eth_sample/Kconfig
new file mode 100644
index 0000000000..0b9192a6a9
--- /dev/null
+++ b/tests/drivers/ethernet/eth_sample/Kconfig
@@ -0,0 +1,31 @@
+# Private config options for packet socket sample app
+
+# Copyright (c) 2020 Intel Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+mainmenu "Networking packet socket sample application"
+
+config NET_SAMPLE_SEND_WAIT_TIME
+	int "Wait time between sent packets (in ms)"
+	default 5000
+	help
+	  By default the application will send a packet every 5 seconds.
+	  If set to 0, then the packets are sent as fast as possible, which
+	  will stress test the network stack.
+
+config NET_SAMPLE_ENABLE_PACKET_DGRAM
+	bool "Use AF_PACKET with SOCK_DGRAM"
+	depends on NET_SOCKETS_PACKET_DGRAM
+	default y
+	help
+	  This will strip Ethernet header from received packets
+	  and insert Ethernet header to sent packets.
+
+config NET_SAMPLE_DESTINATION_ADDR
+	string "Destination Ethernet MAC address"
+	depends on NET_SOCKETS_PACKET_DGRAM
+	default "00:11:22:33:44:55"
+	help
+	  Where to send the Ethernet frames.
+
+source "Kconfig.zephyr"
diff --git a/tests/drivers/ethernet/eth_sample/prj.conf b/tests/drivers/ethernet/eth_sample/prj.conf
new file mode 100644
index 0000000000..b3a6aff78d
--- /dev/null
+++ b/tests/drivers/ethernet/eth_sample/prj.conf
@@ -0,0 +1,53 @@
+CONFIG_ZTEST=y
+
+# Generic networking options
+CONFIG_ETH_RCAR=y
+CONFIG_NET_L2_ETHERNET=y
+CONFIG_NETWORKING=y
+CONFIG_NET_MGMT=y
+CONFIG_NET_L2_ETHERNET_MGMT=y
+CONFIG_TEST_RANDOM_GENERATOR=y
+CONFIG_NET_UDP=n
+CONFIG_NET_TCP=n
+CONFIG_NET_IPV6=n
+CONFIG_NET_IPV4=n
+CONFIG_NET_MAX_CONTEXTS=10
+CONFIG_PTP_CLOCK=n
+
+# Packet socket configuration
+CONFIG_NET_SOCKETS=y
+CONFIG_NET_SOCKETS_PACKET=y
+
+# Destination PC MAC address
+CONFIG_NET_SAMPLE_DESTINATION_ADDR="11:22:33:44:55:66"
+
+# Board MAC address
+CONFIG_ETH_RCAR_MAC_ADDR="AA:BB:CC:DD:EE:FF"
+
+# Configuration for R-Car EtherAVB driver
+CONFIG_ETH_RCAR_RX_BUF_TOTAL=20
+CONFIG_ETH_RCAR_TX_BUF_TOTAL=10
+CONFIG_ETH_RCAR_RX_BUF_SIZE=256
+CONFIG_ETH_RCAR_TX_BUF_SIZE=256
+CONFIG_ETH_RCAR_SPEED=100
+CONFIG_PHY_INIT_PRIORITY=80
+CONFIG_ETH_INIT_PRIORITY=70
+
+# Log level
+CONFIG_ETHERNET_LOG_LEVEL_INF=y
+CONFIG_PHY_LOG_LEVEL_INF=y
+
+# Logging
+CONFIG_LOG=y
+CONFIG_NET_LOG=y
+CONFIG_NET_STATISTICS=y
+CONFIG_PRINTK=y
+
+CONFIG_NET_SOCKETS_LOG_LEVEL_DBG=n
+CONFIG_NET_CONTEXT_LOG_LEVEL_DBG=n
+CONFIG_NET_CORE_LOG_LEVEL_DBG=n
+CONFIG_NET_CONN_LOG_LEVEL_DBG=n
+CONFIG_NET_IF_LOG_LEVEL_DBG=n
+CONFIG_NET_L2_ETHERNET_LOG_LEVEL_DBG=n
+CONFIG_ETHERNET_LOG_LEVEL_DBG=n
+CONFIG_NET_PKT_LOG_LEVEL_ERR=n
diff --git a/tests/drivers/ethernet/eth_sample/src/main.c b/tests/drivers/ethernet/eth_sample/src/main.c
new file mode 100644
index 0000000000..0a2b996d04
--- /dev/null
+++ b/tests/drivers/ethernet/eth_sample/src/main.c
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/zephyr.h>
+#include <ztest.h>
+
+extern void test_ethernet(void);
+
+void test_main(void)
+{
+	ztest_test_suite(eth_test,
+			ztest_unit_test(test_ethernet));
+	ztest_run_test_suite(eth_test);
+}
diff --git a/tests/drivers/ethernet/eth_sample/src/test_ethernet.c b/tests/drivers/ethernet/eth_sample/src/test_ethernet.c
new file mode 100644
index 0000000000..c4c6052dda
--- /dev/null
+++ b/tests/drivers/ethernet/eth_sample/src/test_ethernet.c
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(eth_sample, LOG_LEVEL_DBG);
+
+#include <zephyr/zephyr.h>
+#include <errno.h>
+#include <stdio.h>
+
+#include <zephyr/posix/sys/socket.h>
+#include <zephyr/net/ethernet.h>
+
+#define STACK_SIZE 1024
+#if IS_ENABLED(CONFIG_NET_TC_THREAD_COOPERATIVE)
+#define THREAD_PRIORITY K_PRIO_COOP(CONFIG_NUM_COOP_PRIORITIES - 1)
+#else
+#define THREAD_PRIORITY K_PRIO_PREEMPT(8)
+#endif
+#define RECV_BUFFER_SIZE 128
+#define SEND_BUFFER_SIZE 128
+#define WAIT_TIME CONFIG_NET_SAMPLE_SEND_WAIT_TIME
+
+#define FLOOD (CONFIG_NET_SAMPLE_SEND_WAIT_TIME ? 0 : 1)
+
+static struct k_sem quit_lock;
+
+struct packet_data {
+	int send_sock;
+	int recv_sock;
+	char recv_buffer[RECV_BUFFER_SIZE];
+	char send_buffer[SEND_BUFFER_SIZE];
+};
+
+static struct packet_data packet;
+
+static void recv_packet(void);
+static void send_packet(void);
+
+K_THREAD_DEFINE(receiver_thread_id, STACK_SIZE,
+		recv_packet, NULL, NULL, NULL,
+		THREAD_PRIORITY, 0, -1);
+K_THREAD_DEFINE(sender_thread_id, STACK_SIZE,
+		send_packet, NULL, NULL, NULL,
+		THREAD_PRIORITY, 0, -1);
+
+static void quit(void)
+{
+	k_sem_give(&quit_lock);
+}
+
+static int start_socket(int *sock)
+{
+	struct sockaddr_ll dst = { 0 };
+	int ret;
+
+	*sock = socket(AF_PACKET,
+		       IS_ENABLED(CONFIG_NET_SAMPLE_ENABLE_PACKET_DGRAM) ?
+							SOCK_DGRAM : SOCK_RAW,
+		       ETH_P_ALL);
+	if (*sock < 0) {
+		LOG_ERR("Failed to create %s socket : %d",
+			IS_ENABLED(CONFIG_NET_SAMPLE_ENABLE_PACKET_DGRAM) ?
+							"DGRAM" : "RAW",
+			errno);
+		return -errno;
+	}
+
+	dst.sll_ifindex = net_if_get_by_iface(net_if_get_default());
+	dst.sll_family = AF_PACKET;
+
+	ret = bind(*sock, (const struct sockaddr *)&dst,
+		   sizeof(struct sockaddr_ll));
+	if (ret < 0) {
+		LOG_ERR("Failed to bind packet socket : %d", errno);
+		return -errno;
+	}
+
+	return 0;
+}
+
+static int recv_packet_socket(struct packet_data *packet)
+{
+	int ret = 0;
+	int received;
+	int i;
+	static int count = 3; /* After received 3 times, quit TP */
+
+	LOG_INF("Waiting for packets ...");
+
+	do {
+		/* Receive data */
+		received = recv(packet->recv_sock, packet->recv_buffer,
+				sizeof(packet->recv_buffer), 0);
+		if (received < 0) {
+			LOG_ERR("RAW : recv error %d", errno);
+			ret = -errno;
+			break;
+		}
+		/* Dump received data */
+		printf("[TP] received packet [len=%d]\n", received);
+		for (i = 1; i <= received; i++) {
+			printf(" 0x%02X", packet->recv_buffer[i-1]);
+			if (i % 16 == 0) {
+				printf("\n");
+			}
+		}
+		printf("\n");
+		count--;
+		printf("[TP] remaining receive count %d\n", count);
+
+	} while (count > 0);
+
+	return ret;
+}
+
+static void recv_packet(void)
+{
+	int ret;
+
+	ret = start_socket(&packet.recv_sock);
+	if (ret < 0) {
+		quit();
+		return;
+	}
+	ret = recv_packet_socket(&packet);
+	if (ret < 0) {
+		LOG_ERR("recv_packet_socket err");
+	}
+
+	/* quit TP */
+	quit();
+}
+
+static int send_packet_socket(struct packet_data *packet)
+{
+	struct sockaddr_ll dst = { 0 };
+	size_t sendlen = SEND_BUFFER_SIZE;
+	int ret;
+	int i;
+
+	dst.sll_ifindex = net_if_get_by_iface(net_if_get_default());
+
+	if (IS_ENABLED(CONFIG_NET_SAMPLE_ENABLE_PACKET_DGRAM)) {
+		dst.sll_halen = sizeof(struct net_eth_addr);
+		dst.sll_protocol = htons(ETH_P_IP);
+
+		ret = net_bytes_from_str(
+			dst.sll_addr,
+			dst.sll_halen,
+			CONFIG_NET_SAMPLE_DESTINATION_ADDR);
+		if (ret < 0) {
+			LOG_ERR("Invalid MAC address '%s'", CONFIG_NET_SAMPLE_DESTINATION_ADDR);
+		}
+		printf("[TP] CONFIG_NET_SAMPLE_DESTINATION_ADDR is %s\n", CONFIG_NET_SAMPLE_DESTINATION_ADDR);
+	}
+
+	do {
+		/* Send data */
+		ret = sendto(packet->send_sock, packet->send_buffer, sendlen, 0,
+			     (const struct sockaddr *)&dst,
+			     sizeof(struct sockaddr_ll));
+		if (ret < 0) {
+			LOG_ERR("Failed to send, errno %d", errno);
+			break;
+		}
+		/* Dump send data */
+		printf("[TP] send packet [len=%d]\n", sendlen);
+		for (i = 1; i <= sendlen; i++) {
+			printf(" 0x%02X", packet->send_buffer[i-1]);
+			if (i % 16 == 0) {
+				printf("\n");
+			}
+		}
+		printf("\n");
+
+		if (!FLOOD) {
+			k_msleep(WAIT_TIME);
+		}
+	} while (true);
+
+	return ret;
+}
+
+static void send_packet(void)
+{
+	int ret;
+
+	printf("[TP] send_packet start\n");
+
+	ret = start_socket(&packet.send_sock);
+	if (ret < 0) {
+		quit();
+		return;
+	}
+
+	ret = send_packet_socket(&packet);
+	if (ret < 0) {
+		quit();
+		return;
+	}
+}
+
+
+void test_ethernet(void)
+{
+	int i;
+
+	k_sem_init(&quit_lock, 0, K_SEM_MAX_LIMIT);
+
+	/* Create send data*/
+	for (i = 0; i < SEND_BUFFER_SIZE; i++) {
+		packet.send_buffer[i] = i + 1;
+	}
+
+	k_thread_start(receiver_thread_id);
+	k_thread_start(sender_thread_id);
+
+	k_sem_take(&quit_lock, K_FOREVER);
+
+	LOG_INF("Stopping...");
+
+	k_thread_abort(receiver_thread_id);
+	k_thread_abort(sender_thread_id);
+
+	if (packet.recv_sock > 0) {
+		(void)close(packet.recv_sock);
+	}
+	if (packet.send_sock > 0) {
+		(void)close(packet.send_sock);
+	}
+}
diff --git a/tests/drivers/ethernet/eth_sample/testcase.yaml b/tests/drivers/ethernet/eth_sample/testcase.yaml
new file mode 100644
index 0000000000..bfc75b5537
--- /dev/null
+++ b/tests/drivers/ethernet/eth_sample/testcase.yaml
@@ -0,0 +1,3 @@
+tests:
+  drivers.ethernet.eth_sample:
+    tags: drivers ethernet
diff --git a/tests/drivers/i2c/i2c_sample/CMakeLists.txt b/tests/drivers/i2c/i2c_sample/CMakeLists.txt
new file mode 100644
index 0000000000..2ef5e18c23
--- /dev/null
+++ b/tests/drivers/i2c/i2c_sample/CMakeLists.txt
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.20.0)
+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
+project(i2c_sample)
+
+FILE(GLOB app_sources src/*.c)
+target_sources(app PRIVATE ${app_sources})
diff --git a/tests/drivers/i2c/i2c_sample/prj.conf b/tests/drivers/i2c/i2c_sample/prj.conf
new file mode 100644
index 0000000000..4b19609ecf
--- /dev/null
+++ b/tests/drivers/i2c/i2c_sample/prj.conf
@@ -0,0 +1,2 @@
+CONFIG_I2C=y
+CONFIG_ZTEST=y
diff --git a/tests/drivers/i2c/i2c_sample/src/i2c1_MAX20087.c b/tests/drivers/i2c/i2c_sample/src/i2c1_MAX20087.c
new file mode 100644
index 0000000000..826af08467
--- /dev/null
+++ b/tests/drivers/i2c/i2c_sample/src/i2c1_MAX20087.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <errno.h>
+#include <zephyr.h>
+#include <sys/printk.h>
+#include <device.h>
+#include <drivers/i2c.h>
+
+/**
+ * @file Sample app using the MAX20087 through I2C.
+ */
+
+#define MAX20087_U6_I2C_ADDR	(0x50 >> 1)
+#define MAX20087_U9_I2C_ADDR	(0x54 >> 1)
+
+#define MAX20087_REG_MASK       0U
+#define MAX20087_REG_CONFIG     1U
+
+
+/*
+ *  Write register
+ */
+static int MAX20087_write_reg(const struct device *i2c_dev, const uint8_t slave_addr, const uint8_t reg, uint8_t data)
+{
+	uint8_t wr_data[2];
+	uint32_t wr_size;
+	struct i2c_msg msgs[1];
+
+	wr_data[0] = reg & 0xFF;
+	wr_data[1] = data;
+	wr_size = 2;
+
+	/* Setup I2C messages */
+
+	/* Send the command and data with STOP */
+	msgs[0].buf = wr_data;
+	msgs[0].len = wr_size;
+	msgs[0].flags = I2C_MSG_WRITE | I2C_MSG_STOP;
+
+	return i2c_transfer(i2c_dev, &msgs[0], 1, slave_addr);
+}
+
+/*
+ *  Read register
+ */
+static int MAX20087_read_reg(const struct device *i2c_dev, const uint8_t slave_addr, const uint8_t reg, uint8_t *data)
+{
+	uint8_t wr_addr[1];
+	struct i2c_msg msgs[2];
+
+	wr_addr[0] = reg;
+
+	/* Setup I2C messages */
+
+	/* Send the address to read from */
+	msgs[0].buf = wr_addr;
+	msgs[0].len = 1U;
+	msgs[0].flags = I2C_MSG_WRITE;
+
+	/* Data to be written, and STOP after this. */
+	msgs[1].buf = data;
+	msgs[1].len = 1U;
+	msgs[1].flags = I2C_MSG_READ | I2C_MSG_STOP;
+
+	return i2c_transfer(i2c_dev, &msgs[0], 2, slave_addr);
+}
+
+
+void test_sub_MAX20087(const uint8_t max20087_slave_addr)
+{
+	const struct device *i2c_dev = DEVICE_DT_GET(DT_NODELABEL(i2c1));
+	uint8_t data[1];
+	int ret;
+	uint32_t dev_config;
+
+	printk("Test for MAX20087 (0x%02X)\n", max20087_slave_addr);
+
+	if (!device_is_ready(i2c_dev)) {
+		printk("I2C: Device is not ready.\n");
+		return;
+	}
+
+	dev_config = I2C_MODE_MASTER | I2C_SPEED_SET(I2C_SPEED_FAST);
+	ret = i2c_configure(i2c_dev, dev_config);
+	if (ret != 0) {
+		printk("Error configuring. error code (%d)\n", ret);
+		return;
+	}
+
+	/* Do one-byte read/write for MASK register */
+	/* POWER-ON RESET : 0x00 */
+	ret = MAX20087_write_reg(i2c_dev, max20087_slave_addr, MAX20087_REG_MASK, 0xa5);
+
+	if (ret != 0) {
+		printk("Error writing to MAX20087! error code (%d)\n", ret);
+		return;
+	} else {
+		printk("Wrote 0xa5 to MASK register.\n");
+	}
+
+	data[0] = 0x00;
+	ret = MAX20087_read_reg(i2c_dev, max20087_slave_addr, MAX20087_REG_MASK, &data[0]);
+	if (ret != 0) {
+		printk("Error reading from MAX20087! error code (%d)\n", ret);
+		return;
+	} else {
+		printk("Read 0x%X from MASK register.\n", data[0]);
+	}
+
+
+	/* Do one-byte read/write for CONFIG register */
+	/* POWER-ON RESET : 0x1f */
+	ret = MAX20087_write_reg(i2c_dev, max20087_slave_addr, MAX20087_REG_CONFIG, 0x5a);
+
+	if (ret != 0) {
+		printk("Error writing to MAX20087! error code (%d)\n", ret);
+		return;
+	} else {
+		printk("Wrote 0x5a to CONFIG register.\n");
+	}
+
+	data[0] = 0x00;
+	ret = MAX20087_read_reg(i2c_dev, max20087_slave_addr, MAX20087_REG_CONFIG, &data[0]);
+	if (ret != 0) {
+		printk("Error reading from MAX20087! error code (%d)\n", ret);
+		return;
+	} else {
+		printk("Read 0x%X from CONFIG register.\n", data[0]);
+	}
+
+}
+
+void test_MAX20087(void)
+{
+	test_sub_MAX20087(MAX20087_U6_I2C_ADDR);
+	test_sub_MAX20087(MAX20087_U9_I2C_ADDR);
+}
diff --git a/tests/drivers/i2c/i2c_sample/src/main.c b/tests/drivers/i2c/i2c_sample/src/main.c
new file mode 100644
index 0000000000..b902dd670a
--- /dev/null
+++ b/tests/drivers/i2c/i2c_sample/src/main.c
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/zephyr.h>
+#include <ztest.h>
+
+extern void test_MAX20087(void);
+
+void test_main(void)
+{
+	ztest_test_suite(i2c_test,
+	ztest_unit_test(test_MAX20087));
+	ztest_run_test_suite(i2c_test);
+}
diff --git a/tests/drivers/i2c/i2c_sample/testcase.yaml b/tests/drivers/i2c/i2c_sample/testcase.yaml
new file mode 100644
index 0000000000..94e2f2b952
--- /dev/null
+++ b/tests/drivers/i2c/i2c_sample/testcase.yaml
@@ -0,0 +1,6 @@
+tests:
+  drivers.i2c.api:
+    depends_on: i2c
+    tags: drivers i2c
+    harness: sensor
+    filter: dt_alias_exists("accel-0")
diff --git a/tests/drivers/uart/scif_sample/CMakeLists.txt b/tests/drivers/uart/scif_sample/CMakeLists.txt
new file mode 100644
index 0000000000..5c3c0d1311
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/CMakeLists.txt
@@ -0,0 +1,13 @@
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.20.0)
+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
+project(scif_sample)
+
+target_sources(app PRIVATE
+    src/main.c
+    src/test_uart_config.c
+    src/test_uart_poll.c
+    )
+target_sources_ifdef(CONFIG_UART_INTERRUPT_DRIVEN app PRIVATE src/test_uart_fifo.c)
+target_sources_ifdef(CONFIG_UART_INTERRUPT_DRIVEN app PRIVATE src/test_uart_pending.c)
diff --git a/tests/drivers/uart/scif_sample/overlay-usb.conf b/tests/drivers/uart/scif_sample/overlay-usb.conf
new file mode 100644
index 0000000000..3af32b0ea5
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/overlay-usb.conf
@@ -0,0 +1,4 @@
+CONFIG_USB_DEVICE_STACK=y
+CONFIG_USB_DEVICE_PRODUCT="Zephyr CDC ACM UART"
+CONFIG_UART_LINE_CTRL=y
+CONFIG_TEST_LOGGING_DEFAULTS=n
diff --git a/tests/drivers/uart/scif_sample/prj.conf b/tests/drivers/uart/scif_sample/prj.conf
new file mode 100644
index 0000000000..d12c995df0
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/prj.conf
@@ -0,0 +1,4 @@
+CONFIG_SERIAL=y
+CONFIG_UART_INTERRUPT_DRIVEN=y
+CONFIG_ZTEST=y
+CONFIG_NATIVE_UART_0_ON_STDINOUT=y
diff --git a/tests/drivers/uart/scif_sample/prj_poll.conf b/tests/drivers/uart/scif_sample/prj_poll.conf
new file mode 100644
index 0000000000..772072f1c4
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/prj_poll.conf
@@ -0,0 +1,3 @@
+CONFIG_SERIAL=y
+CONFIG_ZTEST=y
+CONFIG_NATIVE_UART_0_ON_STDINOUT=y
diff --git a/tests/drivers/uart/scif_sample/prj_shell.conf b/tests/drivers/uart/scif_sample/prj_shell.conf
new file mode 100644
index 0000000000..6ecbf8931a
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/prj_shell.conf
@@ -0,0 +1,6 @@
+CONFIG_SERIAL=y
+CONFIG_UART_INTERRUPT_DRIVEN=y
+CONFIG_ZTEST=y
+CONFIG_SHELL_CMD_BUFF_SIZE=90
+CONFIG_SHELL=y
+CONFIG_NATIVE_UART_0_ON_STDINOUT=y
diff --git a/tests/drivers/uart/scif_sample/src/main.c b/tests/drivers/uart/scif_sample/src/main.c
new file mode 100644
index 0000000000..f599f429c7
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/src/main.c
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/**
+ * @addtogroup t_driver_uart
+ * @{
+ * @defgroup t_uart_basic test_uart_basic_operations
+ * @}
+ */
+
+#include <zephyr/usb/usb_device.h>
+#include "test_uart.h"
+
+#ifdef CONFIG_SHELL
+TC_CMD_DEFINE(test_uart_configure)
+TC_CMD_DEFINE(test_uart_config_get)
+TC_CMD_DEFINE(test_uart_fifo_read)
+TC_CMD_DEFINE(test_uart_fifo_fill)
+TC_CMD_DEFINE(test_uart_poll_in)
+TC_CMD_DEFINE(test_uart_poll_out)
+TC_CMD_DEFINE(test_uart_pending)
+
+SHELL_CMD_REGISTER(test_uart_configure, NULL, NULL,
+			TC_CMD_ITEM(test_uart_configure));
+SHELL_CMD_REGISTER(test_uart_config_get, NULL, NULL,
+			TC_CMD_ITEM(test_uart_config_get));
+SHELL_CMD_REGISTER(test_uart_fifo_read, NULL, NULL,
+			TC_CMD_ITEM(test_uart_fifo_read));
+SHELL_CMD_REGISTER(test_uart_fifo_fill, NULL, NULL,
+			TC_CMD_ITEM(test_uart_fifo_fill));
+SHELL_CMD_REGISTER(test_uart_poll_in, NULL, NULL,
+			TC_CMD_ITEM(test_uart_poll_in));
+SHELL_CMD_REGISTER(test_uart_poll_out, NULL, NULL,
+			TC_CMD_ITEM(test_uart_poll_out));
+SHELL_CMD_REGISTER(test_uart_pending, NULL, NULL,
+			TC_CMD_ITEM(test_uart_pending));
+#endif
+
+#ifndef CONFIG_UART_INTERRUPT_DRIVEN
+void test_uart_fifo_fill(void)
+{
+	ztest_test_skip();
+}
+
+void test_uart_fifo_read(void)
+{
+	ztest_test_skip();
+}
+
+void test_uart_pending(void)
+{
+	ztest_test_skip();
+}
+#endif
+
+void test_main(void)
+{
+#if DT_NODE_HAS_COMPAT(DT_CHOSEN(zephyr_console), zephyr_cdc_acm_uart)
+	const struct device *dev;
+	uint32_t dtr = 0;
+
+	dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+	if (!device_is_ready(dev) || usb_enable(NULL)) {
+		return;
+	}
+
+	while (!dtr) {
+		uart_line_ctrl_get(dev, UART_LINE_CTRL_DTR, &dtr);
+		k_sleep(K_MSEC(100));
+	}
+#endif
+#ifndef CONFIG_SHELL
+	ztest_test_suite(uart_basic_test,
+			 ztest_unit_test(test_uart_configure),
+			 ztest_unit_test(test_uart_config_get),
+			 ztest_unit_test(test_uart_fifo_fill),
+			 ztest_unit_test(test_uart_fifo_read),
+			 ztest_unit_test(test_uart_poll_in),
+			 ztest_unit_test(test_uart_poll_out),
+			 ztest_unit_test(test_uart_pending));
+	ztest_run_test_suite(uart_basic_test);
+#endif
+}
diff --git a/tests/drivers/uart/scif_sample/src/test_uart.h b/tests/drivers/uart/scif_sample/src/test_uart.h
new file mode 100644
index 0000000000..554821b386
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/src/test_uart.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Intel Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/**
+ * @file
+ * @brief UART cases header file
+ *
+ * Header file for UART cases
+ */
+
+#ifndef __TEST_UART_H__
+#define __TEST_UART_H__
+
+#include <zephyr/drivers/uart.h>
+#include <ztest.h>
+
+void test_uart_configure(void);
+void test_uart_config_get(void);
+void test_uart_poll_out(void);
+void test_uart_fifo_fill(void);
+void test_uart_fifo_read(void);
+void test_uart_poll_in(void);
+void test_uart_pending(void);
+
+#endif /* __TEST_UART_H__ */
diff --git a/tests/drivers/uart/scif_sample/src/test_uart_config.c b/tests/drivers/uart/scif_sample/src/test_uart_config.c
new file mode 100644
index 0000000000..361a5e1735
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/src/test_uart_config.c
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2020 Intel Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/*
+ * @addtogroup t_uart_basic
+ * @{
+ * @defgroup t_uart_config test_uart_config
+ * @brief TestPurpose: verify UART configure API settings
+ * @details
+ * - Test Steps
+ *   - Configure: test_uart_configure( )
+ *   - Configure Get: test_uart_config_get( )
+ * - Expected Results
+ *   -# When test UART CONFIG Configure, the value of configurations actually
+ *      set will be equal to the original configuration values (from device
+ *      tree or run-time configuration to modify those loaded initially from
+ *      device tree)
+ *   -# When test UART CONFIG Configure Get, the app will get/retrieve the
+ *      value of configurations stored at location and to be passed to UART
+ *      CONFIG Configure
+ * @}
+ */
+
+#include "test_uart.h"
+struct uart_config uart_cfg_check;
+const struct uart_config uart_cfg = {
+		.baudrate = 115200,
+		.parity = UART_CFG_PARITY_NONE,
+		.stop_bits = UART_CFG_STOP_BITS_1,
+		.data_bits = UART_CFG_DATA_BITS_8,
+		.flow_ctrl = UART_CFG_FLOW_CTRL_NONE
+	};
+
+static int test_configure(void)
+{
+	const struct device *uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+
+	if (!device_is_ready(uart_dev)) {
+		TC_PRINT("UART device not ready\n");
+		return TC_FAIL;
+	}
+
+	/* Verify configure() - set device configuration using data in cfg */
+	int ret = uart_configure(uart_dev, &uart_cfg);
+
+	if (ret == -ENOSYS) {
+		return TC_SKIP;
+	}
+
+	/* 0 if successful, - error code otherwise */
+	return (ret == 0) ? TC_PASS : TC_FAIL;
+
+}
+
+/* test UART configure get (retrieve configuration) */
+static int test_config_get(void)
+{
+	const struct device *uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+
+	if (!device_is_ready(uart_dev)) {
+		TC_PRINT("UART device not ready\n");
+		return TC_FAIL;
+	}
+
+	TC_PRINT("This is a configure_get test.\n");
+
+	/* Verify configure() - set device configuration using data in cfg */
+	/* 0 if successful, - error code otherwise */
+	int ret = uart_configure(uart_dev, &uart_cfg);
+
+	if (ret == -ENOSYS) {
+		return TC_SKIP;
+	}
+
+	zassert_true(ret == 0, "set config error");
+
+	/* Verify config_get() - get device configuration, put in cfg */
+	/* 0 if successful, - error code otherwise */
+	/* so get the configurations from the device and check */
+	ret = uart_config_get(uart_dev, &uart_cfg_check);
+	zassert_true(ret == 0, "get config error");
+
+	/* Confirm the values from device are the values put in cfg*/
+	if (memcmp(&uart_cfg, &uart_cfg_check, sizeof(uart_cfg)) != 0) {
+		return TC_FAIL;
+	} else {
+		return TC_PASS;
+	}
+}
+
+void test_uart_configure(void)
+{
+	int ret = test_configure();
+
+	zassert_true((ret == TC_PASS) || (ret == TC_SKIP), NULL);
+}
+
+void test_uart_config_get(void)
+{
+	int ret = test_config_get();
+
+	zassert_true((ret == TC_PASS) || (ret == TC_SKIP), NULL);
+}
diff --git a/tests/drivers/uart/scif_sample/src/test_uart_fifo.c b/tests/drivers/uart/scif_sample/src/test_uart_fifo.c
new file mode 100644
index 0000000000..e247b1671d
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/src/test_uart_fifo.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/*
+ * @addtogroup t_uart_basic
+ * @{
+ * @defgroup t_uart_fifo test_uart_fifo
+ * @brief TestPurpose: verify UART works well in fifo mode
+ * @details
+ * - Test Steps
+ *   - FIFO Output:
+ *      -# Set UART IRQ callback using uart_irq_callback_set().
+ *      -# Enable UART TX IRQ using uart_irq_tx_enable().
+ *      -# Output the prepared data using uart_fifo_fill().
+ *      -# Disable UART TX IRQ using uart_irq_tx_disable().
+ *      -# Compare the number of characters sent out with the
+ *         original data size.
+ *   - FIFO Input:
+ *      -# Set UART IRQ callback using uart_irq_callback_set().
+ *      -# Enable UART RX IRQ using uart_irq_rx_enable().
+ *      -# Wait for data sent to UART console and trigger RX IRQ.
+ *      -# Read data from UART console using uart_fifo_read().
+ *      -# Disable UART TX IRQ using uart_irq_rx_disable().
+ * - Expected Results
+ *   -# When test UART FIFO output, the number of characters actually
+ *      sent out will be equal to the original length of the characters.
+ *   -# When test UART FIFO input, the app will wait for input from UART
+ *      console and exit after receiving one character.
+ * @}
+ */
+
+#include "test_uart.h"
+
+static volatile bool data_transmitted;
+static volatile bool data_received;
+static int char_sent;
+static const char fifo_data[] = "This is a FIFO test.\r\n";
+
+#define DATA_SIZE	(sizeof(fifo_data) - 1)
+
+static void uart_fifo_callback(const struct device *dev, void *user_data)
+{
+	uint8_t recvData;
+	static int tx_data_idx;
+
+	ARG_UNUSED(user_data);
+
+	/* Verify uart_irq_update() */
+	if (!uart_irq_update(dev)) {
+		TC_PRINT("retval should always be 1\n");
+		return;
+	}
+
+	/* Verify uart_irq_tx_ready() */
+	/* Note that TX IRQ may be disabled, but uart_irq_tx_ready() may
+	 * still return true when ISR is called for another UART interrupt,
+	 * hence additional check for i < DATA_SIZE.
+	 */
+	if (uart_irq_tx_ready(dev) && tx_data_idx < DATA_SIZE) {
+		/* We arrive here by "tx ready" interrupt, so should always
+		 * be able to put at least one byte into a FIFO. If not,
+		 * well, we'll fail test.
+		 */
+		if (uart_fifo_fill(dev,
+				   (uint8_t *)&fifo_data[tx_data_idx++], 1) > 0) {
+			data_transmitted = true;
+			char_sent++;
+		}
+
+		if (tx_data_idx == DATA_SIZE) {
+			/* If we transmitted everything, stop IRQ stream,
+			 * otherwise main app might never run.
+			 */
+			uart_irq_tx_disable(dev);
+		}
+	}
+
+	/* Verify uart_irq_rx_ready() */
+	if (uart_irq_rx_ready(dev)) {
+		/* Verify uart_fifo_read() */
+		uart_fifo_read(dev, &recvData, 1);
+		TC_PRINT("%c", recvData);
+
+		if ((recvData == '\n') || (recvData == '\r')) {
+			data_received = true;
+		}
+	}
+}
+
+static int test_fifo_read(void)
+{
+	const struct device *uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+
+	if (!device_is_ready(uart_dev)) {
+		TC_PRINT("UART device not ready\n");
+		return TC_FAIL;
+	}
+
+	/* Verify uart_irq_callback_set() */
+	uart_irq_callback_set(uart_dev, uart_fifo_callback);
+
+	/* Enable Tx/Rx interrupt before using fifo */
+	/* Verify uart_irq_rx_enable() */
+	uart_irq_rx_enable(uart_dev);
+
+	TC_PRINT("Please send characters to serial console\n");
+
+	data_received = false;
+	while (data_received == false) {
+		/* Allow other thread/workqueue to work. */
+		k_yield();
+	}
+
+	/* Verify uart_irq_rx_disable() */
+	uart_irq_rx_disable(uart_dev);
+
+	return TC_PASS;
+}
+
+static int test_fifo_fill(void)
+{
+	const struct device *uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+
+	if (!device_is_ready(uart_dev)) {
+		TC_PRINT("UART device not ready\n");
+		return TC_FAIL;
+	}
+
+	char_sent = 0;
+
+	/* Verify uart_irq_callback_set() */
+	uart_irq_callback_set(uart_dev, uart_fifo_callback);
+
+	/* Enable Tx/Rx interrupt before using fifo */
+	/* Verify uart_irq_tx_enable() */
+	uart_irq_tx_enable(uart_dev);
+
+	k_sleep(K_MSEC(500));
+
+	/* Verify uart_irq_tx_disable() */
+	uart_irq_tx_disable(uart_dev);
+
+	if (!data_transmitted) {
+		return TC_FAIL;
+	}
+
+	if (char_sent == DATA_SIZE) {
+		return TC_PASS;
+	} else {
+		return TC_FAIL;
+	}
+
+}
+
+void test_uart_fifo_fill(void)
+{
+	zassert_true(test_fifo_fill() == TC_PASS, NULL);
+}
+
+void test_uart_fifo_read(void)
+{
+	zassert_true(test_fifo_read() == TC_PASS, NULL);
+}
diff --git a/tests/drivers/uart/scif_sample/src/test_uart_pending.c b/tests/drivers/uart/scif_sample/src/test_uart_pending.c
new file mode 100644
index 0000000000..db8d1ec698
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/src/test_uart_pending.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2021 Linaro Limited
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/*
+ * @addtogroup t_uart_basic
+ * @{
+ * @defgroup t_uart_fifo test_uart_pending
+ * @brief TestPurpose: test UART uart_irq_is_pending()
+ * @details
+ *
+ * Test if uart_irq_is_pending() correctly returns 0 when there are no
+ * more RX and TX pending interrupts.
+ *
+ * The test consists in disabling TX IRQ so no TX interrupts are
+ * generated and the TX IRQ pending flag is never set. At the same time
+ * RX IRQ is enabled to let received data cause a RX IRQ and so set the
+ * RX IRQ pending flag.
+ *
+ * Then a message is sent via serial to inform that the test is ready to
+ * receive serial data, which will trigger a RX IRQ.
+ *
+ * Once a RX IRQ happens RX data is read by uart_fifo_read() until there
+ * is no more RX data to be popped from FIFO and all IRQs are handled.
+ * When that happens uart_irq_is_pending() is called and must return 0,
+ * indicating there are no more pending interrupts to be processed. If 0
+ * is returned the test passes.
+ *
+ * In some cases uart_irq_is_pending() does not correctly use the IRQ
+ * pending flags to determine if there are pending interrupts, hence
+ * even tho there aren't any further RX and TX IRQs to be processed it
+ * wrongly returns 1. If 1 is returned the test fails.
+ *
+ * @}
+ */
+
+#include "test_uart.h"
+
+#define MAX_NUM_TRIES 512
+#define NOT_READY 0
+
+#define FAILED	0
+#define PASSED	1
+#define WAIT	2
+static int volatile status;
+
+static void uart_pending_callback(const struct device *dev, void *user_data)
+{
+	ARG_UNUSED(user_data);
+
+	int num_tries = 0;
+	char recv_char;
+
+	/*
+	 * If the bug is not present uart_fifo_read() will pop all
+	 * received data until there is no more RX data, thus
+	 * uart_irq_is_pending() must correctly return 0 indicating
+	 * that there are no more RX interrupts to be processed.
+	 * Otherwise uart_irq_is_pending() never returns 0 even tho
+	 * there is no more RX data in the RX buffer to be processed,
+	 * so, in that case, the test fails after MAX_NUM_TRIES attempts.
+	 */
+	status = PASSED;
+	while (uart_irq_update(dev) && uart_irq_is_pending(dev)) {
+		if (uart_irq_rx_ready(dev) == NOT_READY) {
+			if (num_tries < MAX_NUM_TRIES) {
+				num_tries++;
+				continue;
+			} else {
+				/*
+				 * Bug: no more tries; uart_irq_is_pending()
+				 * always returned 1 in spite of having no more
+				 * RX data to be read from FIFO and no more TX
+				 * data in FIFO to be sent via serial line.
+				 * N.B. uart_irq_update() always returns 1, thus
+				 * uart_irq_is_pending() got stuck without any
+				 * real pending interrupt, i.e. no more RX and
+				 * TX data to be popped or pushed from/to FIFO.
+				 */
+				status = FAILED;
+				break;
+			}
+		}
+
+		while (uart_fifo_read(dev, &recv_char, 1)) {
+			/* Echo received char */
+			TC_PRINT("%c", recv_char);
+		}
+	}
+}
+
+static int test_pending(void)
+{
+	const struct device *uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+
+	if (!device_is_ready(uart_dev)) {
+		TC_PRINT("UART device not ready\n");
+		return TC_FAIL;
+	}
+
+	/*
+	 * Set IRQ callback function to handle RX IRQ.
+	 */
+	uart_irq_callback_set(uart_dev, uart_pending_callback);
+
+	/*
+	 * Disable TX IRQ since transmitted data is not
+	 * handled by uart_pending_callback() and we don't
+	 * want to trigger any TX IRQ for this test.
+	 */
+	uart_irq_tx_disable(uart_dev);
+
+	/*
+	 * Enable RX IRQ so uart_pending_callback() can
+	 * handle input data is available in RX FIFO.
+	 */
+	uart_irq_rx_enable(uart_dev);
+
+	status = WAIT;
+
+	/* Inform test is ready to receive data */
+	TC_PRINT("Please send characters to serial console\n");
+
+	while (status == WAIT) {
+		/* Allow other thread/workqueue to work. */
+		k_yield();
+		/*
+		 * Wait RX handler change 'status' properly:
+		 * it will change to PASSED or FAILED after
+		 * uart_irq_is_pending() is tested by
+		 * uart_pending_callback() upon data reception.
+		 */
+	}
+
+	if (status == PASSED) {
+		return TC_PASS;
+	} else {
+		return TC_FAIL;
+	}
+}
+
+void test_uart_pending(void)
+{
+	zassert_true(test_pending() == TC_PASS, NULL);
+}
diff --git a/tests/drivers/uart/scif_sample/src/test_uart_poll.c b/tests/drivers/uart/scif_sample/src/test_uart_poll.c
new file mode 100644
index 0000000000..2747154213
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/src/test_uart_poll.c
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include "test_uart.h"
+
+static const char *poll_data = "This is a POLL test.\r\n";
+
+static int test_poll_in(void)
+{
+	unsigned char recv_char;
+	const struct device *uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+
+	if (!device_is_ready(uart_dev)) {
+		TC_PRINT("UART device not ready\n");
+		return TC_FAIL;
+	}
+
+	TC_PRINT("Please send characters to serial console\n");
+
+	/* Verify uart_poll_in() */
+	while (1) {
+		while (uart_poll_in(uart_dev, &recv_char) < 0) {
+			/* Allow other thread/workqueue to work. */
+			k_yield();
+		}
+
+		TC_PRINT("%c", recv_char);
+
+		if ((recv_char == '\n') || (recv_char == '\r')) {
+			break;
+		}
+	}
+
+	return TC_PASS;
+}
+
+static int test_poll_out(void)
+{
+	int i;
+	const struct device *uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+
+	if (!device_is_ready(uart_dev)) {
+		TC_PRINT("UART device not ready\n");
+		return TC_FAIL;
+	}
+
+	/* Verify uart_poll_out() */
+	for (i = 0; i < strlen(poll_data); i++) {
+		uart_poll_out(uart_dev, poll_data[i]);
+	}
+
+	return TC_PASS;
+}
+
+void test_uart_poll_out(void)
+{
+	zassert_true(test_poll_out() == TC_PASS, NULL);
+}
+
+void test_uart_poll_in(void)
+{
+	zassert_true(test_poll_in() == TC_PASS, NULL);
+}
diff --git a/tests/drivers/uart/scif_sample/testcase.yaml b/tests/drivers/uart/scif_sample/testcase.yaml
new file mode 100644
index 0000000000..09d67a9843
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/testcase.yaml
@@ -0,0 +1,29 @@
+tests:
+  drivers.uart.basic_api:
+    tags: drivers
+    filter: CONFIG_UART_CONSOLE
+    harness: keyboard
+    integration_platforms:
+      - mps2_an385
+  drivers.uart.basic_api.poll:
+    extra_args: CONF_FILE=prj_poll.conf
+    tags: drivers
+    filter: CONFIG_UART_CONSOLE
+    harness: keyboard
+    integration_platforms:
+      - mps2_an385
+  drivers.uart.basic_api.shell:
+    extra_args: CONF_FILE=prj_shell.conf
+    min_flash: 64
+    tags: drivers
+    filter: CONFIG_UART_CONSOLE
+    harness: keyboard
+    integration_platforms:
+      - mps2_an385
+  drivers.uart.basic_api.cdc_acm:
+    extra_args: OVERLAY_CONFIG="overlay-usb.conf"
+                DTC_OVERLAY_FILE="usb.overlay"
+    tags: drivers usb
+    filter: CONFIG_UART_CONSOLE
+    depends_on: usb_device
+    harness: keyboard
diff --git a/tests/drivers/uart/scif_sample/usb.overlay b/tests/drivers/uart/scif_sample/usb.overlay
new file mode 100644
index 0000000000..a3c18afd70
--- /dev/null
+++ b/tests/drivers/uart/scif_sample/usb.overlay
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2021 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/ {
+	chosen {
+		zephyr,console = &cdc_acm_uart0;
+	};
+};
+
+&zephyr_udc0 {
+	cdc_acm_uart0: cdc_acm_uart0 {
+		compatible = "zephyr,cdc-acm-uart";
+		label = "CDC_ACM_0";
+	};
+};
diff --git a/tests/subsys/pm/sysc_sample/CMakeLists.txt b/tests/subsys/pm/sysc_sample/CMakeLists.txt
new file mode 100644
index 0000000000..dffea20fe0
--- /dev/null
+++ b/tests/subsys/pm/sysc_sample/CMakeLists.txt
@@ -0,0 +1,9 @@
+# Copyright (c) 2022, CSIRO.
+# Copyright (c) 2022 Renesas Electronics Corporation
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.20.0)
+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
+project(sysc_sample)
+
+target_sources(app PRIVATE src/main.c)
diff --git a/tests/subsys/pm/sysc_sample/app.overlay b/tests/subsys/pm/sysc_sample/app.overlay
new file mode 100644
index 0000000000..9feb0883e0
--- /dev/null
+++ b/tests/subsys/pm/sysc_sample/app.overlay
@@ -0,0 +1,11 @@
+/ {
+	power_domain {
+		sysc_test_pdr64: sysc_test_pdr64 {
+			compatible = "power-domain-sysc";
+			status = "okay";
+			label = "test_pdr64";
+			power-domain-number = <64>;
+			syscon = <&sysc>;
+		};
+	};
+};
diff --git a/tests/subsys/pm/sysc_sample/prj.conf b/tests/subsys/pm/sysc_sample/prj.conf
new file mode 100644
index 0000000000..a9d3252581
--- /dev/null
+++ b/tests/subsys/pm/sysc_sample/prj.conf
@@ -0,0 +1,12 @@
+# Copyright (c) 2022, Commonwealth Scientific and Industrial Research
+# Organisation (CSIRO) ABN 41 687 119 230.
+# Copyright (c) 2022 Renesas Electronics Corporation
+CONFIG_ZTEST=y
+CONFIG_PM=y
+CONFIG_PM_DEVICE=y
+CONFIG_PM_DEVICE_RUNTIME=y
+CONFIG_PM_DEVICE_POWER_DOMAIN=y
+
+CONFIG_POWER_DOMAIN=y
+CONFIG_POWER_DOMAIN_SYSC=y
+
diff --git a/tests/subsys/pm/sysc_sample/src/main.c b/tests/subsys/pm/sysc_sample/src/main.c
new file mode 100644
index 0000000000..f869c64c88
--- /dev/null
+++ b/tests/subsys/pm/sysc_sample/src/main.c
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2022 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <ztest.h>
+#include <pm/device.h>
+#include <pm/device_runtime.h>
+
+static void test_demo(void)
+{
+	const struct device *pwr_a1dsp0 = DEVICE_DT_GET(DT_NODELABEL(sysc_a1dsp0));
+	const struct device *pwr_a2cn0 = DEVICE_DT_GET(DT_NODELABEL(sysc_a2cn0));
+	const struct device *pwr_a3ir = DEVICE_DT_GET(DT_NODELABEL(sysc_a3ir));
+	enum pm_device_state state;
+
+	TC_PRINT("Enabling runtime power management on regulators\n");
+
+	/* get state */
+	pm_device_state_get(pwr_a3ir, &state);
+	TC_PRINT("Get Power State: %d, name:%s (Before executing enable)\n", state, pwr_a3ir->name);
+	/* get state */
+	pm_device_state_get(pwr_a2cn0, &state);
+	TC_PRINT("Get Power State: %d, name:%s (Before executing enable)\n", state, pwr_a2cn0->name);
+	/* get state */
+	pm_device_state_get(pwr_a1dsp0, &state);
+	TC_PRINT("Get Power State: %d, name:%s (Before executing enable)\n", state, pwr_a1dsp0->name);
+	TC_PRINT("\n");
+
+	/* enable */
+	pm_device_runtime_enable(pwr_a3ir);
+	/* enable */
+	pm_device_runtime_enable(pwr_a2cn0);
+	/* enable */
+	pm_device_runtime_enable(pwr_a1dsp0);
+
+	/* get state */
+	pm_device_state_get(pwr_a3ir, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing enable)\n", state, pwr_a3ir->name);
+	/* get state */
+	pm_device_state_get(pwr_a2cn0, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing enable)\n", state, pwr_a2cn0->name);
+	/* get state */
+	pm_device_state_get(pwr_a1dsp0, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing enable)\n", state, pwr_a1dsp0->name);
+	TC_PRINT("\n");
+
+	/* Power ON 1st time */
+	TC_PRINT("Power ON(1st): %s\n", pwr_a3ir->name);
+	pm_device_runtime_get(pwr_a3ir);
+	/* Power ON 2nd time */
+	TC_PRINT("Power ON(2nd): %s\n", pwr_a3ir->name);
+	pm_device_runtime_get(pwr_a3ir);
+	/* Power ON */
+	TC_PRINT("Power ON: %s\n", pwr_a2cn0->name);
+	pm_device_runtime_get(pwr_a2cn0);
+	/* Power ON */
+	TC_PRINT("Power ON: %s\n", pwr_a1dsp0->name);
+	pm_device_runtime_get(pwr_a1dsp0);
+	TC_PRINT("\n");
+
+	/* get state */
+	pm_device_state_get(pwr_a3ir, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing power on(1st,2nd))\n", state, pwr_a3ir->name);
+	/* get state */
+	pm_device_state_get(pwr_a2cn0, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing power on)\n", state, pwr_a2cn0->name);
+	/* get state */
+	pm_device_state_get(pwr_a1dsp0, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing power on)\n", state, pwr_a1dsp0->name);
+	TC_PRINT("\n");
+
+	/* Power OFF */
+	TC_PRINT("Power OFF: %s\n", pwr_a1dsp0->name);
+	pm_device_runtime_put(pwr_a1dsp0);
+	/* Power OFF */
+	TC_PRINT("Power OFF: %s\n", pwr_a2cn0->name);
+	pm_device_runtime_put(pwr_a2cn0);
+	/* Power OFF 1st time */
+	TC_PRINT("Power OFF(1st): %s\n", pwr_a3ir->name);
+	pm_device_runtime_put(pwr_a3ir);
+	TC_PRINT("\n");
+
+	/* get state */
+	pm_device_state_get(pwr_a3ir, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing power off)\n", state, pwr_a3ir->name);
+	/* get state */
+	pm_device_state_get(pwr_a2cn0, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing power off)\n", state, pwr_a2cn0->name);
+	/* get state */
+	pm_device_state_get(pwr_a1dsp0, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing power off)\n", state, pwr_a1dsp0->name);
+	TC_PRINT("\n");
+
+	/* Power OFF 2nd time */
+	TC_PRINT("Power OFF(2nd): %s\n", pwr_a3ir->name);
+	pm_device_runtime_put(pwr_a3ir);
+	/* get state */
+	pm_device_state_get(pwr_a3ir, &state);
+	TC_PRINT("Get Power State: %d, name:%s (After executing power off(2nd))\n", state, pwr_a3ir->name);
+	TC_PRINT("\n");
+
+	TC_PRINT("DONE\n");
+}
+
+void test_main(void)
+{
+	ztest_test_suite(device_power_domain,
+	ztest_unit_test(test_demo));
+	ztest_run_test_suite(device_power_domain);
+}
diff --git a/tests/subsys/pm/sysc_sample/testcase.yaml b/tests/subsys/pm/sysc_sample/testcase.yaml
new file mode 100644
index 0000000000..bbee216298
--- /dev/null
+++ b/tests/subsys/pm/sysc_sample/testcase.yaml
@@ -0,0 +1,4 @@
+tests:
+  pm.power_domain.device:
+    tags: pm
+    platform_allow: rcar_v4h_white_hawk_cr52_defconfig
